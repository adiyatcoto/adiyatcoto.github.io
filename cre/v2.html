<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RSA Engine - PRO (v2.9.24)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;700&family=Inter:wght@400;500;600&display=swap" rel="stylesheet">
    <style>
        /* --- CORE THEME --- */
        :root {
            --bg-main: #09090b;
            --bg-panel: #18181b;
            --border-color: rgba(255, 255, 255, 0.08);
            --accent-blue: #3b82f6;
            --accent-yellow: #facc15;
            --text-primary: #e4e4e7;
        }

        body {
            background-color: var(--bg-main);
            color: var(--text-primary);
            font-family: 'Inter', sans-serif;
            display: flex;
            flex-direction: column;
            min-height: 100vh;
            scrollbar-width: thin;
            scrollbar-color: #3f3f46 transparent;
        }

        .mono { font-family: 'JetBrains Mono', monospace; }
        
        /* --- GLASSMOPHISM PANELS --- */
        .glass-panel {
            background-color: rgba(24, 24, 27, 0.6);
            backdrop-filter: blur(12px);
            border: 1px solid var(--border-color);
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
        }

        .chart-container {
            background-color: var(--bg-panel);
            border: 1px solid var(--border-color);
            position: relative;
            cursor: crosshair;
            overflow: hidden;
            transition: border-color 0.2s;
        }
        .chart-container:hover {
            border-color: rgba(59, 130, 246, 0.3);
        }

        canvas { display: block; width: 100%; height: 100%; }
        
        input::placeholder { color: #52525b; }
        input:focus { outline: none; border-color: var(--accent-blue); box-shadow: 0 0 0 1px var(--accent-blue); }

        /* --- SWITCH COMPONENT --- */
        .switch {
            position: relative;
            display: inline-block;
            width: 36px;
            height: 18px;
        }
        .switch input { opacity: 0; width: 0; height: 0; }
        .slider {
            position: absolute;
            cursor: pointer;
            top: 0; left: 0; right: 0; bottom: 0;
            background-color: #3f3f46;
            transition: .3s;
            border-radius: 18px;
        }
        .slider:before {
            position: absolute;
            content: "";
            height: 14px; width: 14px;
            left: 2px; bottom: 2px;
            background-color: white;
            transition: .3s;
            border-radius: 50%;
        }
        input:checked + .slider { background-color: var(--accent-blue); }
        input:checked + .slider:before { transform: translateX(18px); }

        /* --- BUTTONS --- */
        .scale-btn {
            font-size: 9px;
            padding: 2px 8px;
            border-radius: 4px;
            background: #27272a;
            border: 1px solid #3f3f46;
            color: #a1a1aa;
            transition: all 0.2s;
            font-weight: 600;
        }
        .scale-btn:hover { background: #3f3f46; color: white; }
        .scale-btn.active {
            background: rgba(59, 130, 246, 0.15);
            color: #60a5fa;
            border-color: #3b82f6;
        }
        
        .action-btn {
            background: linear-gradient(to bottom, #2563eb, #1d4ed8);
            border: 1px solid #1e40af;
            box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
        }
        .action-btn:hover { background: linear-gradient(to bottom, #1d4ed8, #1e3a8a); }
        
        .icon-btn {
            background: rgba(255,255,255,0.05);
            border: 1px solid rgba(255,255,255,0.1);
            color: #a1a1aa;
            transition: all 0.2s;
        }
        .icon-btn:hover {
            background: rgba(255,255,255,0.1);
            color: white;
        }

        /* --- LOADING OVERLAY --- */
        #loadingOverlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(9, 9, 11, 0.98);
            backdrop-filter: blur(5px);
            z-index: 100;
            display: flex; justify-content: center; align-items: center;
            flex-direction: column;
            transition: opacity 0.4s ease-out;
        }
        .hidden { opacity: 0; pointer-events: none; }
        
        /* Table Styles */
        .data-row { border-bottom: 1px solid var(--border-color); transition: background 0.1s; }
        .data-row:hover { background-color: rgba(255,255,255,0.02); }
        .data-row:last-child { border-bottom: none; }
    </style>
</head>
<body class="p-4 md:p-6 overflow-x-hidden">

    <div id="loadingOverlay">
        <div class="flex flex-col items-center gap-6">
            <div class="relative w-16 h-16">
                <div class="absolute inset-0 border-2 border-blue-500/20 rounded-full"></div>
                <div class="absolute inset-0 border-t-2 border-blue-500 rounded-full animate-spin"></div>
                <div class="absolute inset-4 bg-blue-500/10 rounded-full animate-pulse"></div>
            </div>
            <div class="text-center">
                <div id="loadingTitle" class="text-white font-bold text-lg mono tracking-[0.2em]">INITIALIZING</div>
                <div id="loadingSubtitle" class="text-gray-500 text-xs mt-2 mono uppercase tracking-widest">System Boot Sequence</div>
            </div>
        </div>
    </div>

    <div class="glass-panel rounded-xl p-4 mb-6 flex flex-col lg:flex-row justify-between items-center gap-6 sticky top-4 z-40">
        
        <div class="flex flex-col gap-1 w-full lg:w-auto">
            <div class="flex items-center gap-3">
                <div class="w-2 h-8 bg-blue-600 rounded-sm"></div>
                <div>
                    <h1 class="text-lg font-bold text-white tracking-wide leading-none">RSA ENGINE <span class="text-blue-500 text-xs align-top opacity-80 border border-blue-500/30 px-1 rounded">PRO</span></h1>
                    <p class="text-[10px] text-gray-500 mono uppercase tracking-widest mt-1">Recursive Structure Analysis</p>
                </div>
                
                <div id="headerWarning" class="hidden ml-2 flex items-center gap-2 px-3 py-1 bg-red-500/10 border border-red-500/30 rounded text-red-400 text-[10px] font-bold tracking-wider animate-pulse shadow-[0_0_10px_rgba(239,68,68,0.2)]">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" class="w-3 h-3">
                        <path fill-rule="evenodd" d="M8.485 2.495c.673-1.167 2.357-1.167 3.03 0l6.28 10.875c.673 1.167-.17 2.625-1.516 2.625H3.72c-1.347 0-2.189-1.458-1.515-2.625l6.28-10.875zM10 5a.75.75 0 01.75.75v3.5a.75.75 0 01-1.5 0v-3.5A.75.75 0 0110 5zm0 9a1 1 0 100-2 1 1 0 000 2z" clip-rule="evenodd" />
                    </svg>
                    <span>CONNECTION LOST</span>
                </div>
            </div>
        </div>

        <div class="flex items-center gap-4 bg-black/20 px-4 py-2 rounded-lg border border-white/5">
            <div class="flex flex-col items-start gap-1">
                <span class="text-[9px] text-gray-500 mono font-bold uppercase">Active Cycle</span>
                <span id="cycle-info" class="text-[11px] text-gray-300 mono">Loading...</span>
            </div>
            <div class="w-px h-8 bg-white/10 mx-2"></div>
            <div class="flex flex-col items-start gap-1">
                <span class="text-[9px] text-gray-500 mono font-bold uppercase">Timeframe</span>
                <div class="flex items-center gap-2">
                    <label class="switch">
                        <input type="checkbox" id="modeToggle" onchange="toggleMode()">
                        <span class="slider"></span>
                    </label>
                    <span id="modeLabel" class="text-[10px] mono text-blue-400 font-bold uppercase">ATOMIC</span>
                </div>
            </div>
        </div>

        <div class="flex items-center gap-3 w-full lg:w-auto justify-end">
            <button onclick="toggleFullscreen()" class="icon-btn p-2 rounded-lg" title="Toggle Fullscreen">
                <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-4 h-4">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M3.75 3.75v4.5m0-4.5h4.5m-4.5 0L9 9M3.75 20.25v-4.5m0 4.5h4.5m-4.5 0L9 15M20.25 3.75h-4.5m4.5 0v4.5m0-4.5L15 9m5.25 11.25h-4.5m4.5 0v-4.5m0 4.5L15 15" />
                </svg>
            </button>

            <div class="relative group">
                <input type="text" id="tickerInput" list="tickerList" placeholder="BTCUSDT" 
                       class="bg-[#09090b] border border-[#27272a] pl-3 pr-10 py-2 rounded text-sm text-white mono w-32 focus:w-40 transition-all">
                <div class="absolute right-2 top-2.5 text-gray-600 text-[10px]">üîç</div>
                <datalist id="tickerList"></datalist>
            </div>
            
            <button onclick="changeTicker()" class="action-btn text-white px-5 py-2 rounded text-xs font-bold tracking-wider hover:brightness-110 transition active:scale-95">
                LOAD
            </button>
            
            <div class="text-right pl-4 border-l border-white/10">
                <div id="livePrice" class="text-xl font-bold text-[#26a69a] mono tracking-tight leading-none mb-1">--.---</div>
                <div class="flex flex-col items-end">
                    <div id="currentDate" class="text-[10px] text-gray-400 mono font-medium tracking-wide">-- --- ----</div>
                    <div id="currentTime" class="text-[10px] text-gray-500 mono font-medium">--:--:-- UTC</div>
                </div>
            </div>
        </div>
    </div>

    <div class="glass-panel rounded-xl overflow-hidden mb-6">
        <div class="overflow-x-auto">
            <table class="w-full text-left text-xs mono">
                <thead class="bg-[#101012] text-gray-500 border-b border-white/10 uppercase tracking-wider text-[10px]">
                    <tr>
                        <th class="p-4 font-medium">Level</th>
                        <th class="p-4 font-medium">Context</th>
                        <th class="p-4 font-medium">Progress</th>
                        <th class="p-4 font-medium">Full Expiry (UTC)</th>
                        <th class="p-4 font-medium text-right text-yellow-500">Equilibrium</th>
                        <th class="p-4 font-medium text-right">Delta</th>
                        <th class="p-4 font-medium text-right">Trend Conclusion</th>
                    </tr>
                </thead>
                <tbody id="statsTableBody" class="text-gray-300">
                    <tr><td colspan="7" class="p-8 text-center text-gray-600 italic">Awaiting data stream...</td></tr>
                </tbody>
            </table>
        </div>
    </div>

    <div class="grid grid-cols-1 lg:grid-cols-2 gap-4 h-[900px] mb-6">
        <div class="chart-container rounded-lg p-1 flex flex-col" id="container-0">
            <div class="flex justify-between items-center px-3 py-2 bg-[#101012] border-b border-white/5">
                <div class="text-[10px] font-bold text-gray-400 uppercase tracking-widest flex items-center gap-2">
                    <span class="w-1.5 h-1.5 rounded-full bg-purple-500"></span>
                    <span id="title-0">Window 1</span>
                </div>
                <div class="flex gap-1">
                    <button onclick="setScale(0, false)" id="scale-lin-0" class="scale-btn active">LIN</button>
                    <button onclick="setScale(0, true)" id="scale-log-0" class="scale-btn">LOG</button>
                </div>
            </div>
            <div class="flex-1 relative bg-[#09090b]">
                <canvas id="chart-0"></canvas>
                <div class="absolute bottom-2 left-2 text-[9px] text-gray-700 mono pointer-events-none">ZOOM: SCROLL | PAN: DRAG</div>
            </div>
        </div>

        <div class="chart-container rounded-lg p-1 flex flex-col" id="container-1">
            <div class="flex justify-between items-center px-3 py-2 bg-[#101012] border-b border-white/5">
                <div class="text-[10px] font-bold text-gray-400 uppercase tracking-widest flex items-center gap-2">
                    <span class="w-1.5 h-1.5 rounded-full bg-blue-500"></span>
                    <span id="title-1">Window 2</span>
                </div>
                <div class="flex gap-1">
                    <button onclick="setScale(1, false)" id="scale-lin-1" class="scale-btn active">LIN</button>
                    <button onclick="setScale(1, true)" id="scale-log-1" class="scale-btn">LOG</button>
                </div>
            </div>
            <div class="flex-1 relative bg-[#09090b]">
                <canvas id="chart-1"></canvas>
                <div class="absolute bottom-2 left-2 text-[9px] text-gray-700 mono pointer-events-none">ZOOM: SCROLL | PAN: DRAG</div>
            </div>
        </div>

        <div class="chart-container rounded-lg p-1 flex flex-col" id="container-2">
            <div class="flex justify-between items-center px-3 py-2 bg-[#101012] border-b border-white/5">
                <div class="text-[10px] font-bold text-gray-400 uppercase tracking-widest flex items-center gap-2">
                    <span class="w-1.5 h-1.5 rounded-full bg-orange-500"></span>
                    <span id="title-2">Window 3</span>
                </div>
                <div class="flex gap-1">
                    <button onclick="setScale(2, false)" id="scale-lin-2" class="scale-btn active">LIN</button>
                    <button onclick="setScale(2, true)" id="scale-log-2" class="scale-btn">LOG</button>
                </div>
            </div>
            <div class="flex-1 relative bg-[#09090b]">
                <canvas id="chart-2"></canvas>
                <div class="absolute bottom-2 left-2 text-[9px] text-gray-700 mono pointer-events-none">ZOOM: SCROLL | PAN: DRAG</div>
            </div>
        </div>

        <div class="chart-container rounded-lg p-1 flex flex-col" id="container-3">
            <div class="flex justify-between items-center px-3 py-2 bg-[#101012] border-b border-white/5">
                <div class="text-[10px] font-bold text-gray-400 uppercase tracking-widest flex items-center gap-2">
                    <span class="w-1.5 h-1.5 rounded-full bg-red-500"></span>
                    <span id="title-3">Window 4</span>
                </div>
                <div class="flex gap-1">
                    <button onclick="setScale(3, false)" id="scale-lin-3" class="scale-btn active">LIN</button>
                    <button onclick="setScale(3, true)" id="scale-log-3" class="scale-btn">LOG</button>
                </div>
            </div>
            <div class="flex-1 relative bg-[#09090b]">
                <canvas id="chart-3"></canvas>
                <div class="absolute bottom-2 left-2 text-[9px] text-gray-700 mono pointer-events-none">ZOOM: SCROLL | PAN: DRAG</div>
            </div>
        </div>
    </div>

    <footer class="mt-auto border-t border-white/10 bg-[#0c0c0e] py-3 px-6 rounded-t-lg">
        <div class="flex flex-col md:flex-row justify-between items-center gap-4 text-[10px] mono text-gray-500">
            
            <div class="flex items-center gap-4">
                <span class="text-gray-400 font-bold tracking-widest">RSA ENGINE</span>
                <span>¬© 2026 Adiyat Coto. All rights reserved.</span>
            </div>
    
            <div id="statusContainer" class="flex items-center gap-2 bg-black/30 px-3 py-1 rounded-full border border-white/5 transition-colors duration-300">
                <span class="relative flex h-2 w-2">
                  <span id="statusPing" class="animate-ping absolute inline-flex h-full w-full rounded-full bg-emerald-400 opacity-75"></span>
                  <span id="statusDot" class="relative inline-flex rounded-full h-2 w-2 bg-emerald-500 transition-colors duration-300"></span>
                </span>
                <span id="statusText" class="text-emerald-500 font-bold tracking-wide transition-colors duration-300">SYSTEM OPERATIONAL</span>
            </div>
    
            <div class="flex items-center gap-4">
                <div class="flex items-center gap-1">
                    <span>LATENCY:</span>
                    <span id="latencyValue" class="text-blue-400">CALCULATING...</span>
                </div>
                <div class="w-px h-3 bg-gray-700"></div>
                <span class="opacity-50">v2.9.24-stable</span>
            </div>
        </div>
    </footer>

    <script>
        // --- GLOBAL CONFIGURATION ---
        let currentSymbol = "BTCUSDT";
        let livePrice = 0;
        let historicalData = [];
        let avgCaps = {};
        let activeStats = {};
        let histories = [[], [], [], []];
        let isCalendarMode = false;
        
        let fixedCycleAnchorPrice = null;
        let wasOffline = false; // Tracks if we were previously offline

        let chartStates = [
            { viewLimit: 100, offset: 0, isDragging: false, lastX: 0, isLog: false },
            { viewLimit: 200, offset: 0, isDragging: false, lastX: 0, isLog: false },
            { viewLimit: 104, offset: 0, isDragging: false, lastX: 0, isLog: false },
            { viewLimit: 48,  offset: 0, isDragging: false, lastX: 0, isLog: false }
        ];
        
        const TIMEFRAME_MAP = {
            0: "4-YEARS",
            1: "2-YEARS", 2: "YEARLY", 3: "6-MONTHS", 4: "3-MONTHS", 
            5: "1.5-MO", 6: "3-WEEKS", 7: "11-DAYS", 8: "5-DAYS", 
            9: "2-DAYS", 10: "DAILY", 11: "INTRADAY"
        };

        const CALENDAR_LABELS = {
            0: "4-YEARLY",
            1: "2-YEARLY", 2: "YEARLY", 3: "SEMESTER", 4: "QUARTER", 
            5: "1.5-MO", 6: "3-WEEKS", 7: "11-DAYS", 8: "5-DAYS", 
            9: "2-DAYS", 10: "DAILY", 11: "INTRADAY"
        };

        const WINDOW_CONFIGS = [
            { id: 0, interval: "1h", limit: 504, levels: [8, 9, 10, 11], title: "MICRO STRUCTURE (L8-L11)" },
            { id: 1, interval: "4h", limit: 720, levels: [5, 6, 7],      title: "INTERMEDIATE (L5-L7)" },
            { id: 2, interval: "1w", limit: 104, levels: [2, 3, 4],      title: "MACRO TREND (L2-L4)" },
            { id: 3, interval: "1M", limit: 96,  levels: [0, 1],         title: "GLOBAL CYCLE (L0-L1)" } 
        ];

        // --- LOADING UX ---
        const loadingMessages = [
            { t: "HANDSHAKE", s: "Establishing secure connection..." },
            { t: "DEEP QUERY", s: "Retrieving 2018-2026 dataset..." },
            { t: "CALIBRATION", s: "Aligning volatility structures..." },
            { t: "RENDERING", s: "Generating visualization layers..." }
        ];

        let loadingStep = 0;
        let loadingInterval;

        function startLoadingSequence() {
            const titleEl = document.getElementById('loadingTitle');
            const subEl = document.getElementById('loadingSubtitle');
            const overlay = document.getElementById('loadingOverlay');
            
            overlay.classList.remove('hidden');
            loadingStep = 0;
            titleEl.innerText = loadingMessages[0].t;
            subEl.innerText = loadingMessages[0].s;

            loadingInterval = setInterval(() => {
                loadingStep = (loadingStep + 1) % loadingMessages.length;
                titleEl.innerText = loadingMessages[loadingStep].t;
                subEl.innerText = loadingMessages[loadingStep].s;
            }, 1200);
        }

        function stopLoadingSequence() {
            clearInterval(loadingInterval);
            document.getElementById('loadingOverlay').classList.add('hidden');
        }

        // --- HELPER FUNCTIONS ---
        function formatPrice(price, isDelta = false) {
            if (price === undefined || price === null) return "--";
            const absP = Math.abs(price);
            const sign = isDelta && price > 0 ? "+" : "";
            let decimals = 2;
            if (absP === 0) decimals = 2;
            else if (absP < 0.0001) decimals = 8;
            else if (absP < 0.01) decimals = 6;
            else if (absP < 1) decimals = 4;
            else if (absP < 100) decimals = 3;

            return sign + price.toLocaleString('en-US', { minimumFractionDigits: decimals, maximumFractionDigits: decimals });
        }

        // --- REAL-TIME CONNECTION MONITOR (HEADER & FOOTER) ---
        function updateConnectionUI(isConnected, latency) {
            const container = document.getElementById('statusContainer');
            const ping = document.getElementById('statusPing');
            const dot = document.getElementById('statusDot');
            const text = document.getElementById('statusText');
            const latText = document.getElementById('latencyValue');
            const headerWarn = document.getElementById('headerWarning');

            if (isConnected) {
                // Success State
                headerWarn.classList.add('hidden'); 

                container.classList.remove('border-red-500/30', 'bg-red-900/10');
                container.classList.add('border-white/5', 'bg-black/30');
                
                ping.classList.remove('hidden');
                dot.classList.remove('bg-red-500');
                dot.classList.add('bg-emerald-500');
                
                text.classList.remove('text-red-500');
                text.classList.add('text-emerald-500');
                text.innerText = "SYSTEM OPERATIONAL";

                let latColor = 'text-emerald-400';
                if(latency > 300) latColor = 'text-yellow-400';
                if(latency > 800) latColor = 'text-red-400';
                
                latText.className = latColor;
                latText.innerText = latency + "ms";
            } else {
                // Failure State
                headerWarn.classList.remove('hidden'); 

                container.classList.remove('border-red-500/30', 'bg-red-900/10');
                container.classList.add('border-red-500/30', 'bg-red-900/10');
                
                ping.classList.add('hidden');
                dot.classList.remove('bg-emerald-500');
                dot.classList.add('bg-red-500');
                
                text.classList.remove('text-emerald-500');
                text.classList.add('text-red-500');
                
                text.innerText = "API UNREACHABLE ‚Ä¢ CHECK NETWORK / VPN";

                latText.className = "text-red-500 font-bold";
                latText.innerText = "OFFLINE";
            }
        }

        async function fetchBinance(endpoint, params) {
            const url = new URL(`https://api.binance.com/api/v3/${endpoint}`);
            Object.keys(params).forEach(key => url.searchParams.append(key, params[key]));
            try {
                const res = await fetch(url);
                if (!res.ok) throw new Error("Access Failed");
                return await res.json();
            } catch (e) { 
                console.error("API Error:", e);
                return null; 
            }
        }

        async function loadSymbolSuggestions() {
            const data = await fetchBinance('exchangeInfo', {});
            if (data && data.symbols) {
                const datalist = document.getElementById('tickerList');
                datalist.innerHTML = "";
                const symbols = data.symbols
                    .filter(s => s.quoteAsset === 'USDT' && s.status === 'TRADING')
                    .map(s => s.symbol)
                    .sort();
                symbols.forEach(s => {
                    const option = document.createElement('option');
                    option.value = s;
                    datalist.appendChild(option);
                });
            }
        }

        async function fetchFullHistory(symbol) {
            let all = [];
            let currentStart = Date.UTC(2018, 0, 1); 
            const now = Date.now();
            
            while (currentStart < now) {
                const data = await fetchBinance('klines', { symbol, interval: '1d', startTime: currentStart, limit: 1000 });
                if (!data || !Array.isArray(data)) break;
                if (data.length === 0) break;
                all = all.concat(data);
                currentStart = data[data.length - 1][0] + 1;
                if (data.length < 1000) break;
            }
            return all.map(d => ({
                ot: new Date(d[0]),
                o: parseFloat(d[1]), h: parseFloat(d[2]), l: parseFloat(d[3]), c: parseFloat(d[4])
            }));
        }

        function getAtomicIntervals(start, end, maxLevel) {
            let intervals = {};
            for(let i=0; i<=maxLevel; i++) intervals[i] = [];
            intervals[0].push([start, end]);

            function divide(s, e, lvl) {
                if (lvl > maxLevel) return;
                let diff = e.getTime() - s.getTime();
                if (diff < 60000) { intervals[lvl].push([s, e]); return; }
                let mid = new Date(s.getTime() + Math.floor(diff / 2));
                intervals[lvl].push([s, mid], [mid, e]);
                divide(s, mid, lvl + 1); divide(mid, e, lvl + 1);
            }
            divide(start, end, 1);
            return intervals;
        }

        function getCalendarIntervals(start, end, maxLevel) {
            let intervals = {};
            for(let i=0; i<=maxLevel; i++) intervals[i] = [];
            intervals[0].push([start, end]);

            let midPoint = new Date(start.getTime() + (end.getTime() - start.getTime()) / 2);
            if (midPoint.getUTCMonth() !== 0 || midPoint.getUTCDate() !== 1) {
                midPoint = new Date(Date.UTC(start.getUTCFullYear() + 2, 0, 1));
            }
            intervals[1].push([start, midPoint]);
            intervals[1].push([midPoint, end]);

            intervals[1].forEach(([s, e]) => {
                let mid = new Date(Date.UTC(s.getUTCFullYear() + 1, 0, 1));
                intervals[2].push([s, mid], [mid, e]);
            });
            intervals[2].forEach(([s, e]) => {
                let mid = new Date(Date.UTC(s.getUTCFullYear(), 6, 1));
                intervals[3].push([s, mid], [mid, e]);
            });
            intervals[3].forEach(([s, e]) => {
                let mid = new Date(s.getTime() + (e.getTime() - s.getTime()) / 2);
                mid.setUTCHours(0,0,0,0);
                intervals[4].push([s, mid], [mid, e]);
            });

            function fillRecursive(lvl) {
                if (lvl > maxLevel) return;
                intervals[lvl-1].forEach(([s, e]) => {
                    let diff = e.getTime() - s.getTime();
                    let mid;
                    if (diff > 86400000) {
                        mid = new Date(s.getTime() + Math.floor(diff / (2 * 86400000)) * 86400000);
                    } else {
                        mid = new Date(s.getTime() + Math.floor(diff / 2));
                    }
                    if (mid.getTime() === s.getTime() && diff > 1000) {
                        mid = new Date(s.getTime() + Math.floor(diff/2));
                    }
                    intervals[lvl].push([s, mid], [mid, e]);
                });
                fillRecursive(lvl + 1);
            }
            fillRecursive(5);
            return intervals;
        }

        function extractStats(intervals, historicalData) {
            let ups = [];
            let downs = [];
            let count = 0;

            intervals.forEach(([s, e]) => {
                const mask = historicalData.filter(d => d.ot >= s && d.ot < e);
                if (mask.length > 0) {
                    const open = mask[0].o;
                    const hh = Math.max(...mask.map(m => m.h));
                    const ll = Math.min(...mask.map(m => m.l));
                    ups.push(((hh - open) / open) * 100);
                    downs.push(((open - ll) / open) * 100);
                    count++;
                }
            });
            return { ups, downs, count };
        }

        async function initData() {
            startLoadingSequence();
            
            historicalData = await fetchFullHistory(currentSymbol);
            if (historicalData.length === 0) {
                 stopLoadingSequence();
                 return;
            }

            const now = new Date();
            const cycleIdx = Math.floor((now.getUTCFullYear() - 2022) / 4);
            const cycleStartYear = 2022 + (cycleIdx * 4); 
            
            document.getElementById('cycle-info').innerText = `${cycleStartYear}-${cycleStartYear + 4}`;
            
            const startActive = new Date(Date.UTC(cycleStartYear, 0, 1));
            const endActive = new Date(Date.UTC(cycleStartYear + 4, 0, 1));

            try {
                const anchorKlines = await fetchBinance('klines', { 
                    symbol: currentSymbol, 
                    interval: '1d', 
                    startTime: startActive.getTime(), 
                    limit: 1 
                });

                if (anchorKlines && anchorKlines.length > 0) {
                    const candleTime = anchorKlines[0][0];
                    if (Math.abs(candleTime - startActive.getTime()) < 86400000) {
                        fixedCycleAnchorPrice = parseFloat(anchorKlines[0][1]); 
                    }
                }
            } catch (e) { console.error("Anchor fetch error", e); }
            
            const startPrev = new Date(Date.UTC(cycleStartYear - 4, 0, 1));
            const endPrev = new Date(Date.UTC(cycleStartYear, 0, 1));

            let intervalsPrev, intervalsCurr;
            if (isCalendarMode) {
                intervalsPrev = getCalendarIntervals(startPrev, endPrev, 11);
                intervalsCurr = getCalendarIntervals(startActive, endActive, 11);
            } else {
                intervalsPrev = getAtomicIntervals(startPrev, endPrev, 11);
                intervalsCurr = getAtomicIntervals(startActive, endActive, 11);
            }

            for (let lvl = 0; lvl <= 11; lvl++) {
                const statsPrev = extractStats(intervalsPrev[lvl], historicalData);
                const statsCurr = extractStats(intervalsCurr[lvl], historicalData);

                let finalUps = [...statsPrev.ups];
                let finalDowns = [...statsPrev.downs];

                if (statsCurr.count > 0) {
                    finalUps = finalUps.concat(statsCurr.ups);
                    finalDowns = finalDowns.concat(statsCurr.downs);
                }

                if (finalUps.length === 0) {
                    avgCaps[lvl] = { u: 0, d: 0 }; 
                } else {
                    avgCaps[lvl] = { 
                        u: finalUps.reduce((a,b)=>a+b)/finalUps.length, 
                        d: finalDowns.reduce((a,b)=>a+b)/finalDowns.length 
                    };
                }
            }

            activeStats = {};
            for (let lvl = 0; lvl <= 11; lvl++) {
                const mergedIntervals = intervalsPrev[lvl].concat(intervalsCurr[lvl]);
                activeStats[lvl] = mergedIntervals.map(([s, e]) => {
                    const mask = historicalData.filter(d => d.ot >= s && d.ot < e);
                    let openPrice = mask.length ? mask[0].o : null;
                    if (s.getTime() === startActive.getTime() && fixedCycleAnchorPrice !== null) {
                        openPrice = fixedCycleAnchorPrice;
                    }
                    if (openPrice === null && s <= now && e > now) {
                        openPrice = livePrice;
                    }
                    return { start: s, end: e, open: openPrice };
                });
            }

            for (let cfg of WINDOW_CONFIGS) {
                const res = await fetchBinance('klines', { symbol: currentSymbol, interval: cfg.interval, limit: cfg.limit });
                if(res) {
                    histories[cfg.id] = res.map(d => [new Date(d[0]), parseFloat(d[1]), parseFloat(d[2]), parseFloat(d[3]), parseFloat(d[4])]);
                    document.getElementById(`title-${cfg.id}`).innerText = cfg.title;
                    chartStates[cfg.id].viewLimit = Math.min(histories[cfg.id].length, 100);
                    chartStates[cfg.id].offset = 0;
                }
            }
            
            stopLoadingSequence();
            renderCharts();
            updateStatsTable();
        }

        function setScale(idx, isLog) {
            chartStates[idx].isLog = isLog;
            document.getElementById(`scale-lin-${idx}`).classList.toggle('active', !isLog);
            document.getElementById(`scale-log-${idx}`).classList.toggle('active', isLog);
            renderCharts();
        }

        function initInteractions() {
            WINDOW_CONFIGS.forEach(cfg => {
                const canvas = document.getElementById(`chart-${cfg.id}`);
                canvas.addEventListener('wheel', (e) => {
                    e.preventDefault();
                    const state = chartStates[cfg.id];
                    const delta = e.deltaY > 0 ? 1.1 : 0.9;
                    state.viewLimit = Math.max(10, Math.min(histories[cfg.id].length, Math.round(state.viewLimit * delta)));
                    renderCharts();
                }, { passive: false });
                canvas.addEventListener('mousedown', (e) => {
                    chartStates[cfg.id].isDragging = true;
                    chartStates[cfg.id].lastX = e.clientX;
                });
                window.addEventListener('mousemove', (e) => {
                    const state = chartStates[cfg.id];
                    if (!state.isDragging) return;
                    const dx = e.clientX - state.lastX;
                    if (Math.abs(dx) > 2) {
                        const ohlc = histories[cfg.id];
                        const candleWidthPixels = canvas.clientWidth / state.viewLimit;
                        const shift = Math.round(dx / candleWidthPixels);
                        if (shift !== 0) {
                            state.offset = Math.max(0, Math.min(ohlc.length - state.viewLimit, state.offset + shift));
                            state.lastX = e.clientX;
                            renderCharts();
                        }
                    }
                });
                window.addEventListener('mouseup', () => { chartStates[cfg.id].isDragging = false; });
            });
        }

        function renderCharts() {
            const now = new Date();
            WINDOW_CONFIGS.forEach(cfg => {
                const cv = document.getElementById(`chart-${cfg.id}`);
                // FIX 1: Safety Check for uninitialized canvas
                if (!cv || !cv.parentElement || cv.parentElement.clientWidth === 0) return;

                const ctx = cv.getContext('2d', { alpha: false });
                const full = histories[cfg.id];
                if (!full || !full.length) return;

                const st = chartStates[cfg.id];
                const end = full.length - st.offset;
                const start = Math.max(0, end - st.viewLimit);
                const data = full.slice(start, end);

                cv.width = cv.parentElement.clientWidth;
                cv.height = cv.parentElement.clientHeight;
                
                const chartW = cv.width - 200; 
                const chartH = cv.height - 30;

                let prices = data.flatMap(d => [d[2], d[3]]);
                
                cfg.levels.forEach(l => {
                    activeStats[l]?.forEach(p => {
                        if(p.end >= data[0][0] && p.start <= data[data.length-1][0]) {
                            
                            let effectiveOpen = p.open;
                            if (effectiveOpen === null) {
                                const match = full.find(c => c[0].getTime() === p.start.getTime());
                                if (match) effectiveOpen = match[1];
                            }

                            if(effectiveOpen !== null && effectiveOpen > 0) {
                                const caps = avgCaps[l];
                                prices.push(effectiveOpen * (1 + (caps.u || 0)/100));
                                prices.push(effectiveOpen * (1 - (caps.d || 0)/100));
                            }
                        }
                    });
                });
                
                // FIX 2: Only push livePrice if it is valid (non-zero)
                if (livePrice > 0) {
                    prices.push(livePrice);
                }
                
                // FIX 3: Filter out any 0s or NaNs that might crush the scale
                prices = prices.filter(p => p > 0);

                if (prices.length === 0) return; // Abort drawing if no valid price data

                const minP = Math.min(...prices), maxP = Math.max(...prices);
                
                let getY;
                if (st.isLog) {
                    const lMin = Math.log(minP), lMax = Math.log(maxP), lR = lMax - lMin;
                    getY = p => chartH - (Math.log(Math.max(1e-9, p)) - lMin) / lR * chartH + 15;
                } else {
                    const R = maxP - minP;
                    getY = p => chartH - (p - minP) / R * chartH + 15;
                }

                const viewStartTime = data[0][0].getTime();
                const viewEndTime = data[data.length - 1][0].getTime();
                const getX_Time = (t) => {
                    const diffTime = t.getTime() - viewStartTime;
                    const ratio = diffTime / (viewEndTime - viewStartTime);
                    return (ratio * chartW); 
                };
                const getX_Index = i => (i / data.length) * chartW;

                ctx.fillStyle = '#09090b'; 
                ctx.fillRect(0, 0, cv.width, cv.height);
                
                ctx.strokeStyle = '#27272a'; 
                ctx.lineWidth = 1;
                for(let i=0; i<=5; i++) { 
                    let y = 15 + (i/5) * chartH; 
                    ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(chartW, y); ctx.stroke(); 
                }

                let labels = [];

                cfg.levels.forEach(lvl => {
                    const caps = avgCaps[lvl];
                    activeStats[lvl]?.forEach(ph => {
                        
                        const isActive = (now.getTime() >= ph.start.getTime() && now.getTime() < ph.end.getTime());
                        const startVisible = ph.start.getTime() <= viewEndTime;
                        const endVisible = ph.end.getTime() >= viewStartTime;
                        if (!isActive && (!startVisible || !endVisible)) return;

                        let effectiveOpen = ph.open;
                        if (effectiveOpen === null) {
                            const match = full.find(c => c[0].getTime() === ph.start.getTime());
                            if (match) effectiveOpen = match[1];
                        }
                        if (effectiveOpen === null || effectiveOpen === 0) return;

                        const c = effectiveOpen * (1 + (caps.u||0)/100);
                        const f = effectiveOpen * (1 - (caps.d||0)/100);
                        const m = (c + f) / 2;

                        let x1, x2;
                        if (ph.start.getTime() < viewStartTime) { x1 = 0; } else { x1 = getX_Time(ph.start); }
                        if (ph.end.getTime() > viewEndTime) { x2 = chartW; } else { x2 = getX_Time(ph.end); }

                        ctx.fillStyle = 'rgba(59, 130, 246, 0.03)';
                        ctx.fillRect(x1, getY(c), Math.max(1, x2 - x1), Math.max(1, getY(f) - getY(c)));

                        if (isActive) {
                            const phData = full.filter(d => d[0] >= ph.start && d[0] < ph.end);
                            const highestHigh = phData.length > 0 ? Math.max(...phData.map(d => d[2]), livePrice) : livePrice;
                            const lowestLow = phData.length > 0 ? Math.min(...phData.map(d => d[3]), livePrice) : livePrice;
                            
                            const isCT = highestHigh >= c; 
                            const isFT = lowestLow <= f;
                            const isEQT = (highestHigh >= m && lowestLow <= m);    

                            const desc = isCalendarMode ? CALENDAR_LABELS[lvl] : TIMEFRAME_MAP[lvl];

                            ctx.setLineDash([4, 4]); ctx.lineWidth = 1;
                            ctx.strokeStyle = isCT ? '#ffffff' : '#ef4444'; 
                            ctx.beginPath(); ctx.moveTo(x1, getY(c)); ctx.lineTo(chartW, getY(c)); ctx.stroke(); 
                            
                            ctx.strokeStyle = isFT ? '#ffffff' : '#10b981'; 
                            ctx.beginPath(); ctx.moveTo(x1, getY(f)); ctx.lineTo(chartW, getY(f)); ctx.stroke();

                            ctx.setLineDash([2, 2]); 
                            ctx.strokeStyle = '#facc15'; 
                            ctx.beginPath(); ctx.moveTo(x1, getY(m)); ctx.lineTo(chartW, getY(m)); ctx.stroke();
                            ctx.setLineDash([]);

                            labels.push({ y: getY(c), t: `L${lvl} ${desc} TOP: $${formatPrice(c)} ${isCT ? '[‚ö°]' : ''}`, c: isCT ? '#ffffff' : '#ef4444' });
                            labels.push({ y: getY(f), t: `L${lvl} ${desc} BOT: $${formatPrice(f)} ${isFT ? '[‚ö°]' : ''}`, c: isFT ? '#ffffff' : '#10b981' });
                            labels.push({ y: getY(m), t: `L${lvl} ${desc} EQ : $${formatPrice(m)} ${isEQT ? '[‚ö°]' : ''}`, c: '#facc15' });
                        }
                    });
                });

                const cw = Math.max(1, (chartW / data.length) * 0.7);
                data.forEach((d, i) => {
                    const color = d[4] >= d[1] ? '#10b981' : '#ef4444';
                    ctx.fillStyle = color; ctx.strokeStyle = color;
                    const x = getX_Index(i);
                    ctx.beginPath(); ctx.moveTo(x, getY(d[2])); ctx.lineTo(x, getY(d[3])); ctx.stroke();
                    ctx.fillRect(x - cw / 2, getY(Math.max(d[1], d[4])), cw, Math.abs(getY(d[1]) - getY(d[4])) || 1);
                });

                if (livePrice > 0) {
                    ctx.strokeStyle = 'rgba(255,255,255,0.3)'; ctx.setLineDash([2, 2]);
                    ctx.beginPath(); ctx.moveTo(0, getY(livePrice)); ctx.lineTo(cv.width, getY(livePrice)); ctx.stroke();
                    ctx.setLineDash([]);
                    
                    ctx.fillStyle = '#3b82f6'; ctx.fillRect(cv.width - 60, getY(livePrice) - 9, 60, 18);
                    ctx.fillStyle = '#fff'; ctx.font = 'bold 10px JetBrains Mono'; ctx.textAlign = "right";
                    ctx.fillText(formatPrice(livePrice), cv.width - 5, getY(livePrice) + 4);
                    ctx.textAlign = "left"; 
                }

                labels.sort((a, b) => a.y - b.y);
                const minGap = 12; 
                for (let i = 1; i < labels.length; i++) {
                    if (labels[i].y - labels[i - 1].y < minGap) {
                        labels[i].y = labels[i - 1].y + minGap;
                    }
                }

                ctx.font = '500 9px JetBrains Mono';
                labels.forEach(l => {
                    ctx.fillStyle = l.c;
                    ctx.fillText(l.t, chartW + 8, l.y + 3);
                });
            });
        }

        function updateStatsTable() {
            const now = new Date(); const tb = document.getElementById('statsTableBody'); let h = "";
            for(let l=0; l<=11; l++) {
                const ph = activeStats[l]?.find(p => now.getTime() >= p.start.getTime() && now.getTime() < p.end.getTime());
                if(!ph || ph.open===null) continue;
                const cp = avgCaps[l], c = ph.open*(1+cp.u/100), f = ph.open*(1-cp.d/100), m = (c+f)/2;
                const isMain = l<=1 ? "bg-white/5" : "";
                const desc = isCalendarMode ? CALENDAR_LABELS[l] : TIMEFRAME_MAP[l];
                
                const phaseData = historicalData.filter(d => d.ot >= ph.start && d.ot < ph.end);
                const phHigh = phaseData.length > 0 ? Math.max(...phaseData.map(d => d.h), livePrice) : livePrice;
                const phLow = phaseData.length > 0 ? Math.min(...phaseData.map(d => d.l), livePrice) : livePrice;
                const isEQT = (phHigh >= m && phLow <= m); 

                const total = ph.end - ph.start;
                const elap = now - ph.start;
                const prog = Math.min(100, Math.max(0, (elap/total)*100)).toFixed(1);

                const expiryStr = ph.end.toLocaleString('en-GB', { 
                    weekday:'short', year:'numeric', month:'short', day:'2-digit', 
                    hour:'2-digit', minute:'2-digit', second:'2-digit', timeZone:'UTC' 
                }) + " UTC";

                const upPct = parseFloat(((c - livePrice) / livePrice * 100).toFixed(2));
                const downPct = parseFloat(((livePrice - f) / livePrice * 100).toFixed(2));
                const isBullish = upPct < downPct; 
                const winnerBadge = isBullish 
                    ? `<span class="bg-emerald-500/10 text-emerald-400 text-[9px] px-2 py-0.5 rounded-sm ml-2 font-bold tracking-wider border border-emerald-500/20">BULLS</span>`
                    : `<span class="bg-red-500/10 text-red-400 text-[9px] px-2 py-0.5 rounded-sm ml-2 font-bold tracking-wider border border-red-500/20">BEARS</span>`;

                h += `<tr class="data-row ${isMain}">
                    <td class="p-4 ${l<=1?'text-white font-bold':'text-blue-400'}">L${l}</td>
                    <td class="p-4 font-medium text-white">${desc}</td>
                    <td class="p-4">
                        <div class="flex items-center gap-2">
                            <div class="w-16 h-1.5 bg-gray-700 rounded-full overflow-hidden">
                                <div class="bg-blue-500 h-full" style="width:${prog}%"></div>
                            </div>
                            <span class="text-[10px] text-gray-400">${prog}%</span>
                        </div>
                    </td>
                    <td class="p-4 text-gray-400 text-[10px] mono">${expiryStr}</td>
                    <td class="p-4 text-right text-yellow-500 font-mono">${formatPrice(m)} ${isEQT?'‚ö°':''}</td>
                    <td class="p-4 text-right ${livePrice>=m?'text-emerald-400':'text-red-400'} font-mono">${formatPrice(livePrice-m,true)}</td>
                    <td class="p-4 text-right font-mono text-gray-500 text-[10px]">
                        <span class="text-red-400">‚Üë${upPct}%</span> / <span class="text-emerald-400">‚Üì${downPct}%</span>
                        ${winnerBadge}
                    </td>
                </tr>`;
            }
            tb.innerHTML = h;
        }

        function toggleFullscreen() {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen().catch(err => { console.log(`Error attempting to enable fullscreen: ${err.message}`); });
            } else {
                if (document.exitFullscreen) { document.exitFullscreen(); }
            }
        }

        async function loop() {
            const start = performance.now();
            const t = await fetchBinance('ticker/price', { symbol: currentSymbol });
            const end = performance.now();
            const latency = Math.round(end - start);

            if (t) {
                // If we were offline, this is the first successful reconnection.
                if (wasOffline) {
                    wasOffline = false; // Reset flag
                    // Trigger full refresh to backfill missing data
                    await initData(); 
                    return; // Exit this loop cycle to prevent double-update
                }

                livePrice = parseFloat(t.price); 
                document.getElementById('livePrice').innerText = formatPrice(livePrice); 
                updateConnectionUI(true, latency);
            } else {
                wasOffline = true; // Mark system as offline
                updateConnectionUI(false, 0);
            }

            const now = new Date(); 
            const dateStr = now.toLocaleDateString('en-GB', { day: '2-digit', month: 'short', year: 'numeric', timeZone: 'UTC' });
            document.getElementById('currentDate').innerText = dateStr;
            document.getElementById('currentTime').innerText = now.toUTCString().split(' ')[4] + " UTC";
            
            if (t) {
                histories.forEach(h => { 
                    if (h.length) { 
                        const l = h[h.length - 1]; 
                        l[2] = Math.max(l[2], livePrice); 
                        l[3] = Math.min(l[3], livePrice); 
                        l[4] = livePrice; 
                    } 
                });
                renderCharts(); 
                updateStatsTable();
            }
        }

        async function toggleMode() {
            isCalendarMode = document.getElementById('modeToggle').checked;
            document.getElementById('modeLabel').innerText = isCalendarMode ? "CALENDAR" : "ATOMIC";
            await initData();
        }

        async function changeTicker() {
            const v = document.getElementById('tickerInput').value.trim().toUpperCase();
            if (v) { currentSymbol = v; await initData(); }
        }

        window.onload = async () => {
            await loadSymbolSuggestions();
            await initData();
            initInteractions();
            setInterval(loop, 1000);
            window.addEventListener('resize', renderCharts);
        };
    </script>
</body>
</html>