<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Geometric Time Visualization</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            color: #ffffff;
            background: linear-gradient(-45deg, #111827, #1f2937, #374151, #111827);
            background-size: 400% 400%;
            animation: gradientAnimation 30s ease infinite;
            overflow: hidden; /* Prevent scrollbars from animation */
        }

        @keyframes gradientAnimation {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        svg {
            width: 100%;
            height: 100%;
            cursor: crosshair;
            overflow: visible; /* Allow labels outside the viewBox to be seen */
        }
        #tooltip {
            position: fixed;
            opacity: 0;
            transition: opacity 0.2s ease-in-out;
            pointer-events: none;
            z-index: 10;
        }
        #tooltip.visible {
            opacity: 1;
        }
        .ring-label {
            font-size: 1.7px; /* Reduced slightly to create padding from ring borders */
            font-weight: 500;
            pointer-events: none;
        }
    </style>
</head>
<body class="flex flex-col items-center justify-center min-h-screen p-4 sm:p-6">

    <div class="w-full max-w-5xl text-center mb-6">
        <h1 class="text-3xl sm:text-4xl font-bold tracking-tight">Nested Time Visualization</h1>
        <p id="time-display" class="text-gray-400 mt-2">Loading current time...</p>
    </div>

    <div id="visualization" class="w-full max-w-5xl mx-auto">
         <svg viewBox="-5 -5 110 110" id="geometric-svg">
            <!-- Geometric shapes will be generated by JS -->
         </svg>
    </div>

    <div id="tooltip" class="rounded-md bg-gray-900 bg-opacity-80 px-3 py-2 text-sm text-white shadow-lg backdrop-blur-sm"></div>

    <script>
        const svgContainer = document.getElementById('geometric-svg');
        const timeDisplay = document.getElementById('time-display');
        const tooltip = document.getElementById('tooltip');

        // --- Time Configuration ---
        // The time will now auto-adjust to the visitor's local timezone.
        const visitorTimezone = Intl.DateTimeFormat().resolvedOptions().timeZone;
        const locationName = visitorTimezone.split('/').pop().replace(/_/g, ' ');

        const timeUnits = [
            { name: 'Millennium' }, { name: 'Century' }, { name: 'Decade' },
            { name: 'Year' }, { name: 'Semester' }, { name: 'Quarter' },
            { name: 'Month' }, { name: 'Week' }, { name: 'Day' },
            { name: '4-Hour' }, { name: 'Hour' }, { name: '30 Mins' },
            { name: '15 Mins' }, { name: '5 Mins' }, { name: 'Mins' },
            { name: 'Second' },
        ];

        function calculateProgress(unit, now) {
            const fullYear = now.getFullYear();
            const month = now.getMonth();
            const dayOfMonth = now.getDate();
            const dayOfWeek = now.getDay();
            const hours = now.getHours();
            const minutes = now.getMinutes();
            const seconds = now.getSeconds();
            const milliseconds = now.getMilliseconds();
            const daysInMonth = new Date(fullYear, month + 1, 0).getDate();
            
            let progress = 0;
            let valueLabel = '';
            let midpointLabel = '';

            const dateOptions = { month: 'short', day: 'numeric', year: 'numeric' };
            
            const formatMsToMinSec = (ms) => {
                const totalSeconds = Math.floor(ms / 1000);
                const mins = Math.floor(totalSeconds / 60);
                const secs = totalSeconds % 60;
                return `${mins}m ${secs}s`;
            };
            
            const startOfDay = new Date(now.getFullYear(), now.getMonth(), now.getDate());
            const timeElapsedTodayMs = now.getTime() - startOfDay.getTime();
            const progressOfDay = timeElapsedTodayMs / 86400000;

            const startOfYear = new Date(now.getFullYear(), 0, 1);
            const timeElapsedInYearMs = now.getTime() - startOfYear.getTime();
            const totalMsInYear = new Date(now.getFullYear() + 1, 0, 1).getTime() - startOfYear.getTime();
            const progressOfYear = timeElapsedInYearMs / totalMsInYear;

            switch (unit) {
                case 'Second':
                    progress = milliseconds / 1000;
                    valueLabel = `${milliseconds}ms`;
                    midpointLabel = '500 mil-secs';
                    break;
                case 'Mins':
                    progress = (seconds * 1000 + milliseconds) / 60000;
                    valueLabel = `Sec ${seconds + 1}/60`;
                    midpointLabel = '30 secs';
                    break;
                case '5 Mins': {
                    const blockDuration = 300000;
                    progress = (timeElapsedTodayMs % blockDuration) / blockDuration;
                    valueLabel = `${formatMsToMinSec(timeElapsedTodayMs % blockDuration)} / 5m`;
                    midpointLabel = '2m 30s';
                    break;
                }
                case '15 Mins': {
                    const blockDuration = 900000;
                    progress = (timeElapsedTodayMs % blockDuration) / blockDuration;
                    valueLabel = `${formatMsToMinSec(timeElapsedTodayMs % blockDuration)} / 15m`;
                    midpointLabel = '7m 30s';
                    break;
                }
                case '30 Mins': {
                    const blockDuration = 1800000;
                    progress = (timeElapsedTodayMs % blockDuration) / blockDuration;
                    valueLabel = `${formatMsToMinSec(timeElapsedTodayMs % blockDuration)} / 30m`;
                    midpointLabel = '15m 0s';
                    break;
                }
                case 'Hour':
                    progress = ((minutes * 60000) + (seconds * 1000) + milliseconds) / 3600000;
                    valueLabel = `Min ${minutes + 1}/60`;
                    midpointLabel = '30m 0s';
                    break;
                case '4-Hour': {
                    const blockDuration = 14400000;
                    progress = (timeElapsedTodayMs % blockDuration) / blockDuration;
                    const hourIntoSegment = hours % 4;
                    valueLabel = `Hour ${hourIntoSegment + 1}/4`;
                    midpointLabel = `End of hour ${Math.floor(hours/4)*4 + 2}`;
                    break;
                }
                case 'Day':
                    progress = progressOfDay;
                    valueLabel = `${hours}:${String(minutes).padStart(2,'0')}`;
                    midpointLabel = `Noon, ${now.toLocaleDateString('en-US', dateOptions)}`;
                    break;
                case 'Week': {
                    const adjustedDayOfWeek = (dayOfWeek === 0) ? 6 : dayOfWeek - 1;
                    progress = (adjustedDayOfWeek + progressOfDay) / 7;
                    valueLabel = `Day ${adjustedDayOfWeek + 1}/7`;
                    const midpointDate = new Date(now);
                    midpointDate.setDate(now.getDate() - adjustedDayOfWeek + 3);
                    midpointLabel = `Noon, ${midpointDate.toLocaleDateString('en-US', { weekday: 'long', ...dateOptions })}`;
                    break;
                }
                case 'Month':
                    progress = (dayOfMonth - 1 + progressOfDay) / daysInMonth;
                    valueLabel = `Day ${dayOfMonth}/${daysInMonth}`;
                    const midDay = Math.ceil(daysInMonth / 2);
                    midpointLabel = daysInMonth % 2 !== 0 ? `Noon, ${now.toLocaleString('en-US', {month:'short'})} ${midDay}` : `Midnight between ${now.toLocaleString('en-US', {month:'short'})} ${midDay} & ${midDay + 1}`;
                    break;
                case 'Quarter': {
                    const monthWithFraction = month + (dayOfMonth - 1 + progressOfDay) / daysInMonth;
                    progress = (monthWithFraction % 3) / 3;
                    valueLabel = `Month ${month % 3 + 1}/3`;
                    const midMonthIndex = Math.floor(month / 3) * 3 + 1;
                    const daysInMidMonth = new Date(fullYear, midMonthIndex + 1, 0).getDate();
                    const midMonthName = new Date(fullYear, midMonthIndex, 1).toLocaleString('en-US', { month: 'long' });
                    const midDayQM = Math.ceil(daysInMidMonth/2);
                    midpointLabel = `Noon, ${midMonthName} ${midDayQM}`;
                    break;
                }
                case 'Semester': {
                     const monthWithFraction = month + (dayOfMonth - 1 + progressOfDay) / daysInMonth;
                    progress = (monthWithFraction % 6) / 6;
                    valueLabel = `Month ${month % 6 + 1}/6`;
                    const startOfSemesterMonth = Math.floor(month/6)*6;
                    const endOfThirdMonth = new Date(fullYear, startOfSemesterMonth + 3, 0);
                    midpointLabel = `Midnight, ${endOfThirdMonth.toLocaleString('en-US', {...dateOptions})}`;
                    break;
                }
                case 'Year':
                    progress = progressOfYear;
                    valueLabel = `Month ${month + 1}/12`;
                    const isLeap = (fullYear % 4 === 0 && (fullYear % 100 !== 0 || fullYear % 400 === 0));
                    midpointLabel = `Noon, Jul ${isLeap ? 1 : 2}, ${fullYear}`;
                    break;
                case 'Decade':
                    progress = ((fullYear % 10) + progressOfYear) / 10;
                    valueLabel = `Year ${fullYear % 10 + 1}/10`;
                    midpointLabel = `Midnight, Dec 31, ${Math.floor(fullYear/10)*10 + 4}`;
                    break;
                case 'Century':
                    progress = (((fullYear-1) % 100) + progressOfYear) / 100;
                    valueLabel = `Decade ${Math.floor(((fullYear-1)%100)/10)+1}/10`;
                    midpointLabel = `Midnight, Dec 31, ${Math.floor((fullYear-1)/100)*100 + 50}`;
                    break;
                case 'Millennium':
                    progress = (((fullYear-1) % 1000) + progressOfYear) / 1000;
                    valueLabel = `Century ${Math.floor(((fullYear-1)%1000)/100)+1}/10`;
                    midpointLabel = `Midnight, Dec 31, ${Math.floor((fullYear-1)/1000)*1000 + 500}`;
                    break;
            }
            return { progress, valueLabel, percentage: `${(progress * 100).toFixed(2)}%`, midpointLabel };
        }

        function render(now) {
            const center_x = 50;
            const center_y = 50;
            const initialRadius = 50; 
            const ringWidth = initialRadius / timeUnits.length;
            
            let elements = [];
            for (let i = 0; i < timeUnits.length; i++) {
                const radius = initialRadius - (i * ringWidth);
                if (radius <= 0) break;
                const unit = timeUnits[i];
                const unitData = calculateProgress(unit.name, now);
                const nextRadius = radius - ringWidth;
                elements.push({ ...unitData, unitName: unit.name, radius, nextRadius });
            }
            
            let defsContent = '';
            let circleContent = '';
            let labelContent = '';
            let externalLabelContent = '';

            elements.forEach(el => {
                const { progress, valueLabel, unitName, radius, nextRadius } = el;
                const safeUnitName = unitName.replace(/[^a-zA-Z0-9]/g, '-');
                const angle = progress * 360;
                const clipId = `clip-${safeUnitName}`;
                
                const x2 = center_x + radius * Math.sin(angle * Math.PI / 180);
                const y2 = center_y - radius * Math.cos(angle * Math.PI / 180);
                const largeArcFlag = angle > 180 ? 1 : 0;
                const clipPathD = `M ${center_x},${center_y} L ${center_x},${center_y-radius} A ${radius},${radius} 0 ${largeArcFlag},1 ${x2},${y2} Z`;
                defsContent += `<clipPath id="${clipId}"><path d="${clipPathD}" /></clipPath>`;

                const dataAttributes = `data-unit="${el.unitName}" data-value="${el.valueLabel}" data-percentage="${el.percentage}" data-midpoint="${el.midpointLabel}"`;
                const ringClipId = `ring-clip-${safeUnitName}`;
                defsContent += `<clipPath id="${ringClipId}"><path d="M${center_x-radius},${center_y} A${radius},${radius} 0 1 1 ${center_x+radius},${center_y} A${radius},${radius} 0 1 1 ${center_x-radius},${center_y}Z M${center_x-nextRadius},${center_y} A${nextRadius},${nextRadius} 0 1 0 ${center_x+nextRadius},${center_y} A${nextRadius},${nextRadius} 0 1 0 ${center_x-nextRadius},${center_y}Z" fill-rule="evenodd" /></clipPath>`;

                circleContent += `<circle class="time-circle" ${dataAttributes} cx="${center_x}" cy="${center_y}" r="${radius}" fill="#ffffff" clip-path="url(#${ringClipId})" />`;
                circleContent += `<circle class="time-circle" ${dataAttributes} cx="${center_x}" cy="${center_y}" r="${radius}" fill="#000000" clip-path="url(#${clipId})" />`;
                
                if (radius > nextRadius && nextRadius >= 0) {
                    const markerStroke = "#f87171";
                    [0, 90, 180, 270].forEach(a => {
                        const rad = a * Math.PI / 180;
                        const [x1, y1] = [center_x + nextRadius * Math.sin(rad), center_y - nextRadius * Math.cos(rad)];
                        const [x2, y2] = [center_x + radius * Math.sin(rad), center_y - radius * Math.cos(rad)];
                        circleContent += `<line x1="${x1}" y1="${y1}" x2="${x2}" y2="${y2}" stroke="${markerStroke}" stroke-width="0.15" stroke-dasharray="0.2" pointer-events="none" />`;
                    });
                }
                
                const labelRadius = nextRadius + ringWidth / 2;
                if (labelRadius > 4) {
                    const textPathId = `text-path-${safeUnitName}`;
                    defsContent += `<path id="${textPathId}" d="M ${center_x},${center_y - labelRadius} A ${labelRadius},${labelRadius} 0 1 1 ${center_x - 0.01},${center_y - labelRadius} Z" fill="none" />`;
                    const readableLabel = `${unitName}: ${valueLabel}`;
                    const startOffset = `${progress * 100}%`;
                    labelContent += `<text class="ring-label" fill="#000"><textPath href="#${textPathId}" startOffset="${startOffset}" text-anchor="middle">${readableLabel}</textPath></text>`;
                    labelContent += `<text class="ring-label" fill="#FFF" clip-path="url(#${clipId})"><textPath href="#${textPathId}" startOffset="${startOffset}" text-anchor="middle">${readableLabel}</textPath></text>`;
                }
            });
            
            const externalQuadrantRadius = 52.5;
            const externalPercentRadius = 51.5;

            const quadrantPathId = 'quadrant-path';
            defsContent += `<path id="${quadrantPathId}" d="M ${center_x},${center_y - externalQuadrantRadius} A ${externalQuadrantRadius},${externalQuadrantRadius} 0 1 1 ${center_x-0.01},${center_y - externalQuadrantRadius}Z" fill="none" />`;
            
            const percentPathId = 'percent-path';
            defsContent += `<path id="${percentPathId}" d="M ${center_x},${center_y - externalPercentRadius} A ${externalPercentRadius},${externalPercentRadius} 0 1 1 ${center_x-0.01},${center_y - externalPercentRadius}Z" fill="none" />`;

            const quadrantStyle = 'font-size: 3px; font-weight: 600; fill: #ffffff; letter-spacing: 0.2px;';
            const percentStyle = 'font-size: 3px; font-weight: 700; fill: #f87171;';

            const addCurvedText = (text, pathId, offset, style) => `<text style="${style}"><textPath href="#${pathId}" startOffset="${offset}" text-anchor="middle">${text}</textPath></text>`;

            externalLabelContent += addCurvedText('Discovery', quadrantPathId, '12.5%', quadrantStyle);
            externalLabelContent += addCurvedText('Development', quadrantPathId, '37.5%', quadrantStyle);
            externalLabelContent += addCurvedText('Acceleration', quadrantPathId, '62.5%', quadrantStyle);
            externalLabelContent += addCurvedText('Resolution', quadrantPathId, '87.5%', quadrantStyle);

            externalLabelContent += addCurvedText('0%', percentPathId, '0.5%', percentStyle);
            externalLabelContent += addCurvedText('25%', percentPathId, '25%', percentStyle);
            externalLabelContent += addCurvedText('50%', percentPathId, '50%', percentStyle);
            externalLabelContent += addCurvedText('75%', percentPathId, '75%', percentStyle);

            svgContainer.innerHTML = `<defs>${defsContent}</defs>${circleContent}${labelContent}${externalLabelContent}`;
        }
        
        function updateTime() {
            const now = new Date();
            timeDisplay.textContent = now.toLocaleString('en-US', {
                weekday: 'long', year: 'numeric', month: 'long', day: 'numeric',
                hour: '2-digit', minute: '2-digit', second: '2-digit',
                timeZone: visitorTimezone,
                timeZoneName: 'short'
            }) + ` (Current Time in ${locationName})`;
            render(now);
        }

        svgContainer.addEventListener('mousemove', (e) => {
            const target = e.target.closest('.time-circle');
            if (target) {
                const { unit, value, percentage, midpoint } = target.dataset;
                tooltip.innerHTML = `<div class="font-bold text-gray-200">${unit} (${percentage})</div><div class="text-gray-300">${value}</div><div class="text-xs text-red-400 mt-1">Midpoint: ${midpoint}</div>`;
                tooltip.style.left = `${e.clientX + 15}px`;
                tooltip.style.top = `${e.clientY + 15}px`;
                tooltip.classList.add('visible');
            } else {
                 tooltip.classList.remove('visible');
            }
        });

        svgContainer.addEventListener('mouseleave', () => tooltip.classList.remove('visible'));

        setInterval(updateTime, 100);
        updateTime();

    </script>
</body>
</html>


