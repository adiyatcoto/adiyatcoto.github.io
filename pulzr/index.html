<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>PULZR Audioverse</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000000;
            font-family: 'Poppins', sans-serif;
            color: #e5e7eb;
            touch-action: none;
        }
        canvas {
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 0;
        }
        #ui-container {
            position: relative;
            z-index: 1;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            pointer-events: none;
        }
        #initial-prompt, #file-input, #play-button, #visualization-switcher, .ui-button {
            pointer-events: auto;
        }
        #initial-prompt h1 {
            color: rgba(255, 255, 255, 0.85);
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.5), 0 0 35px rgba(255, 255, 255, 0.3);
        }
        #initial-prompt p {
             color: rgba(229, 231, 235, 0.75);
             text-shadow: 0 0 8px rgba(229, 231, 235, 0.2);
        }
        #audio-controls {
            position: absolute;
            bottom: 2rem;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
            border-radius: 0.75rem;
            padding: 0.5rem 1rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            opacity: 0;
            transition: opacity 0.5s ease-in-out;
            pointer-events: none;
            max-width: 90vw;
        }
        #audio-controls.visible {
            opacity: 1;
            pointer-events: auto;
        }
        #audio-controls audio {
            width: 250px;
            max-width: 50vw;
        }
        #top-bar {
            position: absolute;
            top: 1rem;
            left: 1rem;
            right: 1rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            opacity: 0;
            transition: opacity 0.5s ease-in-out;
            pointer-events: none;
            gap: 0.5rem;
        }
        #top-bar.visible {
            opacity: 1;
            pointer-events: auto;
        }
        #song-title {
            color: white;
            font-size: 0.9rem;
            font-weight: 500;
            background: rgba(0,0,0,0.3);
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            backdrop-filter: blur(10px);
            max-width: 40vw;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            flex-shrink: 1;
        }
        .ui-button {
            background: rgba(0,0,0,0.3);
            backdrop-filter: blur(10px);
            border-radius: 50%;
            cursor: pointer;
            width: 2.5rem;
            height: 2.5rem;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: background 0.2s;
            flex-shrink: 0;
        }
        .ui-button:hover, .ui-button:active {
            background: rgba(0,0,0,0.5);
        }
        body.fullscreen-active #home-btn {
            display: none;
        }
        #playlist-panel {
            position: absolute;
            top: 0;
            right: 0;
            width: 350px;
            max-width: 85vw;
            height: 100%;
            background: rgba(10, 10, 20, 0.95);
            backdrop-filter: blur(15px);
            transform: translateX(100%);
            transition: transform 0.4s ease-in-out;
            z-index: 20;
            display: flex;
            flex-direction: column;
        }
        #playlist-panel.visible {
            transform: translateX(0);
        }
        #playlist-header {
            padding: 1rem;
            border-bottom: 1px solid rgba(255,255,255,0.1);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        #playlist-header h2 {
            font-size: 1.2rem;
            font-weight: 600;
        }
        #playlist-list {
            list-style: none;
            padding: 0;
            margin: 0;
            flex-grow: 1;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
        }
        #playlist-list li {
            padding: 0.75rem 1rem;
            cursor: pointer;
            transition: background 0.2s;
            border-bottom: 1px solid rgba(255,255,255,0.05);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        #playlist-list li > span {
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            font-size: 0.9rem;
        }
        #playlist-list li:hover, #playlist-list li:active {
            background: rgba(255,255,255,0.1);
        }
        #playlist-list li.playing {
            background: rgba(99, 102, 241, 0.5);
            font-weight: 600;
        }
        .remove-track-btn {
            background: none;
            border: none;
            color: #9ca3af;
            cursor: pointer;
            padding: 0.25rem;
            border-radius: 50%;
            transition: color 0.2s, background 0.2s;
            flex-shrink: 0;
            margin-left: 1rem;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .remove-track-btn:hover, .remove-track-btn:active {
            color: #fca5a5;
            background: rgba(255, 255, 255, 0.1);
        }

        #visualization-switcher {
            position: absolute;
            bottom: 7rem;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            align-items: center;
            gap: 0.5rem;
            background: rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
            border-radius: 0.5rem;
            padding: 0.5rem 0.75rem;
            opacity: 0;
            transition: opacity 0.5s ease-in-out;
        }
        #visualization-switcher.visible {
            opacity: 1;
        }
        .arrow-btn {
            background: rgba(255,255,255,0.1);
            border: none;
            color: white;
            padding: 0.4rem;
            border-radius: 50%;
            cursor: pointer;
            transition: background 0.2s;
            width: 2rem;
            height: 2rem;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-shrink: 0;
        }
        .arrow-btn:hover, .arrow-btn:active {
            background: rgba(255,255,255,0.2);
        }
        #vis-name {
            color: white;
            font-weight: 500;
            width: 120px;
            text-align: center;
            font-size: 0.9rem;
        }
        
        #footer {
            font-size: 0.8rem;
        }

        @media (max-width: 640px) {
            #initial-prompt h1, #initial-prompt h2 {
                font-size: 2rem;
            }
            #initial-prompt p {
                font-size: 0.9rem;
            }
            #song-title {
                font-size: 0.8rem;
                padding: 0.4rem 0.8rem;
                max-width: 35vw;
            }
            .ui-button {
                width: 2.2rem;
                height: 2.2rem;
            }
            .ui-button svg {
                width: 18px;
                height: 18px;
            }
            #audio-controls audio {
                width: 180px;
            }
            #visualization-switcher {
                bottom: 6rem;
            }
            #vis-name {
                width: 100px;
                font-size: 0.85rem;
            }
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    <canvas id="matrixCanvas" style="display: none;"></canvas>

    <div id="ui-container">
        <div id="initial-prompt" class="flex flex-col items-center gap-4 p-8">
              <h1 class="text-4xl md:text-6xl font-bold text-white tracking-tighter">P U L Z R</h1>
              <h2 class="text-4xl md:text-6xl font-bold text-white tracking-tighter">Interactive Audio Visualization.</h2>
              <p class="text-gray-300 max-w-md mt-2">Upload and play your favorite audio playlist to generate a unique visual universe.</p>
              <div class="mt-6 flex gap-4">
                  <label for="file-input" class="cursor-pointer bg-indigo-600 hover:bg-indigo-500 active:bg-indigo-700 text-white font-bold py-3 px-6 rounded-lg transition-transform duration-200 hover:scale-105 active:scale-95 shadow-lg">
                      Upload Audio
                  </label>
                  <button id="resume-btn" class="hidden cursor-pointer bg-gray-600 hover:bg-gray-500 active:bg-gray-700 text-white font-bold py-3 px-6 rounded-lg transition-transform duration-200 hover:scale-105 active:scale-95 shadow-lg">
                      Resume Session
                  </button>
              </div>
              <input type="file" id="file-input" class="hidden" multiple accept="audio/*">
        </div>
    </div>
    
    <div id="top-bar" class="pointer-events-none">
        <button id="home-btn" class="ui-button" title="Back to Home">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"/><polyline points="9 22 9 12 15 12 15 22"/></svg>
        </button>
        <div id="song-title"></div>
        <div class="flex items-center gap-2">
            <button id="fullscreen-btn" class="ui-button" title="Toggle Fullscreen">
                <svg id="enter-fullscreen-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"/></svg>
                <svg id="exit-fullscreen-icon" class="hidden" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M8 3v3a2 2 0 0 1-2 2H3m18 0h-3a2 2 0 0 1-2-2V3m0 18v-3a2 2 0 0 1 2-2h3M3 16h3a2 2 0 0 1 2 2v3"/></svg>
            </button>
            <button id="playlist-btn" class="ui-button" title="Toggle Playlist">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="8" y1="6" x2="21" y2="6"/><line x1="8" y1="12" x2="21" y2="12"/><line x1="8" y1="18" x2="21" y2="18"/><line x1="3" y1="6" x2="3.01" y2="6"/><line x1="3" y1="12" x2="3.01" y2="12"/><line x1="3" y1="18" x2="3.01" y2="18"/></svg>
            </button>
        </div>
    </div>

    <div id="playlist-panel">
        <div id="playlist-header">
            <h2>Playlist</h2>
            <div class="flex items-center gap-2">
                <label for="file-input" class="arrow-btn" title="Add Tracks">
                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="12" y1="5" x2="12" y2="19"/><line x1="5" y1="12" x2="19" y2="12"/></svg>
                </label>
                <button id="close-playlist-btn" class="arrow-btn" title="Close Playlist">
                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg>
                </button>
            </div>
        </div>
        <ul id="playlist-list"></ul>
    </div>

    <div id="audio-controls">
        <button id="prev-track-btn" class="arrow-btn" title="Previous Track">
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="11 19 2 12 11 5 11 19"/><polygon points="22 19 13 12 22 5 22 19"/></svg>
        </button>
        <audio id="audio" controls></audio>
        <button id="next-track-btn" class="arrow-btn" title="Next Track">
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="13 19 22 12 13 5 13 19"/><polygon points="2 19 11 12 2 5 2 19"/></svg>
        </button>
    </div>
    
    <div id="visualization-switcher">
        <button id="prev-vis" class="arrow-btn">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 18l-6-6 6-6"/></svg>
        </button>
        <div id="vis-name">Particle Sphere</div>
        <button id="next-vis" class="arrow-btn">
             <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9 18l6-6-6-6"/></svg>
        </button>
    </div>
    
    <div id="footer" class="absolute bottom-4 w-full text-center text-white text-sm pointer-events-none z-10">
        &copy; Adiyat Coto 2025
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Import OrbitControls - compatible with Safari
        (function() {
            THREE.OrbitControls = function(object, domElement) {
                this.object = object;
                this.domElement = (domElement !== undefined) ? domElement : document;
                this.enabled = true;
                this.target = new THREE.Vector3();
                this.minDistance = 0;
                this.maxDistance = Infinity;
                this.minZoom = 0;
                this.maxDistance = Infinity;
                this.minPolarAngle = 0;
                this.maxPolarAngle = Math.PI;
                this.minAzimuthAngle = -Infinity;
                this.maxAzimuthAngle = Infinity;
                this.enableDamping = false;
                this.dampingFactor = 0.25;
                this.enableZoom = true;
                this.zoomSpeed = 1.0;
                this.enableRotate = true;
                this.rotateSpeed = 1.0;
                this.enablePan = true;
                this.keyPanSpeed = 7.0;
                this.autoRotate = false;
                this.autoRotateSpeed = 2.0;
                this.enableKeys = true;
                this.keys = {LEFT: 37, UP: 38, RIGHT: 39, BOTTOM: 40};
                this.mouseButtons = {ORBIT: THREE.MOUSE.LEFT, ZOOM: THREE.MOUSE.MIDDLE, PAN: THREE.MOUSE.RIGHT};
                this.target0 = this.target.clone();
                this.position0 = this.object.position.clone();
                this.zoom0 = this.object.zoom;
                
                var scope = this;
                var rotateStart = new THREE.Vector2();
                var rotateEnd = new THREE.Vector2();
                var rotateDelta = new THREE.Vector2();
                var panStart = new THREE.Vector2();
                var panEnd = new THREE.Vector2();
                var panDelta = new THREE.Vector2();
                var dollyStart = new THREE.Vector2();
                var dollyEnd = new THREE.Vector2();
                var dollyDelta = new THREE.Vector2();
                var STATE = {NONE: -1, ROTATE: 0, DOLLY: 1, PAN: 2, TOUCH_ROTATE: 3, TOUCH_DOLLY: 4, TOUCH_PAN: 5};
                var state = STATE.NONE;
                var EPS = 0.000001;
                var spherical = new THREE.Spherical();
                var sphericalDelta = new THREE.Spherical();
                var scale = 1;
                var panOffset = new THREE.Vector3();
                var zoomChanged = false;
                var rotateSpeed = 1.0;

                this.update = function() {
                    var offset = new THREE.Vector3();
                    var quat = new THREE.Quaternion().setFromUnitVectors(object.up, new THREE.Vector3(0, 1, 0));
                    var quatInverse = quat.clone().invert();
                    var lastPosition = new THREE.Vector3();
                    var lastQuaternion = new THREE.Quaternion();
                    return function update() {
                        var position = scope.object.position;
                        offset.copy(position).sub(scope.target);
                        offset.applyQuaternion(quat);
                        spherical.setFromVector3(offset);
                        if (scope.autoRotate && state === STATE.NONE) {
                            rotateLeft(getAutoRotationAngle());
                        }
                        spherical.theta += sphericalDelta.theta;
                        spherical.phi += sphericalDelta.phi;
                        spherical.theta = Math.max(scope.minAzimuthAngle, Math.min(scope.maxAzimuthAngle, spherical.theta));
                        spherical.phi = Math.max(scope.minPolarAngle, Math.min(scope.maxPolarAngle, spherical.phi));
                        spherical.makeSafe();
                        spherical.radius *= scale;
                        spherical.radius = Math.max(scope.minDistance, Math.min(scope.maxDistance, spherical.radius));
                        scope.target.add(panOffset);
                        offset.setFromSpherical(spherical);
                        offset.applyQuaternion(quatInverse);
                        position.copy(scope.target).add(offset);
                        scope.object.lookAt(scope.target);
                        if (scope.enableDamping === true) {
                            sphericalDelta.theta *= (1 - scope.dampingFactor);
                            sphericalDelta.phi *= (1 - scope.dampingFactor);
                            panOffset.multiplyScalar(1 - scope.dampingFactor);
                        } else {
                            sphericalDelta.set(0, 0, 0);
                            panOffset.set(0, 0, 0);
                        }
                        scale = 1;
                        if (zoomChanged || lastPosition.distanceToSquared(scope.object.position) > EPS || 8 * (1 - lastQuaternion.dot(scope.object.quaternion)) > EPS) {
                            lastPosition.copy(scope.object.position);
                            lastQuaternion.copy(scope.object.quaternion);
                            zoomChanged = false;
                            return true;
                        }
                        return false;
                    };
                }();

                function getAutoRotationAngle() {
                    return 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;
                }

                function rotateLeft(angle) {
                    sphericalDelta.theta -= angle;
                }

                function rotateUp(angle) {
                    sphericalDelta.phi -= angle;
                }

                var panLeft = function() {
                    var v = new THREE.Vector3();
                    return function panLeft(distance, objectMatrix) {
                        v.setFromMatrixColumn(objectMatrix, 0);
                        v.multiplyScalar(-distance);
                        panOffset.add(v);
                    };
                }();

                var panUp = function() {
                    var v = new THREE.Vector3();
                    return function panUp(distance, objectMatrix) {
                        v.setFromMatrixColumn(objectMatrix, 1);
                        v.multiplyScalar(distance);
                        panOffset.add(v);
                    };
                }();

                this.dispose = function() {
                    scope.domElement.removeEventListener('contextmenu', onContextMenu, false);
                    scope.domElement.removeEventListener('mousedown', onMouseDown, false);
                    scope.domElement.removeEventListener('wheel', onMouseWheel, false);
                    scope.domElement.removeEventListener('touchstart', onTouchStart, false);
                    scope.domElement.removeEventListener('touchend', onTouchEnd, false);
                    scope.domElement.removeEventListener('touchmove', onTouchMove, false);
                    document.removeEventListener('mousemove', onMouseMove, false);
                    document.removeEventListener('mouseup', onMouseUp, false);
                    window.removeEventListener('keydown', onKeyDown, false);
                };

                function onMouseDown(event) {
                    if (scope.enabled === false) return;
                    event.preventDefault();
                    if (event.button === scope.mouseButtons.ORBIT) {
                        if (scope.enableRotate === false) return;
                        rotateStart.set(event.clientX, event.clientY);
                        state = STATE.ROTATE;
                    }
                    if (state !== STATE.NONE) {
                        document.addEventListener('mousemove', onMouseMove, false);
                        document.addEventListener('mouseup', onMouseUp, false);
                    }
                }

                function onMouseMove(event) {
                    if (scope.enabled === false) return;
                    event.preventDefault();
                    if (state === STATE.ROTATE) {
                        if (scope.enableRotate === false) return;
                        rotateEnd.set(event.clientX, event.clientY);
                        rotateDelta.subVectors(rotateEnd, rotateStart);
                        var element = scope.domElement === document ? scope.domElement.body : scope.domElement;
                        rotateLeft(2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed);
                        rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed);
                        rotateStart.copy(rotateEnd);
                        scope.update();
                    }
                }

                function onMouseUp(event) {
                    if (scope.enabled === false) return;
                    document.removeEventListener('mousemove', onMouseMove, false);
                    document.removeEventListener('mouseup', onMouseUp, false);
                    state = STATE.NONE;
                }

                function onMouseWheel(event) {
                    if (scope.enabled === false || scope.enableZoom === false || (state !== STATE.NONE && state !== STATE.ROTATE)) return;
                    event.preventDefault();
                    event.stopPropagation();
                    if (event.deltaY < 0) {
                        scale /= Math.pow(0.95, scope.zoomSpeed);
                    } else if (event.deltaY > 0) {
                        scale *= Math.pow(0.95, scope.zoomSpeed);
                    }
                    scope.update();
                }

                function onTouchStart(event) {
                    if (scope.enabled === false) return;
                    switch (event.touches.length) {
                        case 1:
                            if (scope.enableRotate === false) return;
                            rotateStart.set(event.touches[0].pageX, event.touches[0].pageY);
                            state = STATE.TOUCH_ROTATE;
                            break;
                        case 2:
                            if (scope.enableZoom === false) return;
                            var dx = event.touches[0].pageX - event.touches[1].pageX;
                            var dy = event.touches[0].pageY - event.touches[1].pageY;
                            var distance = Math.sqrt(dx * dx + dy * dy);
                            dollyStart.set(0, distance);
                            state = STATE.TOUCH_DOLLY;
                            break;
                        default:
                            state = STATE.NONE;
                    }
                }

                function onTouchMove(event) {
                    if (scope.enabled === false) return;
                    event.preventDefault();
                    event.stopPropagation();
                    switch (event.touches.length) {
                        case 1:
                            if (scope.enableRotate === false) return;
                            if (state !== STATE.TOUCH_ROTATE) return;
                            rotateEnd.set(event.touches[0].pageX, event.touches[0].pageY);
                            rotateDelta.subVectors(rotateEnd, rotateStart);
                            var element = scope.domElement === document ? scope.domElement.body : scope.domElement;
                            rotateLeft(2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed);
                            rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed);
                            rotateStart.copy(rotateEnd);
                            scope.update();
                            break;
                        case 2:
                            if (scope.enableZoom === false) return;
                            if (state !== STATE.TOUCH_DOLLY) return;
                            var dx = event.touches[0].pageX - event.touches[1].pageX;
                            var dy = event.touches[0].pageY - event.touches[1].pageY;
                            var distance = Math.sqrt(dx * dx + dy * dy);
                            dollyEnd.set(0, distance);
                            dollyDelta.subVectors(dollyEnd, dollyStart);
                            if (dollyDelta.y > 0) {
                                scale /= Math.pow(0.95, scope.zoomSpeed);
                            } else if (dollyDelta.y < 0) {
                                scale *= Math.pow(0.95, scope.zoomSpeed);
                            }
                            dollyStart.copy(dollyEnd);
                            scope.update();
                            break;
                        default:
                            state = STATE.NONE;
                    }
                }

                function onTouchEnd(event) {
                    if (scope.enabled === false) return;
                    state = STATE.NONE;
                }

                function onContextMenu(event) {
                    event.preventDefault();
                }

                function onKeyDown(event) {
                    if (scope.enabled === false || scope.enableKeys === false || scope.enablePan === false) return;
                    // Handle key events if needed
                }

                this.domElement.addEventListener('contextmenu', onContextMenu, false);
                this.domElement.addEventListener('mousedown', onMouseDown, false);
                this.domElement.addEventListener('wheel', onMouseWheel, false);
                this.domElement.addEventListener('touchstart', onTouchStart, false);
                this.domElement.addEventListener('touchend', onTouchEnd, false);
                this.domElement.addEventListener('touchmove', onTouchMove, false);
                this.update();
            };
        })();

        let scene, camera, renderer, controls, analyser, dataArray, audioContext;
        let visualizations = [];
        let currentVisualizationIndex = 0;
        let backgroundGroup;
        let playlist = [];
        let currentTrackIndex = -1;
        let uiHideTimeout;
        let audioContextResumed = false;

        const fileInput = document.getElementById('file-input');
        const audio = document.getElementById('audio');
        const initialPrompt = document.getElementById('initial-prompt');
        const resumeBtn = document.getElementById('resume-btn');
        const audioControlsContainer = document.getElementById('audio-controls');
        const canvasContainer = document.getElementById('canvas-container');
        const topBar = document.getElementById('top-bar');
        const songTitleElement = document.getElementById('song-title');
        const visSwitcher = document.getElementById('visualization-switcher');
        const prevVisBtn = document.getElementById('prev-vis');
        const nextVisBtn = document.getElementById('next-vis');
        const visNameElement = document.getElementById('vis-name');
        const footerElement = document.getElementById('footer');
        const homeBtn = document.getElementById('home-btn');
        const playlistBtn = document.getElementById('playlist-btn');
        const playlistPanel = document.getElementById('playlist-panel');
        const playlistList = document.getElementById('playlist-list');
        const closePlaylistBtn = document.getElementById('close-playlist-btn');
        const prevTrackBtn = document.getElementById('prev-track-btn');
        const nextTrackBtn = document.getElementById('next-track-btn');
        const fullscreenBtn = document.getElementById('fullscreen-btn');
        const enterFullscreenIcon = document.getElementById('enter-fullscreen-icon');
        const exitFullscreenIcon = document.getElementById('exit-fullscreen-icon');
        const interactiveUIs = [topBar, audioControlsContainer, visSwitcher];

        function createGlowTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 128; canvas.height = 128;
            const context = canvas.getContext('2d');
            const gradient = context.createRadialGradient(64, 64, 0, 64, 64, 64);
            gradient.addColorStop(0, 'rgba(255,255,255,1)');
            gradient.addColorStop(0.2, 'rgba(255,255,255,0.8)');
            gradient.addColorStop(0.5, 'rgba(255,255,255,0.3)');
            gradient.addColorStop(1, 'rgba(255,255,255,0)');
            context.fillStyle = gradient;
            context.fillRect(0, 0, 128, 128);
            return new THREE.CanvasTexture(canvas);
        }

        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 8;
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            canvasContainer.appendChild(renderer.domElement);
            
            backgroundGroup = new THREE.Group();
            const bgGeometry = new THREE.PlaneGeometry(30, 30, 100, 100);
            const bgMaterial = new THREE.ShaderMaterial({
                uniforms: { time: { value: 0 } },
                vertexShader: `
                    uniform float time; varying vec2 vUv;
                    void main() {
                        vUv = uv; vec3 pos = position;
                        float wave1 = sin(pos.x * 2.0 + time * 0.4) * 0.5;
                        float wave2 = sin(pos.y * 3.0 + time * 0.3) * 0.2;
                        float twist = cos(pos.y * 1.0 + time * 0.5) * 0.3;
                        pos.y += wave1 + wave2;
                        pos.z += cos(pos.x * 1.5 + time * 0.2) * 0.3 + twist;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform float time; varying vec2 vUv;
                    float random(vec2 st) { return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123); }
                    float noise(vec2 st) {
                        vec2 i = floor(st); vec2 f = fract(st);
                        float a = random(i); float b = random(i + vec2(1.0, 0.0));
                        float c = random(i + vec2(0.0, 1.0)); float d = random(i + vec2(1.0, 1.0));
                        vec2 u = f * f * (3.0 - 2.0 * f);
                        return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.y * u.x;
                    }
                    void main() {
                        vec3 color1 = vec3(0.8, 0.1, 0.5); vec3 color2 = vec3(0.1, 0.2, 0.9); vec3 color3 = vec3(0.2, 0.8, 0.7);
                        float n = noise(vUv * 3.0 + vec2(0.0, time * -0.1));
                        vec3 mixed = mix(color1, color2, n);
                        vec3 finalColor = mix(mixed, color3, vUv.y * 0.8);
                        float veins = smoothstep(0.7, 0.75, noise(vUv * 8.0 + vec2(0.0, time * -0.2)));
                        finalColor += veins * 0.3;
                        gl_FragColor = vec4(finalColor, 1.0);
                    }
                `,
                side: THREE.DoubleSide
            });
            const bgMesh = new THREE.Mesh(bgGeometry, bgMaterial);
            bgMesh.rotation.x = -Math.PI / 3;
            backgroundGroup.add(bgMesh);
            scene.add(backgroundGroup);

            visualizations.push(new VisParticleSphere());
            visualizations.push(new VisDynamicTerrain());
            visualizations.push(new VisOscillator());
            visualizations.push(new VisFrequencyCanvas());
            visualizations.push(new VisLiquidMarble());
            visualizations.push(new VisStageLights());
            visualizations.push(new VisGrasshopper());
            visualizations.push(new VisMatrix());
            
            visualizations.forEach((vis) => {
                vis.init(scene);
                vis.group.visible = false;
            });
            visNameElement.textContent = visualizations[currentVisualizationIndex].name;

            window.addEventListener('resize', onWindowResize, false);
            fileInput.addEventListener('change', onFileSelect, false);
            homeBtn.addEventListener('click', goHome);
            resumeBtn.addEventListener('click', resumeSession);
            playlistBtn.addEventListener('click', () => playlistPanel.classList.add('visible'));
            closePlaylistBtn.addEventListener('click', () => playlistPanel.classList.remove('visible'));
            audio.addEventListener('ended', playNextTrack);
            audio.addEventListener('play', resumeAudioContext);
            prevVisBtn.addEventListener('click', () => switchVisualization(-1));
            nextVisBtn.addEventListener('click', () => switchVisualization(1));
            prevTrackBtn.addEventListener('click', playPreviousTrack);
            nextTrackBtn.addEventListener('click', playNextTrack);
            fullscreenBtn.addEventListener('click', toggleFullscreen);
            document.addEventListener('fullscreenchange', onFullscreenChange);
            document.addEventListener('webkitfullscreenchange', onFullscreenChange);
            document.addEventListener('mozfullscreenchange', onFullscreenChange);
            document.addEventListener('msfullscreenchange', onFullscreenChange);

            document.addEventListener('click', (event) => {
                if (playlistPanel.classList.contains('visible') && !playlistPanel.contains(event.target) && !playlistBtn.contains(event.target)) {
                    playlistPanel.classList.remove('visible');
                }
            });

            document.addEventListener('touchstart', (event) => {
                if (playlistPanel.classList.contains('visible') && !playlistPanel.contains(event.target) && !playlistBtn.contains(event.target)) {
                    playlistPanel.classList.remove('visible');
                }
            });
        }
        
        class VisParticleSphere{constructor(){this.name="Particle Sphere";this.group=new THREE.Group;this.originalPositions=null;this.satellites=[]}init(e){const t=new THREE.IcosahedronGeometry(2.5,64);t.setAttribute("color",new THREE.BufferAttribute(new Float32Array(3*t.attributes.position.count),3)),this.originalPositions=new Float32Array(t.attributes.position.array);const i=new THREE.PointsMaterial({size:.08,vertexColors:!0,map:createGlowTexture(),blending:THREE.AdditiveBlending,transparent:!0,depthWrite:!1});this.sphere=new THREE.Points(t,i),this.group.add(this.sphere);const s=new THREE.PointsMaterial({size:.1,color:65535,map:createGlowTexture(),blending:THREE.AdditiveBlending,transparent:!0,depthWrite:!1}),o=150;for(let e=0;e<o;e++){const t=new THREE.BufferGeometry;t.setAttribute("position",new THREE.BufferAttribute(new Float32Array([0,0,0]),3));const i=new THREE.Points(t,s.clone());this.satellites.push({point:i,radius:4+2*Math.random(),speed:.002+.008*Math.random(),angle:2*Math.random()*Math.PI,axis:(new THREE.Vector3(Math.random()-.5,Math.random()-.5,Math.random()-.5)).normalize()}),this.group.add(i)}const n=new THREE.BufferGeometry;n.setAttribute("position",new THREE.BufferAttribute(new Float32Array(3*o),3));const a=new THREE.LineBasicMaterial({color:16777215,transparent:!0,opacity:.3,blending:THREE.AdditiveBlending,depthWrite:!1});this.satelliteConnectorLine=new THREE.Line(n,a),this.group.add(this.satelliteConnectorLine),e.add(this.group)}update(e,t){const i=this.sphere.geometry.attributes.position.array,s=this.sphere.geometry.attributes.color.array;this.sphere.material.size=.03+t.avgVolume/255*.1;const o=performance.now()*.0005;for(let n=0;n<i.length;n+=3){const a=n/3,r=2*a%e.length,l=e[r],h=l/255*2*Math.pow(1-r/e.length,1.5),c=new THREE.Vector3(this.originalPositions[n],this.originalPositions[n+1],this.originalPositions[n+2]);c.normalize().multiplyScalar(1+h),i[n]=2.5*c.x,i[n+1]=2.5*c.y,i[n+2]=2.5*c.z;const d=(new THREE.Color).setHSL((o+a/i.length*.1)%1,.9,.5+l/255*.4);d.r+=.8*t.avgLow,d.g+=.8*t.avgMid,d.b+=.8*t.avgHigh,s[n]=d.r,s[n+1]=d.g,s[n+2]=d.b}this.sphere.geometry.attributes.position.needsUpdate=!0,this.sphere.geometry.attributes.color.needsUpdate=!0,this.sphere.rotation.y+=.0008;const n=this.satelliteConnectorLine.geometry.attributes.position.array;let a=0;this.satellites.forEach(e=>{e.angle+=e.speed;const i=(new THREE.Quaternion).setFromAxisAngle(e.axis,e.angle),s=(new THREE.Vector3(e.radius*(1+.5*t.avgLow),0,0)).applyQuaternion(i);e.point.position.copy(s),n[a++]=s.x,n[a++]=s.y,n[a++]=s.z,e.point.material.color.setHSL(.55,1,Math.min(.5+1.5*t.avgHigh,1))}),this.satelliteConnectorLine.geometry.setDrawRange(0,this.satellites.length),this.satelliteConnectorLine.geometry.attributes.position.needsUpdate=!0}}
        class VisDynamicTerrain{constructor(){this.name="Dynamic Terrain";this.group=new THREE.Group;this.originalPositions=null}init(e){const t=128,i=new THREE.PlaneGeometry(15,15,t,t);this.plane=new THREE.Mesh(i,new THREE.MeshPhongMaterial({vertexColors:!0,wireframe:!0})),this.plane.rotation.x=-Math.PI/2.5,this.originalPositions=new Float32Array(i.attributes.position.array),this.group.add(this.plane);const s=new THREE.BufferGeometry;s.setAttribute("position",new THREE.BufferAttribute(new Float32Array(3*(t+1)*(t+1)),3)),this.peakParticles=new THREE.Points(s,new THREE.PointsMaterial({size:.05,color:16777215,map:createGlowTexture(),blending:THREE.AdditiveBlending,transparent:!0,depthWrite:!1})),this.peakParticles.rotation.x=this.plane.rotation.x,this.group.add(this.peakParticles),this.group.add(new THREE.AmbientLight(16777215,.2));const o=new THREE.DirectionalLight(16777215,1);o.position.set(0,1,.5),this.group.add(o),e.add(this.group)}update(e,t){const i=this.plane.geometry.attributes.position.array,s=this.peakParticles.geometry.attributes.position.array,o=new Float32Array(i.length);for(let n=0;n<i.length;n+=3){const a=n+2,r=Math.floor(a/3%e.length*.5),l=e[r]/255*3*t.avgLow;i[a]=this.originalPositions[a]+l,s[n]=i[n],s[n+1]=i[n+1],s[n+2]=i[a]+.02;const h=new THREE.Color;h.setHSL((.6-.1*l)%1,1,.5),o[n]=h.r,o[n+1]=h.g,o[n+2]=h.b}this.plane.geometry.setAttribute("color",new THREE.BufferAttribute(o,3)),this.plane.geometry.attributes.position.needsUpdate=!0,this.peakParticles.geometry.attributes.position.needsUpdate=!0}}
        class VisOscillator{constructor(){this.name="Oscillator";this.group=new THREE.Group;this.timeDomainArray=null;this.trails=[];this.trailCount=8;this.segmentCount=512}init(e){for(let t=0;t<this.trailCount;t++){const i=new THREE.BufferGeometry,s=new Float32Array(2*this.segmentCount*3),o=new Float32Array(2*this.segmentCount*3);i.setAttribute("position",new THREE.BufferAttribute(s,3)),i.setAttribute("color",new THREE.BufferAttribute(o,3));const n=new THREE.MeshBasicMaterial({side:THREE.DoubleSide,vertexColors:!0,transparent:!0,opacity:1-t/this.trailCount*.8,blending:THREE.AdditiveBlending,depthWrite:!1}),a=new THREE.Mesh(i,n);this.trails.push(a),this.group.add(a)}e.add(this.group)}update(e,t){if(!analyser)return;this.timeDomainArray||(this.timeDomainArray=new Uint8Array(analyser.frequencyBinCount)),analyser.getByteTimeDomainData(this.timeDomainArray);for(let e=this.trailCount-1;e>0;e--)this.trails[e].geometry.attributes.position.array.set(this.trails[e-1].geometry.attributes.position.array),this.trails[e].geometry.attributes.color.array.set(this.trails[e-1].geometry.attributes.color.array),this.trails[e].geometry.attributes.position.needsUpdate=!0,this.trails[e].geometry.attributes.color.needsUpdate=!0;const i=this.trails[0].geometry.attributes.position.array,s=this.trails[0].geometry.attributes.color.array,o=.3,n=performance.now()*.001;for(let e=0;e<this.segmentCount;e++){const t=Math.floor(e/this.segmentCount*this.timeDomainArray.length),a=this.timeDomainArray[t]/128,r=2.5*(a-1),l=-6+e/this.segmentCount*12,h=Math.sin(.1*e+n)*.5;i[6*e+0]=l,i[6*e+1]=r+o,i[6*e+2]=h,i[6*e+3]=l,i[6*e+4]=r-o,i[6*e+5]=h;const c=new THREE.Color;c.setHSL(.5+r/5,1,.5),s[6*e+0]=c.r,s[6*e+1]=c.g,s[6*e+2]=c.b,s[6*e+3]=c.r,s[6*e+4]=c.g,s[6*e+5]=c.b}const a=[];for(let e=0;e<this.segmentCount-1;e++){const t=2*e,i=t+1,s=t+2,o=t+3;a.push(t,i,s),a.push(i,o,s)}this.trails[0].geometry.setIndex(a),this.trails[0].geometry.attributes.position.needsUpdate=!0,this.trails[0].geometry.attributes.color.needsUpdate=!0,this.trails[0].geometry.computeVertexNormals()}}
        class VisFrequencyCanvas{constructor(){this.name="Frequency Canvas";this.group=new THREE.Group}init(e){const t=128,i=12,s=new THREE.BufferGeometry,o=new Float32Array(t*t*3),n=new Float32Array(t*t*3);for(let e=0;e<t;e++)for(let a=0;a<t;a++){const r=(e*t+a)*3;o[r]=(a/(t-1)-.5)*i,o[r+1]=(e/(t-1)-.5)*i,o[r+2]=0}s.setAttribute("position",new THREE.BufferAttribute(o,3)),s.setAttribute("color",new THREE.BufferAttribute(n,3));const a=new THREE.PointsMaterial({size:.08,vertexColors:!0,map:createGlowTexture(),blending:THREE.AdditiveBlending,transparent:!0,depthWrite:!1});this.particles=new THREE.Points(s,a),this.group.add(this.particles),this.group.rotation.x=-Math.PI/3,e.add(this.group)}update(e,t){const i=this.particles.geometry.attributes.position.array,s=this.particles.geometry.attributes.color.array,o=Math.sqrt(i.length/3),n=Math.sqrt(.25+.25);for(let t=0;t<o;t++)for(let a=0;a<o;a++){const r=(t*o+a)*3,l=a/(o-1)-.5,h=t/(o-1)-.5,c=Math.sqrt(l*l+h*h),d=Math.pow(c/n,2),u=Math.floor(d*(.75*e.length)),g=e[u]/255;i[r+2]=2*g;const m=new THREE.Color,p=.7-.7*d;m.setHSL(p,1,.5+.5*g),s[r]=m.r,s[r+1]=m.g,s[r+2]=m.b}this.particles.geometry.attributes.position.needsUpdate=!0,this.particles.geometry.attributes.color.needsUpdate=!0}}
        
        class VisLiquidMarble {
            constructor() {
                this.name = "Liquid Marble";
                this.group = new THREE.Group();
                this.lastHighPeak = 0;
            }
            init(scene) {
                const geometry = new THREE.PlaneGeometry(2, 2); 
                this.material = new THREE.ShaderMaterial({
                    uniforms: {
                        time: { value: 0 },
                        avgLow: { value: 0 },
                        avgMid: { value: 0 },
                        avgHigh: { value: 0 },
                        highPeak: { value: 0 }
                    },
                    vertexShader: `
                        varying vec2 vUv; 
                        void main() { 
                            vUv = uv; 
                            gl_Position = vec4(position, 1.0); 
                        }
                    `,
                    fragmentShader: `
                        uniform float time;
                        uniform float avgLow;
                        uniform float avgMid;
                        uniform float avgHigh;
                        uniform float highPeak;
                        varying vec2 vUv;

                        float random (in vec2 _st) { return fract(sin(dot(_st.xy, vec2(12.9898,78.233))) * 43758.5453123); }
                        float noise (in vec2 _st) {
                            vec2 i = floor(_st); vec2 f = fract(_st);
                            float a = random(i); float b = random(i + vec2(1.0, 0.0));
                            float c = random(i + vec2(0.0, 1.0)); float d = random(i + vec2(1.0, 1.0));
                            vec2 u = f * f * (3.0 - 2.0 * f);
                            return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.y * u.x;
                        }
                        #define NUM_OCTAVES 5
                        float fbm ( in vec2 _st) {
                            float v = 0.0; float a = 0.5; vec2 shift = vec2(100.0);
                            mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.50));
                            for (int i = 0; i < NUM_OCTAVES; ++i) { v += a * noise(_st); _st = rot * _st * 2.0 + shift; a *= 0.5; }
                            return v;
                        }

                        void main() {
                            vec2 st = vUv * (2.0 + avgLow * 2.0) - (1.0 + avgLow);
                            st += vec2(sin(time * 0.1), cos(time * 0.1)) * 0.5;
                            vec2 q = vec2(fbm(st + 0.1*time), fbm(st + vec2(1.0)));
                            vec2 r = vec2(fbm(st + 1.0*q + vec2(1.7,9.2)+ 0.15*time), fbm(st + 1.0*q + vec2(8.3,2.8)+ 0.126*time));
                            float f = fbm(st+r);
                            vec3 color = mix(vec3(0.1,0.6,0.7), vec3(0.7,0.7,0.5), clamp((f*f)*4.0,0.0,1.0));
                            color = mix(color, vec3(0.0,0.0,0.16), clamp(length(q),0.0,1.0));
                            color = mix(color, vec3(0.7,1.0,1.0), clamp(length(r.x),0.0,1.0));
                            color *= (f*f*f+.6*f*f+.5*f);
                            
                            float wave = sin(vUv.x * 10.0 + time * 2.0) * 0.3 * avgLow;
                            color *= 1.0 + wave;

                            float lightning = smoothstep(0.3, 0.8, noise(vUv * 10.0 + time * 0.5)) * highPeak * 2.0;
                            color += vec3(0.8, 1.0, 1.0) * lightning;

                            gl_FragColor = vec4(color,1.0);
                        }
                    `
                });
                const mesh = new THREE.Mesh(geometry, this.material);
                this.group.add(mesh);
                scene.add(this.group);
            }
            update(dataArray, audioFeatures) {
                this.material.uniforms.time.value = performance.now() * 0.0005;
                this.material.uniforms.avgLow.value = audioFeatures.avgLow;
                this.material.uniforms.avgMid.value = audioFeatures.avgMid;
                this.material.uniforms.avgHigh.value = audioFeatures.avgHigh;
                
                let highPeakValue = 0;
                if (audioFeatures.avgHigh - this.lastHighPeak > 0.2) {
                    highPeakValue = 1;
                }
                this.material.uniforms.highPeak.value = highPeakValue;
                this.lastHighPeak = audioFeatures.avgHigh;
            }
        }

        class VisStageLights {
            constructor() {
                this.name = "Grainy Screen";
                this.group = new THREE.Group();
            }
            init(scene) {
                const geometry = new THREE.PlaneGeometry(2, 2);
                this.material = new THREE.ShaderMaterial({
                    uniforms: {
                        time: { value: 0 },
                        resolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
                        avgLow: { value: 0 },
                        avgMid: { value: 0 },
                        avgHigh: { value: 0 },
                    },
                    vertexShader: `
                        varying vec2 vUv;
                        void main() {
                            vUv = uv;
                            gl_Position = vec4(position, 1.0);
                        }
                    `,
                    fragmentShader: `
                        uniform vec2 resolution;
                        uniform float time;
                        uniform float avgLow;
                        uniform float avgMid;
                        uniform float avgHigh;
                        varying vec2 vUv;

                        float random (in vec2 _st) { return fract(sin(dot(_st.xy, vec2(12.9898,78.233))) * 43758.5453123); }

                        vec3 hsv2rgb(vec3 c) {
                            vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
                            vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
                            return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
                        }

                        void main() {
                            vec2 st = (vUv - 0.5);
                            st.x *= resolution.x / resolution.y;
                            
                            vec3 color = vec3(0.0);
                            vec3 bgColor = vec3(0.1, 0.05, 0.2) * (0.5 + avgLow * 1.5);
                            color += bgColor;
                            
                            for(float i = 0.0; i < 7.0; i++) {
                                float time_offset = i * 1.3;
                                float angle_speed = 0.3 + i * 0.05;
                                float beam_phase = sin(time * angle_speed + time_offset) * 1.2;
                                
                                vec2 light_pos = vec2(beam_phase, -1.2);
                                vec2 dir_to_pixel = st - light_pos;
                                float dist_to_light = length(dir_to_pixel);
                                dir_to_pixel = normalize(dir_to_pixel);
                                
                                float intensity = pow(0.15 / dist_to_light, 1.2);
                                
                                vec2 light_up_dir = normalize(vec2(sin(time*0.2 + i*2.0)*0.5, 1.0)); 
                                float ray = pow(max(0.0, dot(dir_to_pixel, light_up_dir)), 2.5);
                                
                                intensity *= ray * (0.5 + avgLow * 2.5);
                                
                                float hue = fract(time * 0.1 + i / 7.0);
                                float saturation = 0.6 + avgMid * 0.4;
                                vec3 beam_color = hsv2rgb(vec3(hue, saturation, 1.0));
                                
                                color += intensity * beam_color;
                            }

                            float smoke = random(st * 2.0 + time * 0.1) * 0.15;
                            color += smoke * vec3(0.5, 0.5, 0.7);

                            float sparkle = pow(random(st * (1.0 + avgHigh * 20.0)), 20.0);
                            color += sparkle * (1.0 + avgHigh * 2.0);

                            color *= smoothstep(1.5, 0.4, length(st));

                            gl_FragColor = vec4(color, 1.0);
                        }
                    `
                });
                const mesh = new THREE.Mesh(geometry, this.material);
                this.group.add(mesh);
                scene.add(this.group);
                window.addEventListener('resize', () => {
                    this.material.uniforms.resolution.value.set(window.innerWidth, window.innerHeight);
                });
            }
            update(dataArray, audioFeatures) {
                this.material.uniforms.time.value = performance.now() * 0.001;
                this.material.uniforms.avgLow.value = audioFeatures.avgLow;
                this.material.uniforms.avgMid.value = audioFeatures.avgMid;
                this.material.uniforms.avgHigh.value = audioFeatures.avgHigh;
            }
        }

        class VisGrasshopper {
            constructor() {
                this.name = "Grasshopper";
                this.group = new THREE.Group();
            }
            init(scene) {
                const geometry = new THREE.PlaneGeometry(2, 2);
                this.material = new THREE.ShaderMaterial({
                    uniforms: {
                        time: { value: 0 },
                        resolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
                        avgLow: { value: 0 },
                        avgMid: { value: 0 },
                        avgHigh: { value: 0 },
                    },
                    vertexShader: `
                        varying vec2 vUv;
                        void main() {
                            vUv = uv;
                            gl_Position = vec4(position, 1.0);
                        }
                    `,
                    fragmentShader: `
                        uniform vec2 resolution;
                        uniform float time;
                        uniform float avgLow;
                        uniform float avgMid;
                        uniform float avgHigh;
                        varying vec2 vUv;

                        float random (in vec2 _st) { return fract(sin(dot(_st.xy, vec2(12.9898,78.233))) * 43758.5453123); }

                        float noise (in vec2 _st) {
                            vec2 i = floor(_st);
                            vec2 f = fract(_st);
                            float a = random(i);
                            float b = random(i + vec2(1.0, 0.0));
                            float c = random(i + vec2(0.0, 1.0));
                            float d = random(i + vec2(1.0, 1.0));
                            vec2 u = f * f * (3.0 - 2.0 * f);
                            return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.y * u.x;
                        }

                        #define NUM_OCTAVES 6
                        float fbm ( in vec2 _st) {
                            float v = 0.0;
                            float a = 0.5;
                            vec2 shift = vec2(100.0);
                            mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.50));
                            for (int i = 0; i < NUM_OCTAVES; ++i) {
                                v += a * noise(_st);
                                _st = rot * _st * 2.0 + shift;
                                a *= 0.5;
                            }
                            return v;
                        }

                        void main() {
                            vec2 st = vUv * 5.0;
                            
                            vec2 wind_uv = vUv * vec2(2.0, 0.5) + vec2(time * 0.2, time * 0.1);
                            float wind_pattern = noise(wind_uv) - 0.5;
                            
                            float wind_strength = 0.2 + avgLow * 0.5;
                            
                            st.x += wind_pattern * wind_strength;
                            
                            float pattern = fbm(st);
                            
                            vec3 grass_dark = vec3(0.1, 0.3, 0.05);
                            vec3 grass_light = vec3(0.4, 0.8, 0.2);
                            vec3 grass_dry = vec3(0.6, 0.5, 0.1);

                            vec3 color = mix(grass_dark, grass_light, smoothstep(0.4, 0.6, pattern));
                            color = mix(color, grass_dry, smoothstep(0.6, 0.65, pattern));

                            color.g += avgMid * 0.2;
                            color.r += avgMid * 0.1;

                            float sparkle = pow(noise(st * 20.0 + time), 10.0) * avgHigh * 1.5;
                            color += vec3(0.8, 1.0, 0.7) * sparkle;
                            
                            color *= smoothstep(1.0, 0.3, length(vUv - 0.5));

                            gl_FragColor = vec4(color, 1.0);
                        }
                    `
                });
                const mesh = new THREE.Mesh(geometry, this.material);
                this.group.add(mesh);
                scene.add(this.group);
                window.addEventListener('resize', () => {
                    this.material.uniforms.resolution.value.set(window.innerWidth, window.innerHeight);
                });
            }
            update(dataArray, audioFeatures) {
                this.material.uniforms.time.value = performance.now() * 0.001;
                this.material.uniforms.avgLow.value = audioFeatures.avgLow;
                this.material.uniforms.avgMid.value = audioFeatures.avgMid;
                this.material.uniforms.avgHigh.value = audioFeatures.avgHigh;
            }
        }

        class VisMatrix {
            constructor() {
                this.name = "Matrix";
                this.group = new THREE.Group();
                this.canvas = null;
                this.ctx = null;
                this.drops = [];
                this.columns = 0;
                this.fontSize = 16;
                this.animationInterval = null;
                this.characters = 'アァカサタナハマヤャラワガザダバパイィキシチニヒミリヰギジヂビピウゥクスツヌフムユュルグズブプエェケセテネヘメレヱゲゼデベペオォコソトノホモヨョロヲゴゾドボポヴッンABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
                this.currentAudioFeatures = { avgLow: 0, avgMid: 0, avgHigh: 0 };
            }

            init() {
                this.canvas = document.getElementById('matrixCanvas');
                if (!this.canvas) return;
                this.ctx = this.canvas.getContext('2d');
                this.setupCanvas(); 
                window.addEventListener('resize', () => {
                    if (this.canvas.style.display === 'block') {
                        this.setupCanvas();
                    }
                }, false);
            }

            setupCanvas() {
                if (!this.canvas) return;
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
                this.columns = Math.floor(this.canvas.width / this.fontSize);
                this.drops = [];
                for (let x = 0; x < this.columns; x++) {
                    this.drops[x] = 1 + Math.random() * 100; 
                }
            }

            draw() {
                if (!this.ctx) return;
                
                this.ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                this.ctx.font = this.fontSize + 'px monospace';

                for (let i = 0; i < this.drops.length; i++) {
                    const text = this.characters.charAt(Math.floor(Math.random() * this.characters.length));
                    const x = i * this.fontSize;
                    const y = this.drops[i] * this.fontSize;
                    
                    const midPulseGreen = 150 + Math.floor(this.currentAudioFeatures.avgMid * 105);
                    const glowAmount = this.currentAudioFeatures.avgLow * 20;
                    
                    this.ctx.fillStyle = `rgb(0, ${midPulseGreen}, 0)`;
                    this.ctx.shadowBlur = glowAmount;
                    this.ctx.shadowColor = 'rgba(100, 255, 100, 0.5)';
                    
                    this.ctx.fillText(text, x, y);

                    const shineAlpha = this.currentAudioFeatures.avgHigh * 0.8; 
                    if (shineAlpha > 0.1) {
                        this.ctx.fillStyle = `rgba(255, 255, 255, ${shineAlpha})`;
                        this.ctx.shadowBlur = 5; 
                        this.ctx.shadowColor = 'rgba(255, 255, 255, 0.7)';
                        this.ctx.fillText(text, x, y);
                    }

                    this.ctx.shadowBlur = 0;

                    if (y > this.canvas.height && Math.random() > 0.975) {
                        this.drops[i] = 0;
                    }

                    this.drops[i]++;
                }
            }

            start() {
                if (this.animationInterval) return;
                this.setupCanvas();
                this.canvas.style.display = 'block';
                this.animationInterval = setInterval(() => this.draw(), 33);
            }

            stop() {
                if (!this.animationInterval) return;
                this.canvas.style.display = 'none';
                clearInterval(this.animationInterval);
                this.animationInterval = null;
            }
            
            update(dataArray, audioFeatures) {
                this.currentAudioFeatures = audioFeatures;
            }
        }

        function resumeAudioContext() {
            if (audioContext && audioContext.state === 'suspended' && !audioContextResumed) {
                audioContext.resume().then(() => {
                    audioContextResumed = true;
                }).catch(err => {
                    console.log('AudioContext resume error:', err);
                });
            }
        }

        function goHome() {
            if (document.fullscreenElement || document.webkitFullscreenElement || document.mozFullscreenElement || document.msFullscreenElement) {
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                } else if (document.webkitExitFullscreen) {
                    document.webkitExitFullscreen();
                } else if (document.mozCancelFullScreen) {
                    document.mozCancelFullScreen();
                } else if (document.msExitFullscreen) {
                    document.msExitFullscreen();
                }
            }
            
            audio.pause();
            
            if (visualizations[currentVisualizationIndex].name === "Matrix") {
                visualizations[currentVisualizationIndex].stop();
            }
            renderer.domElement.style.display = 'block';

            visualizations.forEach(vis => vis.group.visible = false);
            audioControlsContainer.classList.remove('visible');
            visSwitcher.classList.remove('visible');
            topBar.classList.remove('visible');
            playlistPanel.classList.remove('visible');

            initialPrompt.style.display = 'flex';
            footerElement.style.display = 'block';
            backgroundGroup.visible = true;
            
            updateHomepageUI();
        }

        function resumeSession() {
            initialPrompt.style.display = 'none';
            footerElement.style.display = 'none';
            backgroundGroup.visible = false;

            const currentVis = visualizations[currentVisualizationIndex];
            if (currentVis.name === "Matrix") {
                renderer.domElement.style.display = 'none';
                currentVis.start();
            } else {
                renderer.domElement.style.display = 'block';
                currentVis.group.visible = true;
            }

            audioControlsContainer.classList.add('visible');
            visSwitcher.classList.add('visible');
            topBar.classList.add('visible');
            if(currentTrackIndex !== -1) {
                audio.play().catch(err => console.log('Play error:', err));
            }
        }

        function updateHomepageUI() {
            if (playlist.length > 0) {
                resumeBtn.style.display = 'block';
            } else {
                resumeBtn.style.display = 'none';
            }
        }

        function switchVisualization(direction) {
            const oldIndex = currentVisualizationIndex;
            const oldVis = visualizations[oldIndex];
            
            currentVisualizationIndex = (currentVisualizationIndex + direction + visualizations.length) % visualizations.length;
            const newVis = visualizations[currentVisualizationIndex];

            if (oldVis.name === "Matrix") {
                oldVis.stop();
                renderer.domElement.style.display = 'block';
            } else {
                oldVis.group.visible = false;
            }

            if (newVis.name === "Matrix") {
                newVis.start();
                renderer.domElement.style.display = 'none';
            } else {
                newVis.group.visible = true;
            }
            
            visNameElement.textContent = newVis.name;
        }

        function setupAudioContext() {
            if (audioContext) return;
            const AudioContextClass = window.AudioContext || window.webkitAudioContext;
            audioContext = new AudioContextClass();
            const source = audioContext.createMediaElementSource(audio);
            analyser = audioContext.createAnalyser();
            analyser.fftSize = 2048;
            analyser.minDecibels = -90;
            analyser.maxDecibels = -10;
            analyser.smoothingTimeConstant = 0.85;
            dataArray = new Uint8Array(analyser.frequencyBinCount);
            source.connect(analyser);
            analyser.connect(audioContext.destination);
        }

        function onFileSelect(event) {
            const newFiles = Array.from(event.target.files);
            if (newFiles.length === 0) return;

            const wasPlaylistEmpty = playlist.length === 0;
            const isFromHomepage = initialPrompt.style.display !== 'none';

            newFiles.forEach(file => {
                playlist.push({
                    name: file.name,
                    url: URL.createObjectURL(file)
                });
            });

            renderPlaylist();

            if (isFromHomepage) {
                resumeSession();
                playlistPanel.classList.add('visible');
                if (wasPlaylistEmpty) {
                    playTrack(0);
                }
            }
            
            if (!controls) {
                controls = new THREE.OrbitControls(camera, renderer.domElement);
                controls.enableDamping = true;
                controls.dampingFactor = 0.05;
            }
            if (!analyser) setupAudioContext();
            
            fileInput.value = '';
        }

        function playTrack(index) {
            if (index < 0 || index >= playlist.length) return;
            currentTrackIndex = index;
            audio.src = playlist[index].url;
            audio.play().catch(err => {
                console.log('Play error:', err);
            });
            songTitleElement.textContent = playlist[index].name;
            renderPlaylist();
        }

        function playNextTrack() {
            if (playlist.length === 0) return;
            let nextIndex = currentTrackIndex + 1;
            if (nextIndex >= playlist.length) {
                nextIndex = 0;
            }
            playTrack(nextIndex);
        }

        function playPreviousTrack() {
            if (playlist.length === 0) return;
            let prevIndex = currentTrackIndex - 1;
            if (prevIndex < 0) {
                prevIndex = playlist.length - 1;
            }
            playTrack(prevIndex);
        }
        
        function removeTrack(index) {
            if (index < 0 || index >= playlist.length) return;

            const isCurrentlyPlaying = (index === currentTrackIndex);
            playlist.splice(index, 1);

            if (isCurrentlyPlaying) {
                audio.pause();
                audio.src = '';
                songTitleElement.textContent = 'Select a track';
                currentTrackIndex = -1; 
            } 
            else if (index < currentTrackIndex) {
                currentTrackIndex--; 
            }

            if (playlist.length === 0) {
                goHome();
            } else {
                renderPlaylist();
            }
        }

        function renderPlaylist() {
            playlistList.innerHTML = '';
            playlist.forEach((track, index) => {
                const li = document.createElement('li');
                
                const trackName = document.createElement('span');
                trackName.textContent = track.name;
                li.appendChild(trackName);

                const removeBtn = document.createElement('button');
                removeBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg>`;
                removeBtn.className = 'remove-track-btn';
                removeBtn.title = 'Remove track';
                
                removeBtn.addEventListener('click', (event) => {
                    event.stopPropagation();
                    removeTrack(index);
                });
                li.appendChild(removeBtn);

                if (index === currentTrackIndex) {
                    li.classList.add('playing');
                }
                li.addEventListener('click', () => playTrack(index));
                playlistList.appendChild(li);
            });
        }
        
        function toggleFullscreen() {
            if (!document.fullscreenElement && !document.webkitFullscreenElement && !document.mozFullscreenElement && !document.msFullscreenElement) {
                const elem = document.documentElement;
                if (elem.requestFullscreen) {
                    elem.requestFullscreen().catch(err => console.error(`Fullscreen error: ${err.message}`));
                } else if (elem.webkitRequestFullscreen) {
                    elem.webkitRequestFullscreen();
                } else if (elem.mozRequestFullScreen) {
                    elem.mozRequestFullScreen();
                } else if (elem.msRequestFullscreen) {
                    elem.msRequestFullscreen();
                }
            } else {
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                } else if (document.webkitExitFullscreen) {
                    document.webkitExitFullscreen();
                } else if (document.mozCancelFullScreen) {
                    document.mozCancelFullScreen();
                } else if (document.msExitFullscreen) {
                    document.msExitFullscreen();
                }
            }
        }

        function showControls() {
            interactiveUIs.forEach(el => el.classList.add('visible'));
        }
        
        function hideControls() {
            interactiveUIs.forEach(el => el.classList.remove('visible'));
        }

        function onFullscreenChange() {
            const isFullscreen = !!(document.fullscreenElement || document.webkitFullscreenElement || document.mozFullscreenElement || document.msFullscreenElement);
            document.body.classList.toggle('fullscreen-active', isFullscreen);

            enterFullscreenIcon.classList.toggle('hidden', isFullscreen);
            exitFullscreenIcon.classList.toggle('hidden', !isFullscreen);

            if (isFullscreen) {
                uiHideTimeout = setTimeout(hideControls, 3000);
                window.addEventListener('mousemove', handleFullscreenActivity);
                window.addEventListener('touchstart', handleFullscreenActivity);
            } else {
                clearTimeout(uiHideTimeout);
                showControls();
                window.removeEventListener('mousemove', handleFullscreenActivity);
                window.removeEventListener('touchstart', handleFullscreenActivity);
            }
        }

        function handleFullscreenActivity() {
            if (document.fullscreenElement || document.webkitFullscreenElement || document.mozFullscreenElement || document.msFullscreenElement) {
                showControls();
                clearTimeout(uiHideTimeout);
                uiHideTimeout = setTimeout(hideControls, 3000);
            }
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            if (controls) controls.update();

            if (backgroundGroup.visible) {
                backgroundGroup.children[0].material.uniforms.time.value = performance.now() * 0.001;
            }
            
            if (analyser) {
                analyser.getByteFrequencyData(dataArray);
                const bufferLength = analyser.frequencyBinCount;
                
                const lowEnd = Math.floor(bufferLength * 0.1);
                const midEnd = Math.floor(bufferLength * 0.4);
                let lowSum = 0, midSum = 0, highSum = 0;
                for (let i = 0; i < lowEnd; i++) lowSum += dataArray[i];
                for (let i = lowEnd; i < midEnd; i++) midSum += dataArray[i];
                for (let i = midEnd; i < bufferLength; i++) highSum += dataArray[i];

                const audioFeatures = {
                    avgLow: (lowSum / lowEnd) / 255,
                    avgMid: (midSum / (midEnd - lowEnd)) / 255,
                    avgHigh: (highSum / (bufferLength - midEnd)) / 255,
                    avgVolume: (lowSum + midSum + highSum) / bufferLength
                };
                
                const currentVis = visualizations[currentVisualizationIndex];
                if (currentVis && (currentVis.group.visible || currentVis.name === "Matrix")) {
                     currentVis.update(dataArray, audioFeatures);
                }
            }

            renderer.render(scene, camera);
        }

        init();
        animate();
    </script>
</body>
</html>