<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>PULZR Audioverse</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000000;
            font-family: 'Poppins', sans-serif;
            color: #e5e7eb;
            touch-action: none;
        }
        canvas {
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 0;
        }
        #ui-container {
            position: relative;
            z-index: 1;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            pointer-events: none;
        }
        #initial-prompt, #file-input, #play-button, #visualization-switcher, .ui-button {
            pointer-events: auto;
        }
        #initial-prompt h1 {
            color: rgba(255, 255, 255, 0.85);
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.5), 0 0 35px rgba(255, 255, 255, 0.3);
        }
        #initial-prompt p {
             color: rgba(229, 231, 235, 0.75);
             text-shadow: 0 0 8px rgba(229, 231, 235, 0.2);
        }
        #audio-controls {
            position: absolute;
            bottom: 2rem;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
            border-radius: 0.75rem;
            padding: 0.5rem 1rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            opacity: 0;
            transition: opacity 0.5s ease-in-out;
            pointer-events: none;
            max-width: 90vw;
        }
        #audio-controls.visible {
            opacity: 1;
            pointer-events: auto;
        }
        #audio-controls audio {
            width: 250px;
            max-width: 50vw;
        }
        #top-bar {
            position: absolute;
            top: 1rem;
            left: 1rem;
            right: 1rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            opacity: 0;
            transition: opacity 0.5s ease-in-out;
            pointer-events: none;
            gap: 0.5rem;
        }
        #top-bar.visible {
            opacity: 1;
            pointer-events: auto;
        }
        #song-title {
            color: white;
            font-size: 0.9rem;
            font-weight: 500;
            background: rgba(0,0,0,0.3);
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            backdrop-filter: blur(10px);
            max-width: 40vw;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            flex-shrink: 1;
        }
        .ui-button {
            background: rgba(0,0,0,0.3);
            backdrop-filter: blur(10px);
            border-radius: 50%;
            cursor: pointer;
            width: 2.5rem;
            height: 2.5rem;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: background 0.2s;
            flex-shrink: 0;
        }
        .ui-button:hover, .ui-button:active {
            background: rgba(0,0,0,0.5);
        }
        body.fullscreen-active #home-btn {
            display: none;
        }
        #playlist-panel {
            position: absolute;
            top: 0;
            right: 0;
            width: 350px;
            max-width: 85vw;
            height: 100%;
            background: rgba(10, 10, 20, 0.95);
            backdrop-filter: blur(15px);
            transform: translateX(100%);
            transition: transform 0.4s ease-in-out;
            z-index: 20;
            display: flex;
            flex-direction: column;
        }
        #playlist-panel.visible {
            transform: translateX(0);
        }
        #playlist-header {
            padding: 1rem;
            border-bottom: 1px solid rgba(255,255,255,0.1);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        #playlist-header h2 {
            font-size: 1.2rem;
            font-weight: 600;
        }
        #playlist-list {
            list-style: none;
            padding: 0;
            margin: 0;
            flex-grow: 1;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
        }
        #playlist-list li {
            padding: 0.75rem 1rem;
            cursor: pointer;
            transition: background 0.2s;
            border-bottom: 1px solid rgba(255,255,255,0.05);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        #playlist-list li > span {
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            font-size: 0.9rem;
        }
        #playlist-list li:hover, #playlist-list li:active {
            background: rgba(255,255,255,0.1);
        }
        #playlist-list li.playing {
            background: rgba(99, 102, 241, 0.5);
            font-weight: 600;
        }
        .remove-track-btn {
            background: none;
            border: none;
            color: #9ca3af;
            cursor: pointer;
            padding: 0.25rem;
            border-radius: 50%;
            transition: color 0.2s, background 0.2s;
            flex-shrink: 0;
            margin-left: 1rem;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .remove-track-btn:hover, .remove-track-btn:active {
            color: #fca5a5;
            background: rgba(255, 255, 255, 0.1);
        }

        #visualization-switcher {
            position: absolute;
            bottom: 7rem;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            align-items: center;
            gap: 0.5rem;
            background: rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
            border-radius: 0.5rem;
            padding: 0.5rem 0.75rem;
            opacity: 0;
            transition: opacity 0.5s ease-in-out;
        }
        #visualization-switcher.visible {
            opacity: 1;
        }
        .arrow-btn {
            background: rgba(255,255,255,0.1);
            border: none;
            color: white;
            padding: 0.4rem;
            border-radius: 50%;
            cursor: pointer;
            transition: background 0.2s;
            width: 2rem;
            height: 2rem;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-shrink: 0;
        }
        .arrow-btn:hover, .arrow-btn:active {
            background: rgba(255,255,255,0.2);
        }
        #vis-name {
            color: white;
            font-weight: 500;
            width: 120px;
            text-align: center;
            font-size: 0.9rem;
        }
        
        #footer {
            font-size: 0.8rem;
        }

        @media (max-width: 640px) {
            #initial-prompt h1, #initial-prompt h2 {
                font-size: 2rem;
            }
            #initial-prompt p {
                font-size: 0.9rem;
            }
            #song-title {
                font-size: 0.8rem;
                padding: 0.4rem 0.8rem;
                max-width: 35vw;
            }
            .ui-button {
                width: 2.2rem;
                height: 2.2rem;
            }
            .ui-button svg {
                width: 18px;
                height: 18px;
            }
            #audio-controls audio {
                width: 180px;
            }
            #visualization-switcher {
                bottom: 6rem;
            }
            #vis-name {
                width: 100px;
                font-size: 0.85rem;
            }
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    <canvas id="matrixCanvas" style="display: none;"></canvas>

    <div id="ui-container">
        <div id="initial-prompt" class="flex flex-col items-center gap-4 p-8">
              <h1 class="text-4xl md:text-6xl font-bold text-white tracking-tighter">P U L Z R</h1>
              <h2 class="text-4xl md:text-6xl font-bold text-white tracking-tighter">Interactive Audio Visualization.</h2>
              <p class="text-gray-300 max-w-md mt-2">Upload and play your favorite audio playlist to generate a unique visual universe.</p>
              <div class="mt-6 flex gap-4">
                  <label for="file-input" class="cursor-pointer bg-indigo-600 hover:bg-indigo-500 active:bg-indigo-700 text-white font-bold py-3 px-6 rounded-lg transition-transform duration-200 hover:scale-105 active:scale-95 shadow-lg">
                      Upload Audio
                  </label>
                  <button id="resume-btn" class="hidden cursor-pointer bg-gray-600 hover:bg-gray-500 active:bg-gray-700 text-white font-bold py-3 px-6 rounded-lg transition-transform duration-200 hover:scale-105 active:scale-95 shadow-lg">
                      Resume Session
                  </button>
              </div>
              <input type="file" id="file-input" class="hidden" multiple accept="audio/*">
        </div>
    </div>
    
    <div id="top-bar" class="pointer-events-none">
        <button id="home-btn" class="ui-button" title="Back to Home">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"/><polyline points="9 22 9 12 15 12 15 22"/></svg>
        </button>
        <div id="song-title"></div>
        <div class="flex items-center gap-2">
            <button id="fullscreen-btn" class="ui-button" title="Toggle Fullscreen">
                <svg id="enter-fullscreen-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"/></svg>
                <svg id="exit-fullscreen-icon" class="hidden" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M8 3v3a2 2 0 0 1-2 2H3m18 0h-3a2 2 0 0 1-2-2V3m0 18v-3a2 2 0 0 1 2-2h3M3 16h3a2 2 0 0 1 2 2v3"/></svg>
            </button>
            <button id="playlist-btn" class="ui-button" title="Toggle Playlist">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="8" y1="6" x2="21" y2="6"/><line x1="8" y1="12" x2="21" y2="12"/><line x1="8" y1="18" x2="21" y2="18"/><line x1="3" y1="6" x2="3.01" y2="6"/><line x1="3" y1="12" x2="3.01" y2="12"/><line x1="3" y1="18" x2="3.01" y2="18"/></svg>
            </button>
        </div>
    </div>

    <div id="playlist-panel">
        <div id="playlist-header">
            <h2>Playlist</h2>
            <div class="flex items-center gap-2">
                <label for="file-input" class="arrow-btn" title="Add Tracks">
                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="12" y1="5" x2="12" y2="19"/><line x1="5" y1="12" x2="19" y2="12"/></svg>
                </label>
                <button id="close-playlist-btn" class="arrow-btn" title="Close Playlist">
                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg>
                </button>
            </div>
        </div>
        <ul id="playlist-list"></ul>
    </div>

    <div id="audio-controls">
        <button id="prev-track-btn" class="arrow-btn" title="Previous Track">
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="11 19 2 12 11 5 11 19"/><polygon points="22 19 13 12 22 5 22 19"/></svg>
        </button>
        <audio id="audio" controls></audio>
        <button id="next-track-btn" class="arrow-btn" title="Next Track">
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="13 19 22 12 13 5 13 19"/><polygon points="2 19 11 12 2 5 2 19"/></svg>
        </button>
    </div>
    
    <div id="visualization-switcher">
        <button id="prev-vis" class="arrow-btn">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 18l-6-6 6-6"/></svg>
        </button>
        <div id="vis-name">Particle Sphere</div>
        <button id="next-vis" class="arrow-btn">
             <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9 18l6-6-6-6"/></svg>
        </button>
    </div>
    
    <div id="footer" class="absolute bottom-4 w-full text-center text-white text-sm pointer-events-none z-10">
        &copy; Adiyat Coto 2025
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Import OrbitControls - compatible with Safari
        (function() {
            THREE.OrbitControls = function(object, domElement) {
                this.object = object;
                this.domElement = (domElement !== undefined) ? domElement : document;
                this.enabled = true;
                this.target = new THREE.Vector3();
                this.minDistance = 0;
                this.maxDistance = Infinity;
                this.minZoom = 0;
                this.maxDistance = Infinity;
                this.minPolarAngle = 0;
                this.maxPolarAngle = Math.PI;
                this.minAzimuthAngle = -Infinity;
                this.maxAzimuthAngle = Infinity;
                this.enableDamping = false;
                this.dampingFactor = 0.25;
                this.enableZoom = true;
                this.zoomSpeed = 1.0;
                this.enableRotate = true;
                this.rotateSpeed = 1.0;
                this.enablePan = true;
                this.keyPanSpeed = 7.0;
                this.autoRotate = false;
                this.autoRotateSpeed = 2.0;
                this.enableKeys = true;
                this.keys = {LEFT: 37, UP: 38, RIGHT: 39, BOTTOM: 40};
                this.mouseButtons = {ORBIT: THREE.MOUSE.LEFT, ZOOM: THREE.MOUSE.MIDDLE, PAN: THREE.MOUSE.RIGHT};
                this.target0 = this.target.clone();
                this.position0 = this.object.position.clone();
                this.zoom0 = this.object.zoom;
                
                var scope = this;
                var rotateStart = new THREE.Vector2();
                var rotateEnd = new THREE.Vector2();
                var rotateDelta = new THREE.Vector2();
                var panStart = new THREE.Vector2();
                var panEnd = new THREE.Vector2();
                var panDelta = new THREE.Vector2();
                var dollyStart = new THREE.Vector2();
                var dollyEnd = new THREE.Vector2();
                var dollyDelta = new THREE.Vector2();
                var STATE = {NONE: -1, ROTATE: 0, DOLLY: 1, PAN: 2, TOUCH_ROTATE: 3, TOUCH_DOLLY: 4, TOUCH_PAN: 5};
                var state = STATE.NONE;
                var EPS = 0.000001;
                var spherical = new THREE.Spherical();
                var sphericalDelta = new THREE.Spherical();
                var scale = 1;
                var panOffset = new THREE.Vector3();
                var zoomChanged = false;
                var rotateSpeed = 1.0;

                this.update = function() {
                    var offset = new THREE.Vector3();
                    var quat = new THREE.Quaternion().setFromUnitVectors(object.up, new THREE.Vector3(0, 1, 0));
                    var quatInverse = quat.clone().invert();
                    var lastPosition = new THREE.Vector3();
                    var lastQuaternion = new THREE.Quaternion();
                    return function update() {
                        var position = scope.object.position;
                        offset.copy(position).sub(scope.target);
                        offset.applyQuaternion(quat);
                        spherical.setFromVector3(offset);
                        if (scope.autoRotate && state === STATE.NONE) {
                            rotateLeft(getAutoRotationAngle());
                        }
                        spherical.theta += sphericalDelta.theta;
                        spherical.phi += sphericalDelta.phi;
                        spherical.theta = Math.max(scope.minAzimuthAngle, Math.min(scope.maxAzimuthAngle, spherical.theta));
                        spherical.phi = Math.max(scope.minPolarAngle, Math.min(scope.maxPolarAngle, spherical.phi));
                        spherical.makeSafe();
                        spherical.radius *= scale;
                        spherical.radius = Math.max(scope.minDistance, Math.min(scope.maxDistance, spherical.radius));
                        scope.target.add(panOffset);
                        offset.setFromSpherical(spherical);
                        offset.applyQuaternion(quatInverse);
                        position.copy(scope.target).add(offset);
                        scope.object.lookAt(scope.target);
                        if (scope.enableDamping === true) {
                            sphericalDelta.theta *= (1 - scope.dampingFactor);
                            sphericalDelta.phi *= (1 - scope.dampingFactor);
                            panOffset.multiplyScalar(1 - scope.dampingFactor);
                        } else {
                            sphericalDelta.set(0, 0, 0);
                            panOffset.set(0, 0, 0);
                        }
                        scale = 1;
                        if (zoomChanged || lastPosition.distanceToSquared(scope.object.position) > EPS || 8 * (1 - lastQuaternion.dot(scope.object.quaternion)) > EPS) {
                            lastPosition.copy(scope.object.position);
                            lastQuaternion.copy(scope.object.quaternion);
                            zoomChanged = false;
                            return true;
                        }
                        return false;
                    };
                }();

                function getAutoRotationAngle() {
                    return 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;
                }

                function rotateLeft(angle) {
                    sphericalDelta.theta -= angle;
                }

                function rotateUp(angle) {
                    sphericalDelta.phi -= angle;
                }

                var panLeft = function() {
                    var v = new THREE.Vector3();
                    return function panLeft(distance, objectMatrix) {
                        v.setFromMatrixColumn(objectMatrix, 0);
                        v.multiplyScalar(-distance);
                        panOffset.add(v);
                    };
                }();

                var panUp = function() {
                    var v = new THREE.Vector3();
                    return function panUp(distance, objectMatrix) {
                        v.setFromMatrixColumn(objectMatrix, 1);
                        v.multiplyScalar(distance);
                        panOffset.add(v);
                    };
                }();

                this.dispose = function() {
                    scope.domElement.removeEventListener('contextmenu', onContextMenu, false);
                    scope.domElement.removeEventListener('mousedown', onMouseDown, false);
                    scope.domElement.removeEventListener('wheel', onMouseWheel, false);
                    scope.domElement.removeEventListener('touchstart', onTouchStart, false);
                    scope.domElement.removeEventListener('touchend', onTouchEnd, false);
                    scope.domElement.removeEventListener('touchmove', onTouchMove, false);
                    document.removeEventListener('mousemove', onMouseMove, false);
                    document.removeEventListener('mouseup', onMouseUp, false);
                    window.removeEventListener('keydown', onKeyDown, false);
                };

                function onMouseDown(event) {
                    if (scope.enabled === false) return;
                    event.preventDefault();
                    if (event.button === scope.mouseButtons.ORBIT) {
                        if (scope.enableRotate === false) return;
                        rotateStart.set(event.clientX, event.clientY);
                        state = STATE.ROTATE;
                    }
                    if (state !== STATE.NONE) {
                        document.addEventListener('mousemove', onMouseMove, false);
                        document.addEventListener('mouseup', onMouseUp, false);
                    }
                }

                function onMouseMove(event) {
                    if (scope.enabled === false) return;
                    event.preventDefault();
                    if (state === STATE.ROTATE) {
                        if (scope.enableRotate === false) return;
                        rotateEnd.set(event.clientX, event.clientY);
                        rotateDelta.subVectors(rotateEnd, rotateStart);
                        var element = scope.domElement === document ? scope.domElement.body : scope.domElement;
                        rotateLeft(2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed);
                        rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed);
                        rotateStart.copy(rotateEnd);
                        scope.update();
                    }
                }

                function onMouseUp(event) {
                    if (scope.enabled === false) return;
                    document.removeEventListener('mousemove', onMouseMove, false);
                    document.removeEventListener('mouseup', onMouseUp, false);
                    state = STATE.NONE;
                }

                function onMouseWheel(event) {
                    if (scope.enabled === false || scope.enableZoom === false || (state !== STATE.NONE && state !== STATE.ROTATE)) return;
                    event.preventDefault();
                    event.stopPropagation();
                    if (event.deltaY < 0) {
                        scale /= Math.pow(0.95, scope.zoomSpeed);
                    } else if (event.deltaY > 0) {
                        scale *= Math.pow(0.95, scope.zoomSpeed);
                    }
                    scope.update();
                }

                function onTouchStart(event) {
                    if (scope.enabled === false) return;
                    switch (event.touches.length) {
                        case 1:
                            if (scope.enableRotate === false) return;
                            rotateStart.set(event.touches[0].pageX, event.touches[0].pageY);
                            state = STATE.TOUCH_ROTATE;
                            break;
                        case 2:
                            if (scope.enableZoom === false) return;
                            var dx = event.touches[0].pageX - event.touches[1].pageX;
                            var dy = event.touches[0].pageY - event.touches[1].pageY;
                            var distance = Math.sqrt(dx * dx + dy * dy);
                            dollyStart.set(0, distance);
                            state = STATE.TOUCH_DOLLY;
                            break;
                        default:
                            state = STATE.NONE;
                    }
                }

                function onTouchMove(event) {
                    if (scope.enabled === false) return;
                    event.preventDefault();
                    event.stopPropagation();
                    switch (event.touches.length) {
                        case 1:
                            if (scope.enableRotate === false) return;
                            if (state !== STATE.TOUCH_ROTATE) return;
                            rotateEnd.set(event.touches[0].pageX, event.touches[0].pageY);
                            rotateDelta.subVectors(rotateEnd, rotateStart);
                            var element = scope.domElement === document ? scope.domElement.body : scope.domElement;
                            rotateLeft(2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed);
                            rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed);
                            rotateStart.copy(rotateEnd);
                            scope.update();
                            break;
                        case 2:
                            if (scope.enableZoom === false) return;
                            if (state !== STATE.TOUCH_DOLLY) return;
                            var dx = event.touches[0].pageX - event.touches[1].pageX;
                            var dy = event.touches[0].pageY - event.touches[1].pageY;
                            var distance = Math.sqrt(dx * dx + dy * dy);
                            dollyEnd.set(0, distance);
                            dollyDelta.subVectors(dollyEnd, dollyStart);
                            if (dollyDelta.y > 0) {
                                scale /= Math.pow(0.95, scope.zoomSpeed);
                            } else if (dollyDelta.y < 0) {
                                scale *= Math.pow(0.95, scope.zoomSpeed);
                            }
                            dollyStart.copy(dollyEnd);
                            scope.update();
                            break;
                        default:
                            state = STATE.NONE;
                    }
                }

                function onTouchEnd(event) {
                    if (scope.enabled === false) return;
                    state = STATE.NONE;
                }

                function onContextMenu(event) {
                    event.preventDefault();
                }

                function onKeyDown(event) {
                    if (scope.enabled === false || scope.enableKeys === false || scope.enablePan === false) return;
                    // Handle key events if needed
                }

                this.domElement.addEventListener('contextmenu', onContextMenu, false);
                this.domElement.addEventListener('mousedown', onMouseDown, false);
                this.domElement.addEventListener('wheel', onMouseWheel, false);
                this.domElement.addEventListener('touchstart', onTouchStart, false);
                this.domElement.addEventListener('touchend', onTouchEnd, false);
                this.domElement.addEventListener('touchmove', onTouchMove, false);
                this.update();
            };
        })();

        let scene, camera, renderer, controls, analyser, dataArray, audioContext;
        let visualizations = [];
        let currentVisualizationIndex = 0;
        let backgroundGroup;
        let playlist = [];
        let currentTrackIndex = -1;
        let uiHideTimeout;
        let audioContextResumed = false;

        const fileInput = document.getElementById('file-input');
        const audio = document.getElementById('audio');
        const initialPrompt = document.getElementById('initial-prompt');
        const resumeBtn = document.getElementById('resume-btn');
        const audioControlsContainer = document.getElementById('audio-controls');
        const canvasContainer = document.getElementById('canvas-container');
        const topBar = document.getElementById('top-bar');
        const songTitleElement = document.getElementById('song-title');
        const visSwitcher = document.getElementById('visualization-switcher');
        const prevVisBtn = document.getElementById('prev-vis');
        const nextVisBtn = document.getElementById('next-vis');
        const visNameElement = document.getElementById('vis-name');
        const footerElement = document.getElementById('footer');
        const homeBtn = document.getElementById('home-btn');
        const playlistBtn = document.getElementById('playlist-btn');
        const playlistPanel = document.getElementById('playlist-panel');
        const playlistList = document.getElementById('playlist-list');
        const closePlaylistBtn = document.getElementById('close-playlist-btn');
        const prevTrackBtn = document.getElementById('prev-track-btn');
        const nextTrackBtn = document.getElementById('next-track-btn');
        const fullscreenBtn = document.getElementById('fullscreen-btn');
        const enterFullscreenIcon = document.getElementById('enter-fullscreen-icon');
        const exitFullscreenIcon = document.getElementById('exit-fullscreen-icon');
        const interactiveUIs = [topBar, audioControlsContainer, visSwitcher];

        function createGlowTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 128; canvas.height = 128;
            const context = canvas.getContext('2d');
            const gradient = context.createRadialGradient(64, 64, 0, 64, 64, 64);
            gradient.addColorStop(0, 'rgba(255,255,255,1)');
            gradient.addColorStop(0.2, 'rgba(255,255,255,0.8)');
            gradient.addColorStop(0.5, 'rgba(255,255,255,0.3)');
            gradient.addColorStop(1, 'rgba(255,255,255,0)');
            context.fillStyle = gradient;
            context.fillRect(0, 0, 128, 128);
            return new THREE.CanvasTexture(canvas);
        }

        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 8;
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            canvasContainer.appendChild(renderer.domElement);
            
            backgroundGroup = new THREE.Group();
            const bgGeometry = new THREE.PlaneGeometry(30, 30, 100, 100);
            const bgMaterial = new THREE.ShaderMaterial({
                uniforms: { time: { value: 0 } },
                vertexShader: `
                    uniform float time; varying vec2 vUv;
                    void main() {
                        vUv = uv; vec3 pos = position;
                        float wave1 = sin(pos.x * 2.0 + time * 0.4) * 0.5;
                        float wave2 = sin(pos.y * 3.0 + time * 0.3) * 0.2;
                        float twist = cos(pos.y * 1.0 + time * 0.5) * 0.3;
                        pos.y += wave1 + wave2;
                        pos.z += cos(pos.x * 1.5 + time * 0.2) * 0.3 + twist;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform float time; varying vec2 vUv;
                    float random(vec2 st) { return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123); }
                    float noise(vec2 st) {
                        vec2 i = floor(st); vec2 f = fract(st);
                        float a = random(i); float b = random(i + vec2(1.0, 0.0));
                        float c = random(i + vec2(0.0, 1.0)); float d = random(i + vec2(1.0, 1.0));
                        vec2 u = f * f * (3.0 - 2.0 * f);
                        return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.y * u.x;
                    }
                    void main() {
                        vec3 color1 = vec3(0.8, 0.1, 0.5); vec3 color2 = vec3(0.1, 0.2, 0.9); vec3 color3 = vec3(0.2, 0.8, 0.7);
                        float n = noise(vUv * 3.0 + vec2(0.0, time * -0.1));
                        vec3 mixed = mix(color1, color2, n);
                        vec3 finalColor = mix(mixed, color3, vUv.y * 0.8);
                        float veins = smoothstep(0.7, 0.75, noise(vUv * 8.0 + vec2(0.0, time * -0.2)));
                        finalColor += veins * 0.3;
                        gl_FragColor = vec4(finalColor, 1.0);
                    }
                `,
                side: THREE.DoubleSide
            });
            const bgMesh = new THREE.Mesh(bgGeometry, bgMaterial);
            bgMesh.rotation.x = -Math.PI / 3;
            backgroundGroup.add(bgMesh);
            scene.add(backgroundGroup);

            visualizations.push(new VisParticleSphere());
            visualizations.push(new VisDynamicTerrain());
            visualizations.push(new VisOscillator());
            visualizations.push(new VisFrequencyCanvas());
            visualizations.push(new VisLiquidMarble());
            visualizations.push(new VisStageLights());
            visualizations.push(new VisGrasshopper());
            visualizations.push(new VisMatrix());
            
            visualizations.forEach((vis) => {
                vis.init(scene);
                vis.group.visible = false;
            });
            visNameElement.textContent = visualizations[currentVisualizationIndex].name;

            window.addEventListener('resize', onWindowResize, false);
            fileInput.addEventListener('change', onFileSelect, false);
            homeBtn.addEventListener('click', goHome);
            resumeBtn.addEventListener('click', resumeSession);
            playlistBtn.addEventListener('click', () => playlistPanel.classList.add('visible'));
            closePlaylistBtn.addEventListener('click', () => playlistPanel.classList.remove('visible'));
            audio.addEventListener('ended', playNextTrack);
            audio.addEventListener('play', resumeAudioContext);
            prevVisBtn.addEventListener('click', () => switchVisualization(-1));
            nextVisBtn.addEventListener('click', () => switchVisualization(1));
            prevTrackBtn.addEventListener('click', playPreviousTrack);
            nextTrackBtn.addEventListener('click', playNextTrack);
            fullscreenBtn.addEventListener('click', toggleFullscreen);
            document.addEventListener('fullscreenchange', onFullscreenChange);
            document.addEventListener('webkitfullscreenchange', onFullscreenChange);
            document.addEventListener('mozfullscreenchange', onFullscreenChange);
            document.addEventListener('msfullscreenchange', onFullscreenChange);

            document.addEventListener('click', (event) => {
                if (playlistPanel.classList.contains('visible') && !playlistPanel.contains(event.target) && !playlistBtn.contains(event.target)) {
                    playlistPanel.classList.remove('visible');
                }
            });

            document.addEventListener('touchstart', (event) => {
                if (playlistPanel.classList.contains('visible') && !playlistPanel.contains(event.target) && !playlistBtn.contains(event.target)) {
                    playlistPanel.classList.remove('visible');
                }
            });
        }
        
        class VisParticleSphere{constructor(){this.name="Particle Sphere";this.group=new THREE.Group;this.originalPositions=null;this.satellites=[]}init(e){const t=new THREE.IcosahedronGeometry(2.5,64);t.setAttribute("color",new THREE.BufferAttribute(new Float32Array(3*t.attributes.position.count),3)),this.originalPositions=new Float32Array(t.attributes.position.array);const i=new THREE.PointsMaterial({size:.08,vertexColors:!0,map:createGlowTexture(),blending:THREE.AdditiveBlending,transparent:!0,depthWrite:!1});this.sphere=new THREE.Points(t,i),this.group.add(this.sphere);const s=new THREE.PointsMaterial({size:.1,color:65535,map:createGlowTexture(),blending:THREE.AdditiveBlending,transparent:!0,depthWrite:!1}),o=150;for(let e=0;e<o;e++){const t=new THREE.BufferGeometry;t.setAttribute("position",new THREE.BufferAttribute(new Float32Array([0,0,0]),3));const i=new THREE.Points(t,s.clone());this.satellites.push({point:i,radius:4+2*Math.random(),speed:.002+.008*Math.random(),angle:2*Math.random()*Math.PI,axis:(new THREE.Vector3(Math.random()-.5,Math.random()-.5,Math.random()-.5)).normalize()}),this.group.add(i)}const n=new THREE.BufferGeometry;n.setAttribute("position",new THREE.BufferAttribute(new Float32Array(3*o),3));const a=new THREE.LineBasicMaterial({color:16777215,transparent:!0,opacity:.3,blending:THREE.AdditiveBlending,depthWrite:!1});this.satelliteConnectorLine=new THREE.Line(n,a),this.group.add(this.satelliteConnectorLine),e.add(this.group)}update(e,t){const i=this.sphere.geometry.attributes.position.array,s=this.sphere.geometry.attributes.color.array;this.sphere.material.size=.03+t.avgVolume/255*.1;const o=performance.now()*.0005;for(let n=0;n<i.length;n+=3){const a=n/3,r=2*a%e.length,l=e[r],h=l/255*2*Math.pow(1-r/e.length,1.5),c=new THREE.Vector3(this.originalPositions[n],this.originalPositions[n+1],this.originalPositions[n+2]);c.normalize().multiplyScalar(1+h),i[n]=2.5*c.x,i[n+1]=2.5*c.y,i[n+2]=2.5*c.z;const d=(new THREE.Color).setHSL((o+a/i.length*.1)%1,.9,.5+l/255*.4);d.r+=.8*t.avgLow,d.g+=.8*t.avgMid,d.b+=.8*t.avgHigh,s[n]=d.r,s[n+1]=d.g,s[n+2]=d.b}this.sphere.geometry.attributes.position.needsUpdate=!0,this.sphere.geometry.attributes.color.needsUpdate=!0,this.sphere.rotation.y+=.0008;const n=this.satelliteConnectorLine.geometry.attributes.position.array;let a=0;this.satellites.forEach(e=>{e.angle+=e.speed;const i=(new THREE.Quaternion).setFromAxisAngle(e.axis,e.angle),s=(new THREE.Vector3(e.radius*(1+.5*t.avgLow),0,0)).applyQuaternion(i);e.point.position.copy(s),n[a++]=s.x,n[a++]=s.y,n[a++]=s.z,e.point.material.color.setHSL(.55,1,Math.min(.5+1.5*t.avgHigh,1))}),this.satelliteConnectorLine.geometry.setDrawRange(0,this.satellites.length),this.satelliteConnectorLine.geometry.attributes.position.needsUpdate=!0}}
        class VisDynamicTerrain{constructor(){this.name="Dynamic Terrain";this.group=new THREE.Group;this.originalPositions=null}init(e){const t=128,i=new THREE.PlaneGeometry(15,15,t,t);this.plane=new THREE.Mesh(i,new THREE.MeshPhongMaterial({vertexColors:!0,wireframe:!0})),this.plane.rotation.x=-Math.PI/2.5,this.originalPositions=new Float32Array(i.attributes.position.array),this.group.add(this.plane);const s=new THREE.BufferGeometry;s.setAttribute("position",new THREE.BufferAttribute(new Float32Array(3*(t+1)*(t+1)),3)),this.peakParticles=new THREE.Points(s,new THREE.PointsMaterial({size:.05,color:16777215,map:createGlowTexture(),blending:THREE.AdditiveBlending,transparent:!0,depthWrite:!1})),this.peakParticles.rotation.x=this.plane.rotation.x,this.group.add(this.peakParticles),this.group.add(new THREE.AmbientLight(16777215,.2));const o=new THREE.DirectionalLight(16777215,1);o.position.set(0,1,.5),this.group.add(o),e.add(this.group)}update(e,t){const i=this.plane.geometry.attributes.position.array,s=this.peakParticles.geometry.attributes.position.array,o=new Float32Array(i.length);for(let n=0;n<i.length;n+=3){const a=n+2,r=Math.floor(a/3%e.length*.5),l=e[r]/255*3*t.avgLow;i[a]=this.originalPositions[a]+l,s[n]=i[n],s[n+1]=i[n+1],s[n+2]=i[a]+.02;const h=new THREE.Color;h.setHSL((.6-.1*l)%1,1,.5),o[n]=h.r,o[n+1]=h.g,o[n+2]=h.b}this.plane.geometry.setAttribute("color",new THREE.BufferAttribute(o,3)),this.plane.geometry.attributes.position.needsUpdate=!0,this.peakParticles.geometry.attributes.position.needsUpdate=!0}}
        class VisOscillator{constructor(){this.name="Oscillator";this.group=new THREE.Group;this.timeDomainArray=null;this.trails=[];this.trailCount=8;this.segmentCount=512}init(e){for(let t=0;t<this.trailCount;t++){const i=new THREE.BufferGeometry,s=new Float32Array(2*this.segmentCount*3),o=new Float32Array(2*this.segmentCount*3);i.setAttribute("position",new THREE.BufferAttribute(s,3)),i.setAttribute("color",new THREE.BufferAttribute(o,3));const n=new THREE.MeshBasicMaterial({side:THREE.DoubleSide,vertexColors:!0,transparent:!0,opacity:1-t/this.trailCount*.8,blending:THREE.AdditiveBlending,depthWrite:!1}),a=new THREE.Mesh(i,n);this.trails.push(a),this.group.add(a)}e.add(this.group)}update(e,t){if(!analyser)return;this.timeDomainArray||(this.timeDomainArray=new Uint8Array(analyser.frequencyBinCount)),analyser.getByteTimeDomainData(this.timeDomainArray);for(let e=this.trailCount-1;e>0;e--)this.trails[e].geometry.attributes.position.array.set(this.trails[e-1].geometry.attributes.position.array),this.trails[e].geometry.attributes.color.array.set(this.trails[e-1].geometry.attributes.color.array),this.trails[e].geometry.attributes.position.needsUpdate=!0,this.trails[e].geometry.attributes.color.needsUpdate=!0;const i=this.trails[0].geometry.attributes.position.array,s=this.trails[0].geometry.attributes.color.array,o=.3,n=performance.now()*.001;for(let e=0;e<this.segmentCount;e++){const t=Math.floor(e/this.segmentCount*this.timeDomainArray.length),a=this.timeDomainArray[t]/128,r=2.5*(a-1),l=-6+e/this.segmentCount*12,h=Math.sin(.1*e+n)*.5;i[6*e+0]=l,i[6*e+1]=r+o,i[6*e+2]=h,i[6*e+3]=l,i[6*e+4]=r-o,i[6*e+5]=h;const c=new THREE.Color;c.setHSL(.5+r/5,1,.5),s[6*e+0]=c.r,s[6*e+1]=c.g,s[6*e+2]=c.b,s[6*e+3]=c.r,s[6*e+4]=c.g,s[6*e+5]=c.b}const a=[];for(let e=0;e<this.segmentCount-1;e++){const t=2*e,i=t+1,s=t+2,o=t+3;a.push(t,i,s),a.push(i,o,s)}this.trails[0].geometry.setIndex(a),this.trails[0].geometry.attributes.position.needsUpdate=!0,this.trails[0].geometry.attributes.color.needsUpdate=!0,this.trails[0].geometry.computeVertexNormals()}}
        class VisFrequencyCanvas{constructor(){this.name="Frequency Canvas";this.group=new THREE.Group}init(e){const t=128,i=12,s=new THREE.BufferGeometry,o=new Float32Array(t*t*3),n=new Float32Array(t*t*3);for(let e=0;e<t;e++)for(let a=0;a<t;a++){const r=(e*t+a)*3;o[r]=(a/(t-1)-.5)*i,o[r+1]=(e/(t-1)-.5)*i,o[r+2]=0}s.setAttribute("position",new THREE.BufferAttribute(o,3)),s.setAttribute("color",new THREE.BufferAttribute(n,3));const a=new THREE.PointsMaterial({size:.08,vertexColors:!0,map:createGlowTexture(),blending:THREE.AdditiveBlending,transparent:!0,depthWrite:!1});this.particles=new THREE.Points(s,a),this.group.add(this.particles),this.group.rotation.x=-Math.PI/3,e.add(this.group)}update(e,t){const i=this.particles.geometry.attributes.position.array,s=this.particles.geometry.attributes.color.array,o=Math.sqrt(i.length/3),n=Math.sqrt(.25+.25);for(let t=0;t<o;t++)for(let a=0;a<o;a++){const r=(t*o+a)*3,l=a/(o-1)-.5,h=t/(o-1)-.5,c=Math.sqrt(l*l+h*h),d=Math.pow(c/n,2),u=Math.floor(d*(.75*e.length)),g=e[u]/255;i[r+2]=2*g;const m=new THREE.Color,p=.7-.7*d;m.setHSL(p,1,.5+.5*g),s[r]=m.r,s[r+1]=m.g,s[r+2]=m.b}this.particles.geometry.attributes.position.needsUpdate=!0,this.particles.geometry.attributes.color.needsUpdate=!0}}
        
        class VisLiquidMarble {
            constructor() {
                this.name = "Liquid Marble";
                this.group = new THREE.Group();
                this.lastHighPeak = 0;
            }
            init(scene) {
                const geometry = new THREE.PlaneGeometry(2, 2); 
                this.material = new THREE.ShaderMaterial({
                    uniforms: {
                        time: { value: 0 },
                        avgLow: { value: 0 },
                        avgMid: { value: 0 },
                        avgHigh: { value: 0 },
                        highPeak: { value: 0 }
                    },
                    vertexShader: `
                        varying vec2 vUv; 
                        void main() { 
                            vUv = uv; 
                            gl_Position = vec4(position, 1.0); 
                        }
                    `,
                    fragmentShader: `
                        uniform float time;
                        uniform float avgLow;
                        uniform float avgMid;
                        uniform float avgHigh;
                        uniform float highPeak;
                        varying vec2 vUv;

                        float random (in vec2 _st) { return fract(sin(dot(_st.xy, vec2(12.9898,78.233))) * 43758.5453123); }
                        float noise (in vec2 _st) {
                            vec2 i = floor(_st); vec2 f = fract(_st);
                            float a = random(i); float b = random(i + vec2(1.0, 0.0));
                            float c = random(i + vec2(0.0, 1.0)); float d = random(i + vec2(1.0, 1.0));
                            vec2 u = f * f * (3.0 - 2.0 * f);
                            return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.y * u.x;
                        }
                        #define NUM_OCTAVES 5
                        float fbm ( in vec2 _st) {
                            float v = 0.0; float a = 0.5; vec2 shift = vec2(100.0);
                            mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.50));
                            for (int i = 0; i < NUM_OCTAVES; ++i) { v += a * noise(_st); _st = rot * _st * 2.0 + shift; a *= 0.5; }
                            return v;
                        }

                        void main() {
                            vec2 st = vUv * (2.0 + avgLow * 2.0) - (1.0 + avgLow);
                            st += vec2(sin(time * 0.1), cos(time * 0.1)) * 0.5;
                            vec2 q = vec2(fbm(st + 0.1*time), fbm(st + vec2(1.0)));
                            vec2 r = vec2(fbm(st + 1.0*q + vec2(1.7,9.2)+ 0.15*time), fbm(st + 1.0*q + vec2(8.3,2.8)+ 0.126*time));
                            float f = fbm(st+r);
                            vec3 color = mix(vec3(0.1,0.6,0.7), vec3(0.7,0.7,0.5), clamp((f*f)*4.0,0.0,1.0));
                            color = mix(color, vec3(0.0,0.0,0.16), clamp(length(q),0.0,1.0));
                            color = mix(color, vec3(0.7,1.0,1.0), clamp(length(r.x),0.0,1.0));
                            color *= (f*f*f+.6*f*f+.5*f);
                            
                            float wave = sin(vUv.x * 10.0 + time * 2.0) * 0.3 * avgLow;
                            color *= 1.0 + wave;

                            float lightning = smoothstep(0.3, 0.8, noise(vUv * 10.0 + time * 0.5)) * highPeak * 2.0;
                            color += vec3(0.8, 1.0, 1.0) * lightning;

                            gl_FragColor = vec4(color,1.0);
                        }
                    `
                });
                const mesh = new THREE.Mesh(geometry, this.material);
                this.group.add(mesh);
                scene.add(this.group);
            }
            update(dataArray, audioFeatures) {
                this.material.uniforms.time.value = performance.now() * 0.0005;
                this.material.uniforms.avgLow.value = audioFeatures.avgLow;
                this.material.uniforms.avgMid.value = audioFeatures.avgMid;
                this.material.uniforms.avgHigh.value = audioFeatures.avgHigh;
                
                let highPeakValue = 0;
                if (audioFeatures.avgHigh - this.lastHighPeak > 0.2) {
                    highPeakValue = 1;
                }
                this.material.uniforms.highPeak.value = highPeakValue;
                this.lastHighPeak = audioFeatures.avgHigh;
            }
        }

        class VisStageLights {
            constructor() {
                this.name = "Grainy Screen";
                this.group = new THREE.Group();
            }
            init(scene) {
                const geometry = new THREE.PlaneGeometry(2, 2);
                this.material = new THREE.ShaderMaterial({
                    uniforms: {
                        time: { value: 0 },
                        resolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
                        avgLow: { value: 0 },
                        avgMid: { value: 0 },
                        avgHigh: { value: 0 },
                    },
                    vertexShader: `
                        varying vec2 vUv;
                        void main() {
                            vUv = uv;
                            gl_Position = vec4(position, 1.0);
                        }
                    `,
                    fragmentShader: `
                        uniform vec2 resolution;
                        uniform float time;
                        uniform float avgLow;
                        uniform float avgMid;
                        uniform float avgHigh;
                        varying vec2 vUv;

                        float random (in vec2 _st) { return fract(sin(dot(_st.xy, vec2(12.9898,78.233))) * 43758.5453123); }

                        vec3 hsv2rgb(vec3 c) {
                            vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
                            vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
                            return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
                        }

                        void main() {
                            vec2 st = (vUv - 0.5);
                            st.x *= resolution.x / resolution.y;
                            
                            vec3 color = vec3(0.0);
                            vec3 bgColor = vec3(0.1, 0.05, 0.2) * (0.5 + avgLow * 1.5);
                            color += bgColor;
                            
                            for(float i = 0.0; i < 7.0; i++) {
                                float time_offset = i * 1.3;
                                float angle_speed = 0.3 + i * 0.05;
                                float beam_phase = sin(time * angle_speed + time_offset) * 1.2;
                                
                                vec2 light_pos = vec2(beam_phase, -1.2);
                                vec2 dir_to_pixel = st - light_pos;
                                float dist_to_light = length(dir_to_pixel);
                                dir_to_pixel = normalize(dir_to_pixel);
                                
                                float intensity = pow(0.15 / dist_to_light, 1.2);
                                
                                vec2 light_up_dir = normalize(vec2(sin(time*0.2 + i*2.0)*0.5, 1.0)); 
                                float ray = pow(max(0.0, dot(dir_to_pixel, light_up_dir)), 2.5);
                                
                                intensity *= ray * (0.5 + avgLow * 2.5);
                                
                                float hue = fract(time * 0.1 + i / 7.0);
                                float saturation = 0.6 + avgMid * 0.4;
                                vec3 beam_color = hsv2rgb(vec3(hue, saturation, 1.0));
                                
                                color += intensity * beam_color;
                            }

                            float smoke = random(st * 2.0 + time * 0.1) * 0.15;
                            color += smoke * vec3(0.5, 0.5, 0.7);

                            float sparkle = pow(random(st * (1.0 + avgHigh * 20.0)), 20.0);
                            color += sparkle * (1.0 + avgHigh * 2.0);

                            color *= smoothstep(1.5, 0.4, length(st));

                            gl_FragColor = vec4(color, 1.0);
                        }
                    `
                });
                const mesh = new THREE.Mesh(geometry, this.material);
                this.group.add(mesh);
                scene.add(this.group);
                window.addEventListener('resize', () => {
                    this.material.uniforms.resolution.value.set(window.innerWidth, window.innerHeight);
                });
            }
            update(dataArray, audioFeatures) {
                this.material.uniforms.time.value = performance.now() * 0.001;
                this.material.uniforms.avgLow.value = audioFeatures.avgLow;
                this.material.uniforms.avgMid.value = audioFeatures.avgMid;
                this.material.uniforms.avgHigh.value = audioFeatures.avgHigh;
            }
        }

        class VisGrasshopper {
            constructor() {
                this.name = "Grasshopper";
                this.group = new THREE.Group();
            }
            init(scene) {
                const geometry = new THREE.PlaneGeometry(2, 2);
                this.material = new THREE.ShaderMaterial({
                    uniforms: {
                        time: { value: 0 },
                        resolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
                        avgLow: { value: 0 },
                        avgMid: { value: 0 },
                        avgHigh: { value: 0 },
                    },
                    vertexShader: `
                        varying vec2 vUv;
                        void main() {
                            vUv = uv;
                            gl_Position = vec4(position, 1.0);
                        }
                    `,
                    fragmentShader: `
                        uniform vec2 resolution;
                        uniform float time;
                        uniform float avgLow;
                        uniform float avgMid;
                        uniform float avgHigh;
                        varying vec2 vUv;

                        float random (in vec2 _st) { return fract(sin(dot(_st.xy, vec2(12.9898,78.233))) * 43758.5453123); }

                        float noise (in vec2 _st) {
                            vec2 i = floor(_st);
                            vec2 f = fract(_st);
                            float a = random(i);
                            float b = random(i + vec2(1.0, 0.0));
                            float c = random(i + vec2(0.0, 1.0));
                            float d = random(i + vec2(1.0, 1.0));
                            vec2 u = f * f * (3.0 - 2.0 * f);
                            return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.y * u.x;
                        }

                        #define NUM_OCTAVES 6
                        float fbm ( in vec2 _st) {
                            float v = 0.0;
                            float a = 0.5;
                            vec2 shift = vec2(100.0);
                            mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.50));
                            for (int i = 0; i < NUM_OCTAVES; ++i) {
                                v += a * noise(_st);
                                _st = rot * _st * 2.0 + shift;
                                a *= 0.5;
                            }
                            return v;
                        }

                        void main() {
                            vec2 st = vUv * 5.0;
                            
                            vec2 wind_uv = vUv * vec2(2.0, 0.5) + vec2(time * 0.2, time * 0.1);
                            float wind_pattern = noise(wind_uv) - 0.5;
                            
                            float wind_strength = 0.2 + avgLow * 0.5;
                            
                            st.x += wind_pattern * wind_strength;
                            
                            float pattern = fbm(st);
                            
                            vec3 grass_dark = vec3(0.1, 0.3, 0.05);
                            vec3 grass_light = vec3(0.4, 0.8, 0.2);
                            vec3 grass_dry = vec3(0.6, 0.5, 0.1);

                            vec3 color = mix(grass_dark, grass_light, smoothstep(0.4, 0.6, pattern));
                            color = mix(color, grass_dry, smoothstep(0.6, 0.65, pattern));

                            color.g += avgMid * 0.2;
                            color.r += avgMid * 0.1;

                            float sparkle = pow(noise(st * 20.0 + time), 10.0) * avgHigh * 1.5;
                            color += vec3(0.8, 1.0, 0.7) * sparkle;
                            
                            color *= smoothstep(1.0, 0.3, length(vUv - 0.5));

                            gl_FragColor = vec4(color, 1.0);
                        }
                    `
                });
                const mesh = new THREE.Mesh(geometry, this.material);
                this.group.add(mesh);
                scene.add(this.group);
                window.addEventListener('resize', () => {
                    this.material.uniforms.resolution.value.set(window.innerWidth, window.innerHeight);
                });
            }
            update(dataArray, audioFeatures) {
                this.material.uniforms.time.value = performance.now() * 0.001;
                this.material.uniforms.avgLow.value = audioFeatures.avgLow;
                this.material.uniforms.avgMid.value = audioFeatures.avgMid;
                this.material.uniforms.avgHigh.value = audioFeatures.avgHigh;
            }
        }

        class VisMatrix {
            constructor() {
                this.name = "Matrix";
                this.group = new THREE.Group();
                this.canvas = null;
                this.ctx = null;
                this.drops = [];
                this.columns = 0;
                this.fontSize = 16;
                this.animationInterval = null;
                this.characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
                this.currentAudioFeatures = { avgLow: 0, avgMid: 0, avgHigh: 0 };
            }

            init() {
                this.canvas = document.getElementById('matrixCanvas');
                if (!this.canvas) return;
                this.ctx = this.canvas.getContext('2d');
                this.setupCanvas(); 
                window.addEventListener('resize', () => {
                    if (this.canvas.style.display === 'block') {
                        this.setupCanvas();
                    }
                }, false);
            }

            setupCanvas() {
                if (!this.canvas) return;
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
                this.columns = Math.floor(this.canvas.width / this.fontSize);
                this.drops = [];
                for (let x = 0; x < this.columns; x++) {
                    this.drops[x] = 1 + Math.random() * 100; 
                }
            }

            draw() {
                if (!this.ctx) return;
                
                this.ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                this.ctx.font = this.fontSize + 'px monospace';

                for (let i = 0; i < this.drops.length; i++) {
                    const text = this.characters.charAt(Math.floor(Math.random() * this.characters.length));
                    const x = i * this.fontSize;
                    const y = this.drops[i] * this.fontSize;
                    
                    const midPulseGreen = 150 + Math.floor(this.currentAudioFeatures.avgMid * 105);
                    const glowAmount = this.currentAudioFeatures.avgLow * 20;
                    
                    this.ctx.fillStyle = `rgb(0, ${midPulseGreen}, 0)`;
                    this.ctx.shadowBlur = glowAmount;
                    this.ctx.shadowColor = 'rgba(100, 255, 100, 0.5)';
                    
                    this.ctx.fillText(text, x, y);

                    const shineAlpha = this.currentAudioFeatures.avgHigh * 0.8; 
                    if (shineAlpha > 0.1) {
                        this.ctx.fillStyle = `rgba(255, 255, 255, ${shineAlpha})`;
                        this.ctx.shadowBlur = 5; 
                        this.ctx.shadowColor = 'rgba(255, 255, 255, 0.7)';
                        this.ctx.fillText(text, x, y);
                    }

                    this.ctx.shadowBlur = 0;

                    if (y > this.canvas.height && Math.random() > 0.975) {
                        this.drops[i] = 0;
                    }

                    this.drops[i]++;
                }
            }

            start() {
                if (this.animationInterval) return;
                this.setupCanvas();
                this.canvas.style.display = 'block';
                this.animationInterval = setInterval(() => this.draw(), 33);
            }

            stop() {
                if (!this.animationInterval) return;
                this.canvas.style.display = 'none';
                clearInterval(this.animationInterval);
                this.animationInterval = null;
            }
            
            update(dataArray, audioFeatures) {
                this.currentAudioFeatures = audioFeatures;
            }
        }

        function resumeAudioContext() {
            if (audioContext && audioContext.state === 'suspended' && !audioContextResumed) {
                audioContext.resume().then(() => {
                    audioContextResumed = true;
                }).catch(err => {
                    console.log('AudioContext resume error:', err);
                });
            }
        }

        function goHome() {
            if (document.fullscreenElement || document.webkitFullscreenElement || document.mozFullscreenElement || document.msFullscreenElement) {
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                } else if (document.webkitExitFullscreen) {
                    document.webkitExitFullscreen();
                } else if (document.mozCancelFullScreen) {
                    document.mozCancelFullScreen();
                } else if (document.msExitFullscreen) {
                    document.msExitFullscreen();
                }
            }
            
            audio.pause();
            
            if (visualizations[currentVisualizationIndex].name === "Matrix") {
                visualizations[currentVisualizationIndex].stop();
            }
            renderer.domElement.style.display = 'block';

            visualizations.forEach(vis => vis.group.visible = false);
            audioControlsContainer.classList.remove('visible');
            visSwitcher.classList.remove('visible');
            topBar.classList.remove('visible');
            playlistPanel.classList.remove('visible');

            initialPrompt.style.display = 'flex';
            footerElement.style.display = 'block';
            backgroundGroup.visible = true;
            
            updateHomepageUI();
        }

        function resumeSession() {
            initialPrompt.style.display = 'none';
            footerElement.style.display = 'none';
            backgroundGroup.visible = false;

            const currentVis = visualizations[currentVisualizationIndex];
            if (currentVis.name === "Matrix") {
                renderer.domElement.style.display = 'none';
                currentVis.start();
            } else {
                renderer.domElement.style.display = 'block';
                currentVis.group.visible = true;
            }

            audioControlsContainer.classList.add('visible');
            visSwitcher.classList.add('visible');
            topBar.classList.add('visible');
            if(currentTrackIndex !== -1) {
                audio.play().catch(err => console.log('Play error:', err));
            }
        }

        function updateHomepageUI() {
            if (playlist.length > 0) {
                resumeBtn.style.display = 'block';
            } else {
                resumeBtn.style.display = 'none';
            }
        }

        function switchVisualization(direction) {
            const oldIndex = currentVisualizationIndex;
            const oldVis = visualizations[oldIndex];
            
            currentVisualizationIndex = (currentVisualizationIndex + direction + visualizations.length) % visualizations.length;
            const newVis = visualizations[currentVisualizationIndex];

            if (oldVis.name === "Matrix") {
                oldVis.stop();
                renderer.domElement.style.display = 'block';
            } else {
                oldVis.group.visible = false;
            }

            if (newVis.name === "Matrix") {
                newVis.start();
                renderer.domElement.style.display = 'none';
            } else {
                newVis.group.visible = true;
            }
            
            visNameElement.textContent = newVis.name;
        }

        function setupAudioContext() {
            if (audioContext) return;
            const AudioContextClass = window.AudioContext || window.webkitAudioContext;
            audioContext = new AudioContextClass();
            const source = audioContext.createMediaElementSource(audio);
            analyser = audioContext.createAnalyser();
            analyser.fftSize = 2048;
            analyser.minDecibels = -90;
            analyser.maxDecibels = -10;
            analyser.smoothingTimeConstant = 0.85;
            dataArray = new Uint8Array(analyser.frequencyBinCount);
            source.connect(analyser);
            analyser.connect(audioContext.destination);
        }

        function onFileSelect(event) {
            const newFiles = Array.from(event.target.files);
            if (newFiles.length === 0) return;

            const wasPlaylistEmpty = playlist.length === 0;
            const isFromHomepage = initialPrompt.style.display !== 'none';

            newFiles.forEach(file => {
                playlist.push({
                    name: file.name,
                    url: URL.createObjectURL(file)
                });
            });

            renderPlaylist();

            if (isFromHomepage) {
                resumeSession();
                playlistPanel.classList.add('visible');
                if (wasPlaylistEmpty) {
                    playTrack(0);
                }
            }
            
            if (!controls) {
                controls = new THREE.OrbitControls(camera, renderer.domElement);
                controls.enableDamping = true;
                controls.dampingFactor = 0.05;
            }
            if (!analyser) setupAudioContext();
            
            fileInput.value = '';
        }

        function playTrack(index) {
            if (index < 0 || index >= playlist.length) return;
            currentTrackIndex = index;
            audio.src = playlist[index].url;
            audio.play().catch(err => {
                console.log('Play error:', err);
            });
            songTitleElement.textContent = playlist[index].name;
            renderPlaylist();
        }

        function playNextTrack() {
            if (playlist.length === 0) return;
            let nextIndex = currentTrackIndex + 1;
            if (nextIndex >= playlist.length) {
                nextIndex = 0;
            }
            playTrack(nextIndex);
        }

        function playPreviousTrack() {
            if (playlist.length === 0) return;
            let prevIndex = currentTrackIndex - 1;
            if (prevIndex < 0) {
                prevIndex = playlist.length - 1;
            }
            playTrack(prevIndex);
        }
        
        function removeTrack(index) {
            if (index < 0 || index >= playlist.length) return;

            const isCurrentlyPlaying = (index === currentTrackIndex);
            playlist.splice(index, 1);

            if (isCurrentlyPlaying) {
                audio.pause();
                audio.src = '';
                songTitleElement.textContent = 'Select a track';
                currentTrackIndex = -1; 
            } 
            else if (index < currentTrackIndex) {
                currentTrackIndex--; 
            }

            if (playlist.length === 0) {
                goHome();
            } else {
                renderPlaylist();
            }
        }

        function renderPlaylist() {
            playlistList.innerHTML = '';
            playlist.forEach((track, index) => {
                const li = document.createElement('li');
                
                const trackName = document.createElement('span');
                trackName.textContent = track.name;
                li.appendChild(trackName);

                const removeBtn = document.createElement('button');
                removeBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg>`;
                removeBtn.className = 'remove-track-btn';
                removeBtn.title = 'Remove track';
                
                removeBtn.addEventListener('click', (event) => {
                    event.stopPropagation();
                    removeTrack(index);
                });
                li.appendChild(removeBtn);

                if (index === currentTrackIndex) {
                    li.classList.add('playing');
                }
                li.addEventListener('click', () => playTrack(index));
                playlistList.appendChild(li);
            });
        }
        
        function toggleFullscreen() {
            if (!document.fullscreenElement && !document.webkitFullscreenElement && !document.mozFullscreenElement && !document.msFullscreenElement) {
                const elem = document.documentElement;
                if (elem.requestFullscreen) {
                    elem.requestFullscreen().catch(err => console.error(`Fullscreen error: ${err.message}`));
                } else if (elem.webkitRequestFullscreen) {
                    elem.webkitRequestFullscreen();
                } else if (elem.mozRequestFullScreen) {
                    elem.mozRequestFullScreen();
                } else if (elem.msRequestFullscreen) {
                    elem.msRequestFullscreen();
                }
            } else {
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                } else if (document.webkitExitFullscreen) {
                    document.webkitExitFullscreen();
                } else if (document.mozCancelFullScreen) {
                    document.mozCancelFullScreen();
                } else if (document.msExitFullscreen) {
                    document.msExitFullscreen();
                }
            }
        }

        function showControls() {
            interactiveUIs.forEach(el => el.classList.add('visible'));
        }
        
        function hideControls() {
            interactiveUIs.forEach(el => el.classList.remove('visible'));
        }

        function onFullscreenChange() {
            const isFullscreen = !!(document.fullscreenElement || document.webkitFullscreenElement || document.mozFullscreenElement || document.msFullscreenElement);
            document.body.classList.toggle('fullscreen-active', isFullscreen);

            enterFullscreenIcon.classList.toggle('hidden', isFullscreen);
            exitFullscreenIcon.classList.toggle('hidden', !isFullscreen);

            if (isFullscreen) {
                uiHideTimeout = setTimeout(hideControls, 3000);
                window.addEventListener('mousemove', handleFullscreenActivity);
                window.addEventListener('touchstart', handleFullscreenActivity);
            } else {
                clearTimeout(uiHideTimeout);
                showControls();
                window.removeEventListener('mousemove', handleFullscreenActivity);
                window.removeEventListener('touchstart', handleFullscreenActivity);
            }
        }

        function handleFullscreenActivity() {
            if (document.fullscreenElement || document.webkitFullscreenElement || document.mozFullscreenElement || document.msFullscreenElement) {
                showControls();
                clearTimeout(uiHideTimeout);
                uiHideTimeout = setTimeout(hideControls, 3000);
            }
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            if (controls) controls.update();

            if (backgroundGroup.visible) {
                backgroundGroup.children[0].material.uniforms.time.value = performance.now() * 0.001;
            }
            
            if (analyser) {
                analyser.getByteFrequencyData(dataArray);
                const bufferLength = analyser.frequencyBinCount;
                
                const lowEnd = Math.floor(bufferLength * 0.1);
                const midEnd = Math.floor(bufferLength * 0.4);
                let lowSum = 0, midSum = 0, highSum = 0;
                for (let i = 0; i < lowEnd; i++) lowSum += dataArray[i];
                for (let i = lowEnd; i < midEnd; i++) midSum += dataArray[i];
                for (let i = midEnd; i < bufferLength; i++) highSum += dataArray[i];

                const audioFeatures = {
                    avgLow: (lowSum / lowEnd) / 255,
                    avgMid: (midSum / (midEnd - lowEnd)) / 255,
                    avgHigh: (highSum / (bufferLength - midEnd)) / 255,
                    avgVolume: (lowSum + midSum + highSum) / bufferLength
                };
                
                const currentVis = visualizations[currentVisualizationIndex];
                if (currentVis && (currentVis.group.visible || currentVis.name === "Matrix")) {
                     currentVis.update(dataArray, audioFeatures);
                }
            }

            renderer.render(scene, camera);
        }

        init();
        animate();
    </script>
</body>
</html>