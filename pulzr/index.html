<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>PULZR Audioverse</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000000;
            font-family: 'Poppins', sans-serif;
            color: #e5e7eb;
            overscroll-behavior-x: none; /* Prevent horizontal pull-to-refresh/navigation */
        }
        canvas {
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 0;
        }
        #ui-container {
            position: relative;
            z-index: 1;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            pointer-events: none; /* Allows mouse events to pass through to the canvas */
        }
        #initial-prompt, #file-input, #play-button, #visualization-switcher, .ui-button {
            pointer-events: auto; /* Re-enable pointer events for the input itself */
        }
        #initial-prompt h1 {
            color: rgba(255, 255, 255, 0.85);
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.5), 0 0 35px rgba(255, 255, 255, 0.3);
        }
        #initial-prompt p {
             color: rgba(229, 231, 235, 0.75);
             text-shadow: 0 0 8px rgba(229, 231, 235, 0.2);
        }
        #audio-controls {
            position: absolute;
            bottom: 2rem;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
            border-radius: 0.75rem;
            padding: 0.5rem 1rem;
            width: 90%;
            max-width: 500px;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            opacity: 0;
            transition: opacity 0.5s ease-in-out;
            pointer-events: none;
        }
        #audio-controls.visible {
            opacity: 1;
            pointer-events: auto;
        }
        #top-bar {
            position: absolute;
            top: 1rem;
            left: 1rem;
            right: 1rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            opacity: 0;
            transition: opacity 0.5s ease-in-out;
            pointer-events: none;
        }
        #top-bar.visible {
            opacity: 1;
            pointer-events: auto;
        }
        #song-title {
            color: white;
            font-size: 1.1rem;
            font-weight: 500;
            background: rgba(0,0,0,0.3);
            padding: 0.5rem 1.5rem;
            border-radius: 0.5rem;
            backdrop-filter: blur(10px);
            max-width: 50vw;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .ui-button {
            background: rgba(0,0,0,0.3);
            backdrop-filter: blur(10px);
            border-radius: 50%;
            cursor: pointer;
            width: 3rem;
            height: 3rem;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: background 0.2s;
            flex-shrink: 0;
        }
        .ui-button:hover {
            background: rgba(0,0,0,0.5);
        }
        body.fullscreen-active #home-btn {
            display: none;
        }
        #playlist-panel {
            position: absolute;
            top: 0;
            right: 0;
            width: 350px;
            max-width: 80vw;
            height: 100%;
            background: rgba(10, 10, 20, 0.8);
            backdrop-filter: blur(15px);
            transform: translateX(100%);
            transition: transform 0.4s ease-in-out;
            z-index: 20;
            display: flex;
            flex-direction: column;
        }
        #playlist-panel.visible {
            transform: translateX(0);
        }
        #playlist-header {
            padding: 1rem;
            border-bottom: 1px solid rgba(255,255,255,0.1);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        #playlist-header h2 {
            font-size: 1.2rem;
            font-weight: 600;
        }
        #playlist-list {
            list-style: none;
            padding: 0;
            margin: 0;
            flex-grow: 1;
            overflow-y: auto;
        }
        #playlist-list li {
            padding: 0.75rem 1rem;
            cursor: pointer;
            transition: background 0.2s;
            border-bottom: 1px solid rgba(255,255,255,0.05);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        #playlist-list li > span {
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        #playlist-list li:hover {
            background: rgba(255,255,255,0.1);
        }
        #playlist-list li.playing {
            background: rgba(99, 102, 241, 0.5);
            font-weight: 600;
        }
        .remove-track-btn {
            background: none;
            border: none;
            color: #9ca3af; /* gray-400 */
            cursor: pointer;
            padding: 0.25rem;
            border-radius: 50%;
            transition: color 0.2s, background 0.2s;
            flex-shrink: 0; /* Prevent button from shrinking */
            margin-left: 1rem;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .remove-track-btn:hover {
            color: #fca5a5; /* red-300 */
            background: rgba(255, 255, 255, 0.1);
        }

        #visualization-switcher {
            position: absolute;
            bottom: 8.5rem; /* Spacing added */
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            align-items: center;
            gap: 1rem;
            background: rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
            border-radius: 0.5rem;
            padding: 0.5rem 1rem;
            opacity: 0;
            transition: opacity 0.5s ease-in-out;
        }
        #visualization-switcher.visible {
            opacity: 1;
        }
        .arrow-btn {
            background: rgba(255,255,255,0.1);
            border: none;
            color: white;
            padding: 0.5rem;
            border-radius: 50%;
            cursor: pointer;
            transition: background 0.2s;
            width: 2.5rem;
            height: 2.5rem;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-shrink: 0;
        }
        .arrow-btn:hover {
            background: rgba(255,255,255,0.2);
        }
        #vis-name {
            color: white;
            font-weight: 500;
            width: 120px;
            text-align: center;
        }
    </style>
</head>
<body>
    <!-- Canvas for Three.js rendering -->
    <div id="canvas-container"></div>
    <!-- Add the new canvas for the Matrix effect -->
    <canvas id="matrixCanvas" style="display: none;"></canvas>

    <!-- UI Elements -->
    <div id="ui-container">
        <div id="initial-prompt" class="flex flex-col items-center gap-4 p-8">
              <h1 class="text-3xl md:text-6xl font-bold text-white tracking-tighter">P U L Z R</h1>
              <h2 class="text-xl md:text-4xl font-bold text-white tracking-tighter">Interactive Audio Visualization.</h2>
              <p class="text-gray-300 max-w-md mt-2">Upload and play your favorite audio playlist to generate a unique visual universe.</p>
              <div class="mt-6 flex gap-4">
                  <label for="file-input" class="cursor-pointer bg-indigo-600 hover:bg-indigo-500 text-white font-bold py-3 px-6 rounded-lg transition-transform duration-200 hover:scale-105 shadow-lg">
                      Upload Audio
                  </label>
                  <button id="resume-btn" class="hidden cursor-pointer bg-gray-600 hover:bg-gray-500 text-white font-bold py-3 px-6 rounded-lg transition-transform duration-200 hover:scale-105 shadow-lg">
                      Resume Session
                  </button>
              </div>
              <input type="file" id="file-input" class="hidden" multiple accept=".mp3,.wav,.m4a,.aac,audio/*">
        </div>
    </div>
    
    <div id="top-bar" class="pointer-events-none">
        <button id="home-btn" class="ui-button" title="Back to Home">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"/><polyline points="9 22 9 12 15 12 15 22"/></svg>
        </button>
        <div id="song-title"></div>
        <div class="flex items-center gap-4">
            <button id="fullscreen-btn" class="ui-button" title="Toggle Fullscreen">
                <svg id="enter-fullscreen-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"/></svg>
                <svg id="exit-fullscreen-icon" class="hidden" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M8 3v3a2 2 0 0 1-2 2H3m18 0h-3a2 2 0 0 1-2-2V3m0 18v-3a2 2 0 0 1 2-2h3M3 16h3a2 2 0 0 1 2 2v3"/></svg>
            </button>
            <button id="playlist-btn" class="ui-button" title="Toggle Playlist">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="8" y1="6" x2="21" y2="6"/><line x1="8" y1="12" x2="21" y2="12"/><line x1="8" y1="18" x2="21" y2="18"/><line x1="3" y1="6" x2="3.01" y2="6"/><line x1="3" y1="12" x2="3.01" y2="12"/><line x1="3" y1="18" x2="3.01" y2="18"/></svg>
            </button>
        </div>
    </div>

    <!-- Playlist Panel -->
    <div id="playlist-panel">
        <div id="playlist-header">
            <h2>Playlist</h2>
            <div class="flex items-center gap-2">
                <label for="file-input" class="arrow-btn" title="Add Tracks">
                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="12" y1="5" x2="12" y2="19"/><line x1="5" y1="12" x2="19" y2="12"/></svg>
                </label>
                <button id="close-playlist-btn" class="arrow-btn" title="Close Playlist">
                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg>
                </button>
            </div>
        </div>
        <ul id="playlist-list"></ul>
    </div>

    <!-- Audio Player Controls -->
    <div id="audio-controls">
        <button id="prev-track-btn" class="arrow-btn" title="Previous Track">
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="11 19 2 12 11 5 11 19"/><polygon points="22 19 13 12 22 5 22 19"/></svg>
        </button>
        <audio id="audio" controls class="w-full"></audio>
        <button id="next-track-btn" class="arrow-btn" title="Next Track">
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="13 19 22 12 13 5 13 19"/><polygon points="2 19 11 12 2 5 2 19"/></svg>
        </button>
    </div>
    
    <!-- Visualization Switcher -->
    <div id="visualization-switcher">
        <button id="prev-vis" class="arrow-btn">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 18l-6-6 6-6"/></svg>
        </button>
        <div id="vis-name">Particle Sphere</div>
        <button id="next-vis" class="arrow-btn">
             <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9 18l6-6-6-6"/></svg>
        </button>
    </div>
    
    <!-- Footer -->
    <div id="footer" class="absolute bottom-4 w-full text-center text-white text-sm pointer-events-none z-10">
        &copy; Adiyat Coto 2025
    </div>


    <!-- Main script -->
    <script type="module">
        // Import necessary Three.js components
        import * as THREE from 'https://esm.sh/three@0.132.2';
        import { OrbitControls } from 'https://esm.sh/three@0.132.2/examples/jsm/controls/OrbitControls';

        // --- Global Variables ---
        let scene, camera, renderer, controls, analyser, dataArray, audioContext;
        let visualizations = [];
        let currentVisualizationIndex = 0;
        let backgroundGroup;
        let playlist = [];
        let currentTrackIndex = -1;
        let uiHideTimeout;

        const fileInput = document.getElementById('file-input');
        const audio = document.getElementById('audio');
        const initialPrompt = document.getElementById('initial-prompt');
        const resumeBtn = document.getElementById('resume-btn');
        const audioControlsContainer = document.getElementById('audio-controls');
        const canvasContainer = document.getElementById('canvas-container');
        const topBar = document.getElementById('top-bar');
        const songTitleElement = document.getElementById('song-title');
        const visSwitcher = document.getElementById('visualization-switcher');
        const prevVisBtn = document.getElementById('prev-vis');
        const nextVisBtn = document.getElementById('next-vis');
        const visNameElement = document.getElementById('vis-name');
        const footerElement = document.getElementById('footer');
        const homeBtn = document.getElementById('home-btn');
        const playlistBtn = document.getElementById('playlist-btn');
        const playlistPanel = document.getElementById('playlist-panel');
        const playlistList = document.getElementById('playlist-list');
        const closePlaylistBtn = document.getElementById('close-playlist-btn');
        const prevTrackBtn = document.getElementById('prev-track-btn');
        const nextTrackBtn = document.getElementById('next-track-btn');
        const fullscreenBtn = document.getElementById('fullscreen-btn');
        const enterFullscreenIcon = document.getElementById('enter-fullscreen-icon');
        const exitFullscreenIcon = document.getElementById('exit-fullscreen-icon');
        const interactiveUIs = [topBar, audioControlsContainer, visSwitcher];

        // --- Core Functions ---
        
        function createGlowTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 128; canvas.height = 128;
            const context = canvas.getContext('2d');
            const gradient = context.createRadialGradient(64, 64, 0, 64, 64, 64);
            gradient.addColorStop(0, 'rgba(255,255,255,1)');
            gradient.addColorStop(0.2, 'rgba(255,255,255,0.8)');
            gradient.addColorStop(0.5, 'rgba(255,255,255,0.3)');
            gradient.addColorStop(1, 'rgba(255,255,255,0)');
            context.fillStyle = gradient;
            context.fillRect(0, 0, 128, 128);
            return new THREE.CanvasTexture(canvas);
        }

        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 8;
            // Optimization: Use high-performance preference
            renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: 'high-performance' });
            renderer.setSize(window.innerWidth, window.innerHeight);
            // Optimization: Cap pixel ratio on high-DPI devices
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
            canvasContainer.appendChild(renderer.domElement);
            
            backgroundGroup = new THREE.Group();
            const bgGeometry = new THREE.PlaneGeometry(30, 30, 100, 100);
            const bgMaterial = new THREE.ShaderMaterial({
                uniforms: { time: { value: 0 } },
                vertexShader: `
                    uniform float time; varying vec2 vUv;
                    void main() {
                        vUv = uv; vec3 pos = position;
                        float wave1 = sin(pos.x * 2.0 + time * 0.4) * 0.5;
                        float wave2 = sin(pos.y * 3.0 + time * 0.3) * 0.2;
                        float twist = cos(pos.y * 1.0 + time * 0.5) * 0.3;
                        pos.y += wave1 + wave2;
                        pos.z += cos(pos.x * 1.5 + time * 0.2) * 0.3 + twist;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform float time; varying vec2 vUv;
                    float random(vec2 st) { return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123); }
                    float noise(vec2 st) {
                        vec2 i = floor(st); vec2 f = fract(st);
                        float a = random(i); float b = random(i + vec2(1.0, 0.0));
                        float c = random(i + vec2(0.0, 1.0)); float d = random(i + vec2(1.0, 1.0));
                        vec2 u = f * f * (3.0 - 2.0 * f);
                        return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.y * u.x;
                    }
                    void main() {
                        vec3 color1 = vec3(0.8, 0.1, 0.5); vec3 color2 = vec3(0.1, 0.2, 0.9); vec3 color3 = vec3(0.2, 0.8, 0.7);
                        float n = noise(vUv * 3.0 + vec2(0.0, time * -0.1));
                        vec3 mixed = mix(color1, color2, n);
                        vec3 finalColor = mix(mixed, color3, vUv.y * 0.8);
                        float veins = smoothstep(0.7, 0.75, noise(vUv * 8.0 + vec2(0.0, time * -0.2)));
                        finalColor += veins * 0.3;
                        gl_FragColor = vec4(finalColor, 1.0);
                    }
                `,
                side: THREE.DoubleSide
            });
            const bgMesh = new THREE.Mesh(bgGeometry, bgMaterial);
            bgMesh.rotation.x = -Math.PI / 3;
            backgroundGroup.add(bgMesh);
            scene.add(backgroundGroup);

            visualizations.push(new VisParticleSphere());
            visualizations.push(new VisDynamicTerrain());
            visualizations.push(new VisOscillator());
            visualizations.push(new VisFrequencyCanvas());
            visualizations.push(new VisLiquidMarble());
            visualizations.push(new VisStageLights());
            visualizations.push(new VisGrasshopper());
            visualizations.push(new VisMatrix());
            
            visualizations.forEach((vis) => {
                vis.init(scene);
                vis.group.visible = false;
            });
            visNameElement.textContent = visualizations[currentVisualizationIndex].name;

            window.addEventListener('resize', onWindowResize, false);
            fileInput.addEventListener('change', onFileSelect, false);
            homeBtn.addEventListener('click', goHome);
            resumeBtn.addEventListener('click', resumeSession);
            playlistBtn.addEventListener('click', () => playlistPanel.classList.add('visible'));
            closePlaylistBtn.addEventListener('click', () => playlistPanel.classList.remove('visible'));
            audio.addEventListener('ended', playNextTrack);
            prevVisBtn.addEventListener('click', () => switchVisualization(-1));
            nextVisBtn.addEventListener('click', () => switchVisualization(1));
            prevTrackBtn.addEventListener('click', playPreviousTrack);
            nextTrackBtn.addEventListener('click', playNextTrack);
            fullscreenBtn.addEventListener('click', toggleFullscreen);
            document.addEventListener('fullscreenchange', onFullscreenChange);
            document.addEventListener('webkitfullscreenchange', onFullscreenChange);
            document.addEventListener('msfullscreenchange', onFullscreenChange);

            window.addEventListener('click', (event) => {
                if (playlistPanel.classList.contains('visible') && !playlistPanel.contains(event.target) && !playlistBtn.contains(event.target)) {
                    playlistPanel.classList.remove('visible');
                }
            });
        }
        
        // --- Visualization Classes ---
        class VisParticleSphere{constructor(){this.name="Particle Sphere";this.group=new THREE.Group;this.originalPositions=null;this.satellites=[]}init(e){const t=new THREE.IcosahedronGeometry(2.5,24);t.setAttribute("color",new THREE.BufferAttribute(new Float32Array(3*t.attributes.position.count),3)),this.originalPositions=new Float32Array(t.attributes.position.array);const i=new THREE.PointsMaterial({size:.08,vertexColors:!0,map:createGlowTexture(),blending:THREE.AdditiveBlending,transparent:!0,depthWrite:!1});this.sphere=new THREE.Points(t,i),this.group.add(this.sphere);const s=new THREE.PointsMaterial({size:.1,color:65535,map:createGlowTexture(),blending:THREE.AdditiveBlending,transparent:!0,depthWrite:!1}),o=150;for(let e=0;e<o;e++){const t=new THREE.BufferGeometry;t.setAttribute("position",new THREE.BufferAttribute(new Float32Array([0,0,0]),3));const i=new THREE.Points(t,s.clone());this.satellites.push({point:i,radius:4+2*Math.random(),speed:.002+.008*Math.random(),angle:2*Math.random()*Math.PI,axis:(new THREE.Vector3(Math.random()-.5,Math.random()-.5,Math.random()-.5)).normalize()}),this.group.add(i)}const n=new THREE.BufferGeometry;n.setAttribute("position",new THREE.BufferAttribute(new Float32Array(3*o),3));const a=new THREE.LineBasicMaterial({color:16777215,transparent:!0,opacity:.3,blending:THREE.AdditiveBlending,depthWrite:!1});this.satelliteConnectorLine=new THREE.Line(n,a),this.group.add(this.satelliteConnectorLine),e.add(this.group)}update(e,t){const i=this.sphere.geometry.attributes.position.array,s=this.sphere.geometry.attributes.color.array;this.sphere.material.size=.03+t.avgVolume/255*.1;const o=performance.now()*.0005;for(let n=0;n<i.length;n+=3){const a=n/3,r=2*a%e.length,l=e[r],h=l/255*2*Math.pow(1-r/e.length,1.5),c=new THREE.Vector3(this.originalPositions[n],this.originalPositions[n+1],this.originalPositions[n+2]);c.normalize().multiplyScalar(1+h),i[n]=2.5*c.x,i[n+1]=2.5*c.y,i[n+2]=2.5*c.z;const d=(new THREE.Color).setHSL((o+a/i.length*.1)%1,.9,.5+l/255*.4);d.r+=.8*t.avgLow,d.g+=.8*t.avgMid,d.b+=.8*t.avgHigh,s[n]=d.r,s[n+1]=d.g,s[n+2]=d.b}this.sphere.geometry.attributes.position.needsUpdate=!0,this.sphere.geometry.attributes.color.needsUpdate=!0,this.sphere.rotation.y+=.0008;const n=this.satelliteConnectorLine.geometry.attributes.position.array;let a=0;this.satellites.forEach(e=>{e.angle+=e.speed;const i=(new THREE.Quaternion).setFromAxisAngle(e.axis,e.angle),s=(new THREE.Vector3(e.radius*(1+.5*t.avgLow),0,0)).applyQuaternion(i);e.point.position.copy(s),n[a++]=s.x,n[a++]=s.y,n[a++]=s.z,e.point.material.color.setHSL(.55,1,Math.min(.5+1.5*t.avgHigh,1))}),this.satelliteConnectorLine.geometry.setDrawRange(0,this.satellites.length),this.satelliteConnectorLine.geometry.attributes.position.needsUpdate=!0}}
        class VisDynamicTerrain{constructor(){this.name="Dynamic Terrain";this.group=new THREE.Group;this.originalPositions=null}init(e){const t=60,i=new THREE.PlaneGeometry(15,15,t,t);this.plane=new THREE.Mesh(i,new THREE.MeshPhongMaterial({vertexColors:!0,wireframe:!0})),this.plane.rotation.x=-Math.PI/2.5,this.originalPositions=new Float32Array(i.attributes.position.array),this.group.add(this.plane);const s=new THREE.BufferGeometry;s.setAttribute("position",new THREE.BufferAttribute(new Float32Array(3*(t+1)*(t+1)),3)),this.peakParticles=new THREE.Points(s,new THREE.PointsMaterial({size:.05,color:16777215,map:createGlowTexture(),blending:THREE.AdditiveBlending,transparent:!0,depthWrite:!1})),this.peakParticles.rotation.x=this.plane.rotation.x,this.group.add(this.peakParticles),this.group.add(new THREE.AmbientLight(16777215,.2));const o=new THREE.DirectionalLight(16777215,1);o.position.set(0,1,.5),this.group.add(o),e.add(this.group)}update(e,t){const i=this.plane.geometry.attributes.position.array,s=this.peakParticles.geometry.attributes.position.array,o=new Float32Array(i.length);for(let n=0;n<i.length;n+=3){const a=n+2,r=Math.floor(a/3%e.length*.5),l=e[r]/255*3*t.avgLow;i[a]=this.originalPositions[a]+l,s[n]=i[n],s[n+1]=i[n+1],s[n+2]=i[a]+.02;const h=new THREE.Color;h.setHSL((.6-.1*l)%1,1,.5),o[n]=h.r,o[n+1]=h.g,o[n+2]=h.b}this.plane.geometry.setAttribute("color",new THREE.BufferAttribute(o,3)),this.plane.geometry.attributes.position.needsUpdate=!0,this.peakParticles.geometry.attributes.position.needsUpdate=!0}}
        class VisOscillator{constructor(){this.name="Oscillator";this.group=new THREE.Group;this.timeDomainArray=null;this.trails=[];this.trailCount=8;this.segmentCount=256}init(e){for(let t=0;t<this.trailCount;t++){const i=new THREE.BufferGeometry,s=new Float32Array(2*this.segmentCount*3),o=new Float32Array(2*this.segmentCount*3);i.setAttribute("position",new THREE.BufferAttribute(s,3)),i.setAttribute("color",new THREE.BufferAttribute(o,3));const n=new THREE.MeshBasicMaterial({side:THREE.DoubleSide,vertexColors:!0,transparent:!0,opacity:1-t/this.trailCount*.8,blending:THREE.AdditiveBlending,depthWrite:!1}),a=new THREE.Mesh(i,n);this.trails.push(a),this.group.add(a)}e.add(this.group)}update(e,t){if(!analyser)return;this.timeDomainArray||(this.timeDomainArray=new Uint8Array(analyser.frequencyBinCount)),analyser.getByteTimeDomainData(this.timeDomainArray);for(let e=this.trailCount-1;e>0;e--)this.trails[e].geometry.attributes.position.array.set(this.trails[e-1].geometry.attributes.position.array),this.trails[e].geometry.attributes.color.array.set(this.trails[e-1].geometry.attributes.color.array),this.trails[e].geometry.attributes.position.needsUpdate=!0,this.trails[e].geometry.attributes.color.needsUpdate=!0;const i=this.trails[0].geometry.attributes.position.array,s=this.trails[0].geometry.attributes.color.array,o=.3,n=performance.now()*.001;for(let e=0;e<this.segmentCount;e++){const t=Math.floor(e/this.segmentCount*this.timeDomainArray.length),a=this.timeDomainArray[t]/128,r=2.5*(a-1),l=-6+e/this.segmentCount*12,h=Math.sin(.1*e+n)*.5;i[6*e+0]=l,i[6*e+1]=r+o,i[6*e+2]=h,i[6*e+3]=l,i[6*e+4]=r-o,i[6*e+5]=h;const c=new THREE.Color;c.setHSL(.5+r/5,1,.5),s[6*e+0]=c.r,s[6*e+1]=c.g,s[6*e+2]=c.b,s[6*e+3]=c.r,s[6*e+4]=c.g,s[6*e+5]=c.b}const a=[];for(let e=0;e<this.segmentCount-1;e++){const t=2*e,i=t+1,s=t+2,o=t+3;a.push(t,i,s),a.push(i,o,s)}this.trails[0].geometry.setIndex(a),this.trails[0].geometry.attributes.position.needsUpdate=!0,this.trails[0].geometry.attributes.color.needsUpdate=!0,this.trails[0].geometry.computeVertexNormals()}}
        class VisFrequencyCanvas{constructor(){this.name="Frequency Canvas";this.group=new THREE.Group}init(e){const t=64,i=12,s=new THREE.BufferGeometry,o=new Float32Array(t*t*3),n=new Float32Array(t*t*3);for(let e=0;e<t;e++)for(let a=0;a<t;a++){const r=(e*t+a)*3;o[r]=(a/(t-1)-.5)*i,o[r+1]=(e/(t-1)-.5)*i,o[r+2]=0}s.setAttribute("position",new THREE.BufferAttribute(o,3)),s.setAttribute("color",new THREE.BufferAttribute(n,3));const a=new THREE.PointsMaterial({size:.08,vertexColors:!0,map:createGlowTexture(),blending:THREE.AdditiveBlending,transparent:!0,depthWrite:!1});this.particles=new THREE.Points(s,a),this.group.add(this.particles),this.group.rotation.x=-Math.PI/3,e.add(this.group)}update(e,t){const i=this.particles.geometry.attributes.position.array,s=this.particles.geometry.attributes.color.array,o=Math.sqrt(i.length/3),n=Math.sqrt(.25+.25);for(let t=0;t<o;t++)for(let a=0;a<o;a++){const r=(t*o+a)*3,l=a/(o-1)-.5,h=t/(o-1)-.5,c=Math.sqrt(l*l+h*h),d=Math.pow(c/n,2),u=Math.floor(d*(.75*e.length)),g=e[u]/255;i[r+2]=2*g;const m=new THREE.Color,p=.7-.7*d;m.setHSL(p,1,.5+.5*g),s[r]=m.r,s[r+1]=m.g,s[r+2]=m.b}this.particles.geometry.attributes.position.needsUpdate=!0,this.particles.geometry.attributes.color.needsUpdate=!0}}
        
        class VisLiquidMarble {
            constructor() {
                this.name = "Liquid Marble";
                this.group = new THREE.Group();
                this.lastHighPeak = 0;
            }
            init(scene) {
                const geometry = new THREE.PlaneGeometry(2, 2); 
                this.material = new THREE.ShaderMaterial({
                    uniforms: {
                        time: { value: 0 },
                        avgLow: { value: 0 },
                        avgMid: { value: 0 },
                        avgHigh: { value: 0 },
                        highPeak: { value: 0 }
                    },
                    vertexShader: `
                        varying vec2 vUv; 
                        void main() { 
                            vUv = uv; 
                            gl_Position = vec4(position, 1.0); 
                        }
                    `,
                    fragmentShader: `
                        uniform float time;
                        uniform float avgLow;
                        uniform float avgMid;
                        uniform float avgHigh;
                        uniform float highPeak;
                        varying vec2 vUv;

                        float random (in vec2 _st) { return fract(sin(dot(_st.xy, vec2(12.9898,78.233))) * 43758.5453123); }
                        float noise (in vec2 _st) {
                            vec2 i = floor(_st); vec2 f = fract(_st);
                            float a = random(i); float b = random(i + vec2(1.0, 0.0));
                            float c = random(i + vec2(0.0, 1.0)); float d = random(i + vec2(1.0, 1.0));
                            vec2 u = f * f * (3.0 - 2.0 * f);
                            return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.y * u.x;
                        }
                        #define NUM_OCTAVES 4 // Optimization: Reduced octaves from 5
                        float fbm ( in vec2 _st) {
                            float v = 0.0; float a = 0.5; vec2 shift = vec2(100.0);
                            mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.50));
                            for (int i = 0; i < NUM_OCTAVES; ++i) { v += a * noise(_st); _st = rot * _st * 2.0 + shift; a *= 0.5; }
                            return v;
                        }

                        void main() {
                            vec2 st = vUv * (2.0 + avgLow * 2.0) - (1.0 + avgLow);
                            st += vec2(sin(time * 0.1), cos(time * 0.1)) * 0.5;
                            vec2 q = vec2(fbm(st + 0.1*time), fbm(st + vec2(1.0)));
                            vec2 r = vec2(fbm(st + 1.0*q + vec2(1.7,9.2)+ 0.15*time), fbm(st + 1.0*q + vec2(8.3,2.8)+ 0.126*time));
                            float f = fbm(st+r);
                            vec3 color = mix(vec3(0.1,0.6,0.7), vec3(0.7,0.7,0.5), clamp((f*f)*4.0,0.0,1.0));
                            color = mix(color, vec3(0.0,0.0,0.16), clamp(length(q),0.0,1.0));
                            color = mix(color, vec3(0.7,1.0,1.0), clamp(length(r.x),0.0,1.0));
                            color *= (f*f*f+.6*f*f+.5*f);
                            
                            float wave = sin(vUv.x * 10.0 + time * 2.0) * 0.3 * avgLow;
                            color *= 1.0 + wave;

                            float lightning = smoothstep(0.3, 0.8, noise(vUv * 10.0 + time * 0.5)) * highPeak * 2.0;
                            color += vec3(0.8, 1.0, 1.0) * lightning;

                            gl_FragColor = vec4(color,1.0);
                        }
                    `
                });
                const mesh = new THREE.Mesh(geometry, this.material);
                this.group.add(mesh);
                scene.add(this.group);
            }
            update(dataArray, audioFeatures) {
                this.material.uniforms.time.value = performance.now() * 0.0005;
                this.material.uniforms.avgLow.value = audioFeatures.avgLow;
                this.material.uniforms.avgMid.value = audioFeatures.avgMid;
                this.material.uniforms.avgHigh.value = audioFeatures.avgHigh;
                
                let highPeakValue = 0;
                if (audioFeatures.avgHigh - this.lastHighPeak > 0.2) {
                    highPeakValue = 1;
                }
                this.material.uniforms.highPeak.value = highPeakValue;
                this.lastHighPeak = audioFeatures.avgHigh;
            }
        }

        class VisStageLights {
            constructor() {
                this.name = "Grainy Screen";
                this.group = new THREE.Group();
            }
            init(scene) {
                const geometry = new THREE.PlaneGeometry(2, 2);
                this.material = new THREE.ShaderMaterial({
                    uniforms: {
                        time: { value: 0 },
                        resolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
                        avgLow: { value: 0 },
                        avgMid: { value: 0 },
                        avgHigh: { value: 0 },
                    },
                    vertexShader: `
                        varying vec2 vUv;
                        void main() {
                            vUv = uv;
                            gl_Position = vec4(position, 1.0);
                        }
                    `,
                    fragmentShader: `
                        uniform vec2 resolution;
                        uniform float time;
                        uniform float avgLow;
                        uniform float avgMid;
                        uniform float avgHigh;
                        varying vec2 vUv;

                        float random (in vec2 _st) { return fract(sin(dot(_st.xy, vec2(12.9898,78.233))) * 43758.5453123); }

                        vec3 hsv2rgb(vec3 c) {
                            vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
                            vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
                            return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
                        }

                        void main() {
                            vec2 st = (vUv - 0.5);
                            st.x *= resolution.x / resolution.y;
                            
                            vec3 color = vec3(0.0);

                            // Pulsing background glow based on bass
                            vec3 bgColor = vec3(0.1, 0.05, 0.2) * (0.5 + avgLow * 1.5);
                            color += bgColor;
                            
                            // 7 dynamic, sweeping light beams
                            for(float i = 0.0; i < 7.0; i++) {
                                float time_offset = i * 1.3;
                                float angle_speed = 0.3 + i * 0.05;
                                // Wider, more dramatic sweep
                                float beam_phase = sin(time * angle_speed + time_offset) * 1.2;
                                
                                vec2 light_pos = vec2(beam_phase, -1.2); // Start from bottom, closer to screen
                                
                                // Volumetric light effect calculation
                                vec2 dir_to_pixel = st - light_pos;
                                float dist_to_light = length(dir_to_pixel);
                                dir_to_pixel = normalize(dir_to_pixel);
                                
                                // Brighter, softer, wider beams
                                float intensity = pow(0.15 / dist_to_light, 1.2);
                                
                                // Make the beams sway a bit
                                vec2 light_up_dir = normalize(vec2(sin(time*0.2 + i*2.0)*0.5, 1.0)); 
                                float ray = pow(max(0.0, dot(dir_to_pixel, light_up_dir)), 2.5);
                                
                                intensity *= ray * (0.5 + avgLow * 2.5); // More impact from bass
                                
                                // Dynamic colors based on time and mid-range audio
                                float hue = fract(time * 0.1 + i / 7.0);
                                float saturation = 0.6 + avgMid * 0.4;
                                vec3 beam_color = hsv2rgb(vec3(hue, saturation, 1.0));
                                
                                color += intensity * beam_color;
                            }

                            // Hazy smoke/atmosphere effect
                            float smoke = random(st * 2.0 + time * 0.1) * 0.15;
                            color += smoke * vec3(0.5, 0.5, 0.7); // Cool-toned smoke

                            // More visible high-frequency sparkles/strobes
                            float sparkle = pow(random(st * (1.0 + avgHigh * 20.0)), 20.0);
                            color += sparkle * (1.0 + avgHigh * 2.0);

                            // Add a soft vignette
                            color *= smoothstep(1.5, 0.4, length(st));

                            gl_FragColor = vec4(color, 1.0);
                        }
                    `
                });
                const mesh = new THREE.Mesh(geometry, this.material);
                this.group.add(mesh);
                scene.add(this.group);
                window.addEventListener('resize', () => {
                    this.material.uniforms.resolution.value.set(window.innerWidth, window.innerHeight);
                });
            }
            update(dataArray, audioFeatures) {
                this.material.uniforms.time.value = performance.now() * 0.001;
                this.material.uniforms.avgLow.value = audioFeatures.avgLow;
                this.material.uniforms.avgMid.value = audioFeatures.avgMid;
                this.material.uniforms.avgHigh.value = audioFeatures.avgHigh;
            }
        }

        class VisGrasshopper {
            constructor() {
                this.name = "Grasshopper";
                this.group = new THREE.Group();
            }
            init(scene) {
                const geometry = new THREE.PlaneGeometry(2, 2);
                this.material = new THREE.ShaderMaterial({
                    uniforms: {
                        time: { value: 0 },
                        resolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
                        avgLow: { value: 0 },
                        avgMid: { value: 0 },
                        avgHigh: { value: 0 },
                    },
                    vertexShader: `
                        varying vec2 vUv;
                        void main() {
                            vUv = uv;
                            gl_Position = vec4(position, 1.0);
                        }
                    `,
                    fragmentShader: `
                        uniform vec2 resolution;
                        uniform float time;
                        uniform float avgLow;
                        uniform float avgMid;
                        uniform float avgHigh;
                        varying vec2 vUv;

                        float random (in vec2 _st) { return fract(sin(dot(_st.xy, vec2(12.9898,78.233))) * 43758.5453123); }

                        float noise (in vec2 _st) {
                            vec2 i = floor(_st);
                            vec2 f = fract(_st);
                            float a = random(i);
                            float b = random(i + vec2(1.0, 0.0));
                            float c = random(i + vec2(0.0, 1.0));
                            float d = random(i + vec2(1.0, 1.0));
                            vec2 u = f * f * (3.0 - 2.0 * f);
                            return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.y * u.x;
                        }

                        #define NUM_OCTAVES 4 // Optimization: Reduced octaves from 6
                        float fbm ( in vec2 _st) {
                            float v = 0.0;
                            float a = 0.5;
                            vec2 shift = vec2(100.0);
                            mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.50));
                            for (int i = 0; i < NUM_OCTAVES; ++i) {
                                v += a * noise(_st);
                                _st = rot * _st * 2.0 + shift;
                                a *= 0.5;
                            }
                            return v;
                        }

                        void main() {
                            vec2 st = vUv * 5.0;
                            
                            vec2 wind_uv = vUv * vec2(2.0, 0.5) + vec2(time * 0.2, time * 0.1);
                            float wind_pattern = noise(wind_uv) - 0.5;
                            
                            float wind_strength = 0.2 + avgLow * 0.5;
                            
                            st.x += wind_pattern * wind_strength;
                            
                            float pattern = fbm(st);
                            
                            vec3 grass_dark = vec3(0.1, 0.3, 0.05);
                            vec3 grass_light = vec3(0.4, 0.8, 0.2);
                            vec3 grass_dry = vec3(0.6, 0.5, 0.1);

                            vec3 color = mix(grass_dark, grass_light, smoothstep(0.4, 0.6, pattern));
                            color = mix(color, grass_dry, smoothstep(0.6, 0.65, pattern));

                            color.g += avgMid * 0.2;
                            color.r += avgMid * 0.1;

                            float sparkle = pow(noise(st * 20.0 + time), 10.0) * avgHigh * 1.5;
                            color += vec3(0.8, 1.0, 0.7) * sparkle;
                            
                            color *= smoothstep(1.0, 0.3, length(vUv - 0.5));

                            gl_FragColor = vec4(color, 1.0);
                        }
                    `
                });
                const mesh = new THREE.Mesh(geometry, this.material);
                this.group.add(mesh);
                scene.add(this.group);
                window.addEventListener('resize', () => {
                    this.material.uniforms.resolution.value.set(window.innerWidth, window.innerHeight);
                });
            }
            update(dataArray, audioFeatures) {
                this.material.uniforms.time.value = performance.now() * 0.001;
                this.material.uniforms.avgLow.value = audioFeatures.avgLow;
                this.material.uniforms.avgMid.value = audioFeatures.avgMid;
                this.material.uniforms.avgHigh.value = audioFeatures.avgHigh;
            }
        }

        class VisMatrix {
            constructor() {
                this.name = "Matrix";
                this.group = new THREE.Group(); // Kept for API compatibility
                this.canvas = null;
                this.ctx = null;
                this.drops = [];
                this.columns = 0;
                this.fontSize = 16;
                this.animationInterval = null;
                this.characters = 'アァカサタナハマヤャラワガザダバパイィキシチニヒミリヰギジヂビピウゥクスツヌフムユュルグズブプエェケセテネヘメレヱゲゼデベペオォコソトノホモヨョロヲゴゾドボポヴッンABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
                // Use a placeholder for audio features until the first update
                this.currentAudioFeatures = { avgLow: 0, avgMid: 0, avgHigh: 0 };
            }

            init() {
                this.canvas = document.getElementById('matrixCanvas');
                if (!this.canvas) return; // Fail gracefully
                this.ctx = this.canvas.getContext('2d');
                // Initial setup for when it's first displayed
                this.setupCanvas(); 
                window.addEventListener('resize', () => {
                    // Only resize if it's currently visible
                    if (this.canvas.style.display === 'block') {
                        this.setupCanvas();
                    }
                }, false);
            }

            setupCanvas() {
                if (!this.canvas) return;
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
                this.columns = Math.floor(this.canvas.width / this.fontSize);
                this.drops = [];
                for (let x = 0; x < this.columns; x++) {
                    // Randomize starting position for a more natural look
                    this.drops[x] = 1 + Math.random() * 100; 
                }
            }

            // The main drawing logic
            draw() {
                if (!this.ctx) return;
                
                // The fading trail effect
                this.ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                this.ctx.font = this.fontSize + 'px monospace';

                for (let i = 0; i < this.drops.length; i++) {
                    const text = this.characters.charAt(Math.floor(Math.random() * this.characters.length));
                    const x = i * this.fontSize;
                    const y = this.drops[i] * this.fontSize;
                    
                    // --- REVISED DYNAMIC SHINING LOGIC ---

                    // 1. Set the base color and glow for the character.
                    // The green channel pulses with the mid-range frequencies.
                    const midPulseGreen = 150 + Math.floor(this.currentAudioFeatures.avgMid * 105);
                    // The glow amount is driven by the bass.
                    const glowAmount = this.currentAudioFeatures.avgLow * 20;
                    
                    this.ctx.fillStyle = `rgb(0, ${midPulseGreen}, 0)`;
                    this.ctx.shadowBlur = glowAmount;
                    this.ctx.shadowColor = 'rgba(100, 255, 100, 0.5)';
                    
                    // Draw the base green, glowing character first. This forms the main part of the trail.
                    this.ctx.fillText(text, x, y);

                    // 2. Layer a bright, white "shine" on top, driven by high-frequencies.
                    // This makes the character flash without completely replacing the green.
                    const shineAlpha = this.currentAudioFeatures.avgHigh * 0.8; 
                    if (shineAlpha > 0.1) { // Threshold to avoid constant faint shine
                        this.ctx.fillStyle = `rgba(255, 255, 255, ${shineAlpha})`;
                        // The shine itself can have a smaller, more intense glow.
                        this.ctx.shadowBlur = 5; 
                        this.ctx.shadowColor = 'rgba(255, 255, 255, 0.7)';
                        this.ctx.fillText(text, x, y);
                    }

                    // 3. Reset shadow properties for the next character in the loop.
                    this.ctx.shadowBlur = 0;

                    // Reset drop when it goes off screen, with some randomness
                    if (y > this.canvas.height && Math.random() > 0.975) {
                        this.drops[i] = 0;
                    }

                    // Move the drop down
                    this.drops[i]++;
                }
            }

            start() {
                if (this.animationInterval) return; // Already running
                this.setupCanvas(); // Ensure it's sized correctly
                this.canvas.style.display = 'block';
                // Run draw at a consistent speed
                this.animationInterval = setInterval(() => this.draw(), 40);
            }

            stop() {
                if (!this.animationInterval) return; // Already stopped
                this.canvas.style.display = 'none';
                clearInterval(this.animationInterval);
                this.animationInterval = null;
            }
            
            // The main animate() loop calls this to pass in fresh audio data
            update(dataArray, audioFeatures) {
                // Just store the latest features for the draw() loop to use
                this.currentAudioFeatures = audioFeatures;
            }
        }


        // --- Event Handlers & Audio Setup ---
        
        function goHome() {
            // BUG FIX: Check if in fullscreen and exit if necessary before resetting UI
            if (document.fullscreenElement || document.webkitFullscreenElement || document.msFullscreenElement) {
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                } else if (document.webkitExitFullscreen) { /* Safari */
                    document.webkitExitFullscreen();
                } else if (document.msExitFullscreen) { /* IE11 */
                    document.msExitFullscreen();
                }
            }
            
            audio.pause();
            
            // Explicitly stop Matrix vis if it's active and show the 3D canvas
            if (visualizations[currentVisualizationIndex].name === "Matrix") {
                visualizations[currentVisualizationIndex].stop();
            }
            renderer.domElement.style.display = 'block';

            visualizations.forEach(vis => vis.group.visible = false);
            audioControlsContainer.classList.remove('visible');
            visSwitcher.classList.remove('visible');
            topBar.classList.remove('visible');
            playlistPanel.classList.remove('visible');

            initialPrompt.style.display = 'flex';
            footerElement.style.display = 'block';
            backgroundGroup.visible = true;
            
            updateHomepageUI();
        }

        function resumeSession() {
            // SAFARI/MOBILE FIX: Resume audio context on user interaction
            if (audioContext && audioContext.state === 'suspended') {
                audioContext.resume();
            }

            initialPrompt.style.display = 'none';
            footerElement.style.display = 'none';
            backgroundGroup.visible = false;

            const currentVis = visualizations[currentVisualizationIndex];
            if (currentVis.name === "Matrix") {
                renderer.domElement.style.display = 'none';
                currentVis.start();
            } else {
                renderer.domElement.style.display = 'block';
                currentVis.group.visible = true;
            }

            audioControlsContainer.classList.add('visible');
            visSwitcher.classList.add('visible');
            topBar.classList.add('visible');
            if(currentTrackIndex !== -1) audio.play();
        }

        function updateHomepageUI() {
            if (playlist.length > 0) {
                resumeBtn.style.display = 'block';
            } else {
                resumeBtn.style.display = 'none';
            }
        }

        function switchVisualization(direction) {
            const oldIndex = currentVisualizationIndex;
            const oldVis = visualizations[oldIndex];
            
            currentVisualizationIndex = (currentVisualizationIndex + direction + visualizations.length) % visualizations.length;
            const newVis = visualizations[currentVisualizationIndex];

            // Deactivate old visualization
            if (oldVis.name === "Matrix") {
                oldVis.stop();
                renderer.domElement.style.display = 'block'; // Show 3D canvas
            } else {
                oldVis.group.visible = false;
            }

            // Activate new visualization
            if (newVis.name === "Matrix") {
                newVis.start();
                renderer.domElement.style.display = 'none'; // Hide 3D canvas
            } else {
                newVis.group.visible = true;
            }
            
            visNameElement.textContent = newVis.name;
        }

        function setupAudioContext() {
            if (audioContext) return;
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            const source = audioContext.createMediaElementSource(audio);
            analyser = audioContext.createAnalyser();
            analyser.fftSize = 1024; // Optimization: Reduced from 2048
            analyser.minDecibels = -90;
            analyser.maxDecibels = -10;
            analyser.smoothingTimeConstant = 0.85;
            dataArray = new Uint8Array(analyser.frequencyBinCount);
            source.connect(analyser);
            analyser.connect(audioContext.destination);
        }

        function onFileSelect(event) {
            const newFiles = Array.from(event.target.files);
            if (newFiles.length === 0) return;

            // --- KEY FIX FOR MOBILE/SAFARI ---
            // Ensure AudioContext is created and resumed within this user gesture.
            if (!audioContext) {
                setupAudioContext();
            }
            if (audioContext.state === 'suspended') {
                audioContext.resume();
            }
            // --- END FIX ---

            const wasPlaylistEmpty = playlist.length === 0;
            const isFromHomepage = initialPrompt.style.display !== 'none';

            newFiles.forEach(file => {
                playlist.push({
                    name: file.name,
                    url: URL.createObjectURL(file)
                });
            });

            renderPlaylist();

            if (!controls) {
                controls = new OrbitControls(camera, renderer.domElement);
                controls.enableDamping = true;
                controls.dampingFactor = 0.05;
                controls.enablePan = false; // Disable panning for a cleaner mobile experience
            }

            if (isFromHomepage) {
                resumeSession();
                playlistPanel.classList.add('visible');
                if (wasPlaylistEmpty) {
                    playTrack(0);
                }
            }
            
            fileInput.value = '';
        }

        function playTrack(index) {
            if (index < 0 || index >= playlist.length) return;
            currentTrackIndex = index;
            audio.src = playlist[index].url;
            audio.play();
            songTitleElement.textContent = playlist[index].name;
            renderPlaylist();
        }

        function playNextTrack() {
            if (playlist.length === 0) return;
            let nextIndex = currentTrackIndex + 1;
            if (nextIndex >= playlist.length) {
                nextIndex = 0;
            }
            playTrack(nextIndex);
        }

        function playPreviousTrack() {
            if (playlist.length === 0) return;
            let prevIndex = currentTrackIndex - 1;
            if (prevIndex < 0) {
                prevIndex = playlist.length - 1;
            }
            playTrack(prevIndex);
        }
        
        function removeTrack(index) {
            if (index < 0 || index >= playlist.length) return;

            const isCurrentlyPlaying = (index === currentTrackIndex);
            playlist.splice(index, 1);

            if (isCurrentlyPlaying) {
                audio.pause();
                audio.src = '';
                songTitleElement.textContent = 'Select a track';
                currentTrackIndex = -1; 
            } 
            else if (index < currentTrackIndex) {
                currentTrackIndex--; 
            }

            if (playlist.length === 0) {
                goHome();
            } else {
                renderPlaylist();
            }
        }

        function renderPlaylist() {
            playlistList.innerHTML = '';
            playlist.forEach((track, index) => {
                const li = document.createElement('li');
                
                const trackName = document.createElement('span');
                trackName.textContent = track.name;
                li.appendChild(trackName);

                const removeBtn = document.createElement('button');
                removeBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg>`;
                removeBtn.className = 'remove-track-btn';
                removeBtn.title = 'Remove track';
                
                removeBtn.addEventListener('click', (event) => {
                    event.stopPropagation();
                    removeTrack(index);
                });
                li.appendChild(removeBtn);

                if (index === currentTrackIndex) {
                    li.classList.add('playing');
                }
                li.addEventListener('click', () => playTrack(index));
                playlistList.appendChild(li);
            });
        }
        
        function toggleFullscreen() {
            if (!document.fullscreenElement && !document.webkitFullscreenElement && !document.msFullscreenElement) {
                const elem = document.documentElement;
                if (elem.requestFullscreen) {
                    elem.requestFullscreen().catch(err => console.error(`Error attempting to enable full-screen mode: ${err.message} (${err.name})`));
                } else if (elem.webkitRequestFullscreen) { /* Safari */
                    elem.webkitRequestFullscreen();
                } else if (elem.msRequestFullscreen) { /* IE11 */
                    elem.msRequestFullscreen();
                }
            } else {
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                } else if (document.webkitExitFullscreen) { /* Safari */
                    document.webkitExitFullscreen();
                } else if (document.msExitFullscreen) { /* IE11 */
                    document.msExitFullscreen();
                }
            }
        }

        function showControls() {
            interactiveUIs.forEach(el => el.classList.add('visible'));
        }
        
        function hideControls() {
            interactiveUIs.forEach(el => el.classList.remove('visible'));
        }

        function onFullscreenChange() {
            const isFullscreen = !!(document.fullscreenElement || document.webkitFullscreenElement || document.msFullscreenElement);
            document.body.classList.toggle('fullscreen-active', isFullscreen);

            enterFullscreenIcon.classList.toggle('hidden', isFullscreen);
            exitFullscreenIcon.classList.toggle('hidden', !isFullscreen);

            if (isFullscreen) {
                uiHideTimeout = setTimeout(hideControls, 3000);
                window.addEventListener('mousemove', handleFullscreenActivity);
                window.addEventListener('touchstart', handleFullscreenActivity);
            } else {
                clearTimeout(uiHideTimeout);
                showControls();
                window.removeEventListener('mousemove', handleFullscreenActivity);
                window.removeEventListener('touchstart', handleFullscreenActivity);
            }
        }

        function handleFullscreenActivity() {
            if (document.fullscreenElement || document.webkitFullscreenElement || document.msFullscreenElement) {
                showControls();
                clearTimeout(uiHideTimeout);
                uiHideTimeout = setTimeout(hideControls, 3000);
            }
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            if (controls) controls.update();

            if (backgroundGroup.visible) {
                backgroundGroup.children[0].material.uniforms.time.value = performance.now() * 0.001;
            }
            
            if (analyser) {
                analyser.getByteFrequencyData(dataArray);
                const bufferLength = analyser.frequencyBinCount;
                
                const lowEnd = Math.floor(bufferLength * 0.1);
                const midEnd = Math.floor(bufferLength * 0.4);
                let lowSum = 0, midSum = 0, highSum = 0;
                for (let i = 0; i < lowEnd; i++) lowSum += dataArray[i];
                for (let i = lowEnd; i < midEnd; i++) midSum += dataArray[i];
                for (let i = midEnd; i < bufferLength; i++) highSum += dataArray[i];

                const audioFeatures = {
                    avgLow: (lowSum / lowEnd) / 255,
                    avgMid: (midSum / (midEnd - lowEnd)) / 255,
                    avgHigh: (highSum / (bufferLength - midEnd)) / 255,
                    avgVolume: (lowSum + midSum + highSum) / bufferLength
                };
                
                // This condition now correctly handles both Three.js and Matrix visualizations
                const currentVis = visualizations[currentVisualizationIndex];
                if (currentVis && (currentVis.group.visible || currentVis.name === "Matrix")) {
                     currentVis.update(dataArray, audioFeatures);
                }
            }

            renderer.render(scene, camera);
        }

        init();
        animate();
    </script>
</body>
</html>

