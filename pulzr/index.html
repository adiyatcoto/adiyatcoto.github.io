<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>PULZR Audioverse</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000000;
            font-family: 'Poppins', sans-serif;
            color: #e5e7eb;
            overscroll-behavior-x: none; /* Prevent horizontal pull-to-refresh/navigation */
        }
        canvas {
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 0;
        }
        #ui-container {
            position: relative;
            z-index: 1;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            pointer-events: none; /* Allows mouse events to pass through to the canvas */
        }
        #initial-prompt, #file-input, #play-button, #visualization-switcher, .ui-button {
            pointer-events: auto; /* Re-enable pointer events for the input itself */
        }
        #initial-prompt h1 {
            color: rgba(255, 255, 255, 0.85);
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.5), 0 0 35px rgba(255, 255, 255, 0.3);
        }
        #initial-prompt p {
             color: rgba(229, 231, 235, 0.75);
             text-shadow: 0 0 8px rgba(229, 231, 235, 0.2);
        }
        #audio-controls {
            position: absolute;
            bottom: 2rem;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
            border-radius: 0.75rem;
            padding: 0.5rem 1rem;
            width: 90%;
            max-width: 500px;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            opacity: 0;
            transition: opacity 0.5s ease-in-out;
            pointer-events: none;
        }
        #audio-controls.visible {
            opacity: 1;
            pointer-events: auto;
        }
        #top-bar {
            position: absolute;
            top: 1rem;
            left: 1rem;
            right: 1rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            opacity: 0;
            transition: opacity 0.5s ease-in-out;
            pointer-events: none;
        }
        #top-bar.visible {
            opacity: 1;
            pointer-events: auto;
        }
        #song-title {
            color: white;
            font-size: 1.1rem;
            font-weight: 500;
            background: rgba(0,0,0,0.3);
            padding: 0.5rem 1.5rem;
            border-radius: 0.5rem;
            backdrop-filter: blur(10px);
            max-width: 50vw;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .ui-button {
            background: rgba(0,0,0,0.3);
            backdrop-filter: blur(10px);
            border-radius: 50%;
            cursor: pointer;
            width: 3rem;
            height: 3rem;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: background 0.2s;
            flex-shrink: 0;
        }
        .ui-button:hover {
            background: rgba(0,0,0,0.5);
        }
        body.fullscreen-active #home-btn {
            display: none;
        }
        #playlist-panel {
            position: absolute;
            top: 0;
            right: 0;
            width: 350px;
            max-width: 80vw;
            height: 100%;
            background: rgba(10, 10, 20, 0.8);
            backdrop-filter: blur(15px);
            transform: translateX(100%);
            transition: transform 0.4s ease-in-out;
            z-index: 20;
            display: flex;
            flex-direction: column;
        }
        #playlist-panel.visible {
            transform: translateX(0);
        }
        #playlist-header {
            padding: 1rem;
            border-bottom: 1px solid rgba(255,255,255,0.1);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        #playlist-header h2 {
            font-size: 1.2rem;
            font-weight: 600;
        }
        #playlist-list {
            list-style: none;
            padding: 0;
            margin: 0;
            flex-grow: 1;
            overflow-y: auto;
        }
        #playlist-list li {
            padding: 0.75rem 1rem;
            cursor: pointer;
            transition: background 0.2s;
            border-bottom: 1px solid rgba(255,255,255,0.05);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        #playlist-list li > span {
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        #playlist-list li:hover {
            background: rgba(255,255,255,0.1);
        }
        #playlist-list li.playing {
            background: rgba(99, 102, 241, 0.5);
            font-weight: 600;
        }
        .remove-track-btn {
            background: none;
            border: none;
            color: #9ca3af; /* gray-400 */
            cursor: pointer;
            padding: 0.25rem;
            border-radius: 50%;
            transition: color 0.2s, background 0.2s;
            flex-shrink: 0; /* Prevent button from shrinking */
            margin-left: 1rem;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .remove-track-btn:hover {
            color: #fca5a5; /* red-300 */
            background: rgba(255, 255, 255, 0.1);
        }

        #visualization-switcher {
            position: absolute;
            bottom: 8.5rem; /* Spacing added */
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            align-items: center;
            gap: 1rem;
            background: rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
            border-radius: 0.5rem;
            padding: 0.5rem 1rem;
            opacity: 0;
            transition: opacity 0.5s ease-in-out;
        }
        #visualization-switcher.visible {
            opacity: 1;
        }
        .arrow-btn {
            background: rgba(255,255,255,0.1);
            border: none;
            color: white;
            padding: 0.5rem;
            border-radius: 50%;
            cursor: pointer;
            transition: background 0.2s;
            width: 2.5rem;
            height: 2.5rem;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-shrink: 0;
        }
        .arrow-btn:hover {
            background: rgba(255,255,255,0.2);
        }
        #vis-name {
            color: white;
            font-weight: 500;
            width: 120px;
            text-align: center;
        }
        
        /* Mobile specific styles */
        @media (max-width: 768px) {
            #fullscreen-btn {
                display: none;
            }

            #playlist-panel {
                width: 100%;
                max-width: 100vw;
                height: 100vh;
                top: 0;
                right: 0;
                border-radius: 0;
                /* Animation from top */
                transform: translateY(-100%);
            }

            #playlist-panel.visible {
                transform: translateY(0);
            }

            #song-title {
                max-width: 40vw;
            }
        }
    </style>
</head>
<body>
    <!-- Canvas for Three.js rendering -->
    <div id="canvas-container"></div>
    <!-- Add the new canvas for the Matrix effect -->
    <canvas id="matrixCanvas" style="display: none;"></canvas>

    <!-- UI Elements -->
    <div id="ui-container">
        <div id="initial-prompt" class="flex flex-col items-center gap-4 p-8">
              <h1 class="text-3xl md:text-6xl font-bold text-white tracking-tighter">P U L Z R</h1>
              <h2 class="text-xl md:text-4xl font-bold text-white tracking-tighter">Interactive Audio Visualization.</h2>
              <p class="text-gray-300 max-w-md mt-2">Upload and play your favorite audio playlist to generate a unique visual universe.</p>
              <div class="mt-6 flex gap-4">
                  <label for="file-input" class="cursor-pointer bg-indigo-600 hover:bg-indigo-500 text-white font-bold py-3 px-6 rounded-lg transition-transform duration-200 hover:scale-105 shadow-lg">
                      Upload Audio
                  </label>
                  <button id="resume-btn" class="hidden cursor-pointer bg-gray-600 hover:bg-gray-500 text-white font-bold py-3 px-6 rounded-lg transition-transform duration-200 hover:scale-105 shadow-lg">
                      Resume Session
                  </button>
              </div>
              <input type="file" id="file-input" class="hidden" multiple accept=".mp3,.wav,.m4a,.aac,audio/*">
        </div>
    </div>
    
    <div id="top-bar" class="pointer-events-none">
        <button id="home-btn" class="ui-button" title="Back to Home">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"/><polyline points="9 22 9 12 15 12 15 22"/></svg>
        </button>
        <div id="song-title"></div>
        <div class="flex items-center gap-4">
            <button id="fullscreen-btn" class="ui-button" title="Toggle Fullscreen">
                <svg id="enter-fullscreen-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"/></svg>
                <svg id="exit-fullscreen-icon" class="hidden" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M8 3v3a2 2 0 0 1-2 2H3m18 0h-3a2 2 0 0 1-2-2V3m0 18v-3a2 2 0 0 1 2-2h3M3 16h3a2 2 0 0 1 2 2v3"/></svg>
            </button>
            <button id="playlist-btn" class="ui-button" title="Toggle Playlist">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="8" y1="6" x2="21" y2="6"/><line x1="8" y1="12" x2="21" y2="12"/><line x1="8" y1="18" x2="21" y2="18"/><line x1="3" y1="6" x2="3.01" y2="6"/><line x1="3" y1="12" x2="3.01" y2="12"/><line x1="3" y1="18" x2="3.01" y2="18"/></svg>
            </button>
        </div>
    </div>

    <!-- Playlist Panel -->
    <div id="playlist-panel">
        <div id="playlist-header">
            <h2>Playlist</h2>
            <div class="flex items-center gap-2">
                <label for="file-input" class="arrow-btn" title="Add Tracks">
                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="12" y1="5" x2="12" y2="19"/><line x1="5" y1="12" x2="19" y2="12"/></svg>
                </label>
                <button id="close-playlist-btn" class="arrow-btn" title="Close Playlist">
                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg>
                </button>
            </div>
        </div>
        <ul id="playlist-list"></ul>
    </div>

    <!-- Audio Player Controls -->
    <div id="audio-controls">
        <button id="prev-track-btn" class="arrow-btn" title="Previous Track">
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="11 19 2 12 11 5 11 19"/><polygon points="22 19 13 12 22 5 22 19"/></svg>
        </button>
        <audio id="audio" controls class="w-full"></audio>
        <button id="next-track-btn" class="arrow-btn" title="Next Track">
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="13 19 22 12 13 5 13 19"/><polygon points="2 19 11 12 2 5 2 19"/></svg>
        </button>
    </div>
    
    <!-- Visualization Switcher -->
    <div id="visualization-switcher">
        <button id="prev-vis" class="arrow-btn">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 18l-6-6 6-6"/></svg>
        </button>
        <div id="vis-name">Particle Sphere</div>
        <button id="next-vis" class="arrow-btn">
             <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9 18l6-6-6-6"/></svg>
        </button>
    </div>
    
    <!-- Footer -->
    <div id="footer" class="absolute bottom-4 w-full text-center text-white text-sm pointer-events-none z-10">
        &copy; Adiyat Coto 2025
    </div>


    <!-- Main script -->
    <script type="module">
        // Import necessary Three.js components
        import * as THREE from 'https://esm.sh/three@0.132.2';
        import { OrbitControls } from 'https://esm.sh/three@0.132.2/examples/jsm/controls/OrbitControls';

        // --- Global Variables ---
        let scene, camera, renderer, controls, analyser, dataArray, audioContext;
        let visualizations = [];
        let currentVisualizationIndex = 0;
        let backgroundGroup;
        let playlist = [];
        let currentTrackIndex = -1;
        let uiHideTimeout;

        const fileInput = document.getElementById('file-input');
        const audio = document.getElementById('audio');
        const initialPrompt = document.getElementById('initial-prompt');
        const resumeBtn = document.getElementById('resume-btn');
        const audioControlsContainer = document.getElementById('audio-controls');
        const canvasContainer = document.getElementById('canvas-container');
        const topBar = document.getElementById('top-bar');
        const songTitleElement = document.getElementById('song-title');
        const visSwitcher = document.getElementById('visualization-switcher');
        const prevVisBtn = document.getElementById('prev-vis');
        const nextVisBtn = document.getElementById('next-vis');
        const visNameElement = document.getElementById('vis-name');
        const footerElement = document.getElementById('footer');
        const homeBtn = document.getElementById('home-btn');
        const playlistBtn = document.getElementById('playlist-btn');
        const playlistPanel = document.getElementById('playlist-panel');
        const playlistList = document.getElementById('playlist-list');
        const closePlaylistBtn = document.getElementById('close-playlist-btn');
        const prevTrackBtn = document.getElementById('prev-track-btn');
        const nextTrackBtn = document.getElementById('next-track-btn');
        const fullscreenBtn = document.getElementById('fullscreen-btn');
        const enterFullscreenIcon = document.getElementById('enter-fullscreen-icon');
        const exitFullscreenIcon = document.getElementById('exit-fullscreen-icon');
        const interactiveUIs = [topBar, audioControlsContainer, visSwitcher];

        // --- Core Functions ---
        
        function createGlowTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 128; canvas.height = 128;
            const context = canvas.getContext('2d');
            const gradient = context.createRadialGradient(64, 64, 0, 64, 64, 64);
            gradient.addColorStop(0, 'rgba(255,255,255,1)');
            gradient.addColorStop(0.2, 'rgba(255,255,255,0.8)');
            gradient.addColorStop(0.5, 'rgba(255,255,255,0.3)');
            gradient.addColorStop(1, 'rgba(255,255,255,0)');
            context.fillStyle = gradient;
            context.fillRect(0, 0, 128, 128);
            return new THREE.CanvasTexture(canvas);
        }

        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 8;
            // Optimization: Use high-performance preference
            renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: 'high-performance' });
            renderer.setSize(window.innerWidth, window.innerHeight);
            // Optimization: Cap pixel ratio on high-DPI devices
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
            canvasContainer.appendChild(renderer.domElement);
            
            backgroundGroup = new THREE.Group();
            const bgGeometry = new THREE.PlaneGeometry(30, 30, 100, 100);
            const bgMaterial = new THREE.ShaderMaterial({
                uniforms: { time: { value: 0 } },
                vertexShader: `
                    uniform float time; varying vec2 vUv;
                    void main() {
                        vUv = uv; vec3 pos = position;
                        float wave1 = sin(pos.x * 2.0 + time * 0.4) * 0.5;
                        float wave2 = sin(pos.y * 3.0 + time * 0.3) * 0.2;
                        float twist = cos(pos.y * 1.0 + time * 0.5) * 0.3;
                        pos.y += wave1 + wave2;
                        pos.z += cos(pos.x * 1.5 + time * 0.2) * 0.3 + twist;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform float time; varying vec2 vUv;
                    float random(vec2 st) { return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123); }
                    float noise(vec2 st) {
                        vec2 i = floor(st); vec2 f = fract(st);
                        float a = random(i); float b = random(i + vec2(1.0, 0.0));
                        float c = random(i + vec2(0.0, 1.0)); float d = random(i + vec2(1.0, 1.0));
                        vec2 u = f * f * (3.0 - 2.0 * f);
                        return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.y * u.x;
                    }
                    void main() {
                        vec3 color1 = vec3(0.8, 0.1, 0.5); vec3 color2 = vec3(0.1, 0.2, 0.9); vec3 color3 = vec3(0.2, 0.8, 0.7);
                        float n = noise(vUv * 3.0 + vec2(0.0, time * -0.1));
                        vec3 mixed = mix(color1, color2, n);
                        vec3 finalColor = mix(mixed, color3, vUv.y * 0.8);
                        float veins = smoothstep(0.7, 0.75, noise(vUv * 8.0 + vec2(0.0, time * -0.2)));
                        finalColor += veins * 0.3;
                        gl_FragColor = vec4(finalColor, 1.0);
                    }
                `,
                side: THREE.DoubleSide
            });
            const bgMesh = new THREE.Mesh(bgGeometry, bgMaterial);
            bgMesh.rotation.x = -Math.PI / 3;
            backgroundGroup.add(bgMesh);
            scene.add(backgroundGroup);

            visualizations.push(new VisParticleSphere());
            visualizations.push(new VisDynamicTerrain());
            visualizations.push(new VisOscillator());
            visualizations.push(new VisFrequencyCanvas());
            visualizations.push(new VisLiquidMarble());
            visualizations.push(new VisStageLights());
            visualizations.push(new VisGrasshopper());
            visualizations.push(new VisMatrix());
            
            visualizations.forEach((vis) => {
                vis.init(scene);
                vis.group.visible = false;
            });
            visNameElement.textContent = visualizations[currentVisualizationIndex].name;

            window.addEventListener('resize', onWindowResize, false);
            fileInput.addEventListener('change', onFileSelect, false);
            homeBtn.addEventListener('click', goHome);
            resumeBtn.addEventListener('click', resumeSession);
            playlistBtn.addEventListener('click', () => playlistPanel.classList.add('visible'));
            closePlaylistBtn.addEventListener('click', () => playlistPanel.classList.remove('visible'));
            audio.addEventListener('ended', playNextTrack);
            prevVisBtn.addEventListener('click', () => switchVisualization(-1));
            nextVisBtn.addEventListener('click', () => switchVisualization(1));
            prevTrackBtn.addEventListener('click', playPreviousTrack);
            nextTrackBtn.addEventListener('click', playNextTrack);
            fullscreenBtn.addEventListener('click', toggleFullscreen);
            document.addEventListener('fullscreenchange', onFullscreenChange);
            document.addEventListener('webkitfullscreenchange', onFullscreenChange);
            document.addEventListener('msfullscreenchange', onFullscreenChange);

            window.addEventListener('click', (event) => {
                if (playlistPanel.classList.contains('visible') && !playlistPanel.contains(event.target) && !playlistBtn.contains(event.target)) {
                    playlistPanel.classList.remove('visible');
                }
            });
        }
        
        // --- Visualization Classes ---
        class VisParticleSphere {
            constructor() {
                this.name = "Particle Sphere";
                this.group = new THREE.Group();
                this.originalPositions = null;
                this.satellites = [];
            }
            init(scene) {
                const geometry = new THREE.IcosahedronGeometry(2.5, 24);
                geometry.setAttribute('color', new THREE.BufferAttribute(new Float32Array(geometry.attributes.position.count * 3), 3));
                this.originalPositions = new Float32Array(geometry.attributes.position.array);
                const material = new THREE.PointsMaterial({
                    size: 0.08,
                    vertexColors: true,
                    map: createGlowTexture(),
                    blending: THREE.AdditiveBlending,
                    transparent: true,
                    depthWrite: false
                });
                this.sphere = new THREE.Points(geometry, material);
                this.group.add(this.sphere);
                const satelliteCount = 150;
                for (let i = 0; i < satelliteCount; i++) {
                    const bufferGeom = new THREE.BufferGeometry();
                    bufferGeom.setAttribute('position', new THREE.BufferAttribute(new Float32Array([0, 0, 0]), 3));
                    const pointMaterial = new THREE.PointsMaterial({
                        size: 0.1,
                        color: 0xffffff,
                        map: createGlowTexture(),
                        blending: THREE.AdditiveBlending,
                        transparent: true,
                        depthWrite: false,
                        opacity: 0
                    });
                    const point = new THREE.Points(bufferGeom, pointMaterial);
                    this.satellites.push({
                        point: point,
                        radius: 4 + Math.random() * 2,
                        speed: 0.002 + Math.random() * 0.008,
                        angle: Math.random() * Math.PI * 2,
                        axis: (new THREE.Vector3(Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5)).normalize(),
                        currentOpacity: 0
                    });
                    this.group.add(point);
                }
                scene.add(this.group);
            }
            update(dataArray, audioFeatures) {
                const positions = this.sphere.geometry.attributes.position.array;
                const colors = this.sphere.geometry.attributes.color.array;
                this.sphere.material.size = 0.03 + (audioFeatures.avgVolume / 255) * 0.1;
                for (let i = 0; i < positions.length; i += 3) {
                    const vertexIndex = i / 3;
                    const dataIndex = (vertexIndex * 2) % dataArray.length;
                    const value = dataArray[dataIndex];
                    const displacement = (value / 255) * 2 * Math.pow(1 - (dataIndex / dataArray.length), 1.5);
                    const p = new THREE.Vector3(this.originalPositions[i], this.originalPositions[i + 1], this.originalPositions[i + 2]);
                    p.normalize().multiplyScalar(1 + displacement);
                    positions[i] = p.x * 2.5;
                    positions[i + 1] = p.y * 2.5;
                    positions[i + 2] = p.z * 2.5;
                    const color = new THREE.Color();
                    const baseHue = 0.65;
                    const finalHue = baseHue - (audioFeatures.avgLow * 0.5);
                    const lightness = 0.5 + audioFeatures.avgLow * 0.4;
                    color.setHSL(finalHue, 0.9, Math.min(lightness, 0.9));
                    colors[i] = color.r;
                    colors[i + 1] = color.g;
                    colors[i + 2] = color.b;
                }
                this.sphere.geometry.attributes.position.needsUpdate = true;
                this.sphere.geometry.attributes.color.needsUpdate = true;
                this.sphere.rotation.y += 0.0008;

                this.satellites.forEach((satellite) => {
                    satellite.angle += satellite.speed;
                    const quaternion = new THREE.Quaternion().setFromAxisAngle(satellite.axis, satellite.angle);
                    const pos = new THREE.Vector3(satellite.radius * (1 + audioFeatures.avgLow * 0.5), 0, 0).applyQuaternion(quaternion);
                    satellite.point.position.copy(pos);
                    
                    const targetOpacity = (audioFeatures.avgMid * 0.6 + audioFeatures.avgHigh * 0.4);

                    satellite.currentOpacity += (targetOpacity - satellite.currentOpacity) * 0.08; // Smoother fade
                    
                    satellite.point.material.opacity = satellite.currentOpacity;
                    satellite.point.material.size = satellite.currentOpacity * (0.05 + audioFeatures.avgHigh * 0.15);
                    
                    const satelliteHue = 0.5;
                    const satelliteLightness = 0.4 + audioFeatures.avgHigh * 0.6;
                    satellite.point.material.color.setHSL(satelliteHue, 1, Math.min(satelliteLightness, 1));
                });
            }
        }
        class VisDynamicTerrain {
            constructor() {
                this.name = "Dynamic Terrain";
                this.group = new THREE.Group();
                this.originalPositions = null;
            }
            init(scene) {
                const segments = 80;
                const geometry = new THREE.PlaneGeometry(15, 15, segments, segments);
                this.plane = new THREE.Mesh(geometry, new THREE.MeshPhongMaterial({
                    vertexColors: true,
                    wireframe: true
                }));
                this.plane.rotation.x = -Math.PI / 2.5;
                this.originalPositions = new Float32Array(geometry.attributes.position.array);
                this.group.add(this.plane);
                const particleGeometry = new THREE.BufferGeometry();
                particleGeometry.setAttribute('position', new THREE.BufferAttribute(new Float32Array((segments + 1) * (segments + 1) * 3), 3));
                this.peakParticles = new THREE.Points(particleGeometry, new THREE.PointsMaterial({
                    size: 0.05,
                    color: 0xffffff,
                    map: createGlowTexture(),
                    blending: THREE.AdditiveBlending,
                    transparent: true,
                    depthWrite: false
                }));
                this.peakParticles.rotation.x = this.plane.rotation.x;
                this.group.add(this.peakParticles);
                this.group.add(new THREE.AmbientLight(0xffffff, 0.2));
                const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
                directionalLight.position.set(0, 1, 0.5);
                this.group.add(directionalLight);
                scene.add(this.group);
            }
            update(dataArray, audioFeatures) {
                const positions = this.plane.geometry.attributes.position.array;
                const particlePositions = this.peakParticles.geometry.attributes.position.array;
                const colors = new Float32Array(positions.length);
                const colorDeep = new THREE.Color(0x0d0d60);
                const colorMid = new THREE.Color(0x1a8cff);
                const colorLand = new THREE.Color(0x00ff00);
                const colorHigh = new THREE.Color(0xffff00);
                const colorPeak = new THREE.Color(0xffffff);
                for (let i = 0; i < positions.length; i += 3) {
                    const zIndex = i + 2;
                    const dataIndex = Math.floor((i / 3) % (dataArray.length * 0.5));
                    const height = (dataArray[dataIndex] / 255) * 3 * audioFeatures.avgLow;
                    positions[zIndex] = this.originalPositions[zIndex] + height;
                    particlePositions[i] = positions[i];
                    particlePositions[i + 1] = positions[i + 1];
                    particlePositions[zIndex] = positions[zIndex] + 0.02;
                    const finalColor = new THREE.Color();
                    const maxHeight = 3.0;
                    const normalizedHeight = Math.min(height / maxHeight, 1.0);
                    if (normalizedHeight < 0.25) {
                        finalColor.lerpColors(colorDeep, colorMid, normalizedHeight / 0.25);
                    } else if (normalizedHeight < 0.5) {
                        finalColor.lerpColors(colorMid, colorLand, (normalizedHeight - 0.25) / 0.25);
                    } else if (normalizedHeight < 0.75) {
                        finalColor.lerpColors(colorLand, colorHigh, (normalizedHeight - 0.5) / 0.25);
                    } else {
                        finalColor.lerpColors(colorHigh, colorPeak, (normalizedHeight - 0.75) / 0.25);
                    }
                    colors[i] = finalColor.r;
                    colors[i + 1] = finalColor.g;
                    colors[i + 2] = finalColor.b;
                }
                this.plane.geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                this.plane.geometry.attributes.position.needsUpdate = true;
                this.peakParticles.geometry.attributes.position.needsUpdate = true;
            }
        }
        class VisOscillator {
            constructor() {
                this.name = "Oscillator";
                this.group = new THREE.Group();
                this.timeDomainArray = null;
                this.trails = [];
                this.trailCount = 16; // Longer ribbon
                this.segmentCount = 256;
            }

            init(scene) {
                for (let i = 0; i < this.trailCount; i++) {
                    const geometry = new THREE.BufferGeometry();
                    const positions = new Float32Array(this.segmentCount * 2 * 3);
                    const colors = new Float32Array(this.segmentCount * 2 * 3);
                    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                    geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                    const material = new THREE.MeshBasicMaterial({
                        side: THREE.DoubleSide,
                        vertexColors: true,
                        transparent: true,
                        opacity: 1.0 - (i / this.trailCount) * 0.8,
                        blending: THREE.AdditiveBlending,
                        depthWrite: false,
                    });
                    const mesh = new THREE.Mesh(geometry, material);
                    this.trails.push(mesh);
                    this.group.add(mesh);
                }
                scene.add(this.group);
            }

            update(dataArray, audioFeatures) {
                if (!analyser) return;
                if (!this.timeDomainArray) {
                    this.timeDomainArray = new Uint8Array(analyser.frequencyBinCount);
                }
                analyser.getByteTimeDomainData(this.timeDomainArray);

                // Shift trail history
                for (let i = this.trailCount - 1; i > 0; i--) {
                    this.trails[i].geometry.attributes.position.array.set(this.trails[i - 1].geometry.attributes.position.array);
                    this.trails[i].geometry.attributes.color.array.set(this.trails[i - 1].geometry.attributes.color.array);
                    this.trails[i].geometry.attributes.position.needsUpdate = true;
                    this.trails[i].geometry.attributes.color.needsUpdate = true;
                }

                const positions = this.trails[0].geometry.attributes.position.array;
                const colors = this.trails[0].geometry.attributes.color.array;
                const ribbonWidth = 0.1; // --- THINNER RIBBON ---
                const time = performance.now() * 0.001;

                for (let i = 0; i < this.segmentCount; i++) {
                    const dataIndex = Math.floor((i / this.segmentCount) * this.timeDomainArray.length);
                    const v = this.timeDomainArray[dataIndex] / 128.0;
                    const y = (v - 1.0) * 2.5;
                    const x = -6 + (i / this.segmentCount) * 12;
                    const z = Math.sin(i * 0.1 + time) * 0.5;

                    positions[i * 6 + 0] = x;
                    positions[i * 6 + 1] = y + ribbonWidth;
                    positions[i * 6 + 2] = z;
                    positions[i * 6 + 3] = x;
                    positions[i * 6 + 4] = y - ribbonWidth;
                    positions[i * 6 + 5] = z;

                    // --- NEW COLOR LOGIC ---
                    const color = new THREE.Color();
                    // Hue cycles through the spectrum over time, and is offset by the waveform height
                    const hue = (performance.now() * 0.00005 + (y / 4)) % 1.0;
                    color.setHSL(hue, 1.0, 0.5);

                    colors[i * 6 + 0] = color.r;
                    colors[i * 6 + 1] = color.g;
                    colors[i * 6 + 2] = color.b;
                    colors[i * 6 + 3] = color.r;
                    colors[i * 6 + 4] = color.g;
                    colors[i * 6 + 5] = color.b;
                }

                const indices = [];
                for (let i = 0; i < this.segmentCount - 1; i++) {
                    const a = i * 2;
                    const b = i * 2 + 1;
                    const c = i * 2 + 2;
                    const d = i * 2 + 3;
                    indices.push(a, b, c);
                    indices.push(b, d, c);
                }
                this.trails[0].geometry.setIndex(indices);
                this.trails[0].geometry.attributes.position.needsUpdate = true;
                this.trails[0].geometry.attributes.color.needsUpdate = true;
                this.trails[0].geometry.computeVertexNormals();
            }
        }
        class VisFrequencyCanvas{constructor(){this.name="Frequency Canvas";this.group=new THREE.Group}init(e){const t=96,i=12,s=new THREE.BufferGeometry,o=new Float32Array(t*t*3),n=new Float32Array(t*t*3);for(let e=0;e<t;e++)for(let a=0;a<t;a++){const r=(e*t+a)*3;o[r]=(a/(t-1)-.5)*i,o[r+1]=(e/(t-1)-.5)*i,o[r+2]=0}s.setAttribute("position",new THREE.BufferAttribute(o,3)),s.setAttribute("color",new THREE.BufferAttribute(n,3));const a=new THREE.PointsMaterial({size:.08,vertexColors:!0,map:createGlowTexture(),blending:THREE.AdditiveBlending,transparent:!0,depthWrite:!1});this.particles=new THREE.Points(s,a),this.group.add(this.particles),this.group.rotation.x=-Math.PI/3,e.add(this.group)}update(e,t){const i=this.particles.geometry.attributes.position.array,s=this.particles.geometry.attributes.color.array,o=Math.sqrt(i.length/3),n=Math.sqrt(.25+.25);for(let t=0;t<o;t++)for(let a=0;a<o;a++){const r=(t*o+a)*3,l=a/(o-1)-.5,h=t/(o-1)-.5,c=Math.sqrt(l*l+h*h),d=Math.pow(c/n,2),u=Math.floor(d*(.75*e.length)),g=e[u]/255;i[r+2]=2*g;const m=new THREE.Color;const p=0.7-0.7*d;const v=0.55+g*0.45;m.setHSL(p,1,v),s[r]=m.r,s[r+1]=m.g,s[r+2]=m.b}this.particles.geometry.attributes.position.needsUpdate=!0,this.particles.geometry.attributes.color.needsUpdate=!0}}
        
        class VisLiquidMarble {
            constructor() {
                this.name = "Liquid Marble";
                this.group = new THREE.Group();
                this.lastHighPeak = 0;
            }
            init(scene) {
                const geometry = new THREE.PlaneGeometry(2, 2); 
                this.material = new THREE.ShaderMaterial({
                    uniforms: {
                        time: { value: 0 },
                        avgLow: { value: 0 },
                        avgMid: { value: 0 },
                        avgHigh: { value: 0 },
                        highPeak: { value: 0 }
                    },
                    vertexShader: `
                        varying vec2 vUv; 
                        void main() { 
                            vUv = uv; 
                            gl_Position = vec4(position, 1.0); 
                        }
                    `,
                    fragmentShader: `
                        uniform float time;
                        uniform float avgLow;
                        uniform float avgMid;
                        uniform float avgHigh;
                        uniform float highPeak;
                        varying vec2 vUv;

                        float random (in vec2 _st) { return fract(sin(dot(_st.xy, vec2(12.9898,78.233))) * 43758.5453123); }
                        float noise (in vec2 _st) {
                            vec2 i = floor(_st); vec2 f = fract(_st);
                            float a = random(i); float b = random(i + vec2(1.0, 0.0));
                            float c = random(i + vec2(0.0, 1.0)); float d = random(i + vec2(1.0, 1.0));
                            vec2 u = f * f * (3.0 - 2.0 * f);
                            return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.y * u.x;
                        }
                        #define NUM_OCTAVES 4 // Optimization: Reduced octaves from 5
                        float fbm ( in vec2 _st) {
                            float v = 0.0; float a = 0.5; vec2 shift = vec2(100.0);
                            mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.50));
                            for (int i = 0; i < NUM_OCTAVES; ++i) { v += a * noise(_st); _st = rot * _st * 2.0 + shift; a *= 0.5; }
                            return v;
                        }

                        void main() {
                            vec2 st = vUv * (2.0 + avgLow * 2.0) - (1.0 + avgLow);
                            st += vec2(sin(time * 0.1), cos(time * 0.1)) * 0.5;
                            vec2 q = vec2(fbm(st + 0.1*time), fbm(st + vec2(1.0)));
                            vec2 r = vec2(fbm(st + 1.0*q + vec2(1.7,9.2)+ 0.15*time), fbm(st + 1.0*q + vec2(8.3,2.8)+ 0.126*time));
                            float f = fbm(st+r);
                            vec3 color = mix(vec3(0.1,0.6,0.7), vec3(0.7,0.7,0.5), clamp((f*f)*4.0,0.0,1.0));
                            color = mix(color, vec3(0.0,0.0,0.16), clamp(length(q),0.0,1.0));
                            color = mix(color, vec3(0.7,1.0,1.0), clamp(length(r.x),0.0,1.0));
                            color *= (f*f*f+.6*f*f+.5*f);
                            
                            float wave = sin(vUv.x * 10.0 + time * 2.0) * 0.3 * avgLow;
                            color *= 1.0 + wave;

                            float lightning = smoothstep(0.3, 0.8, noise(vUv * 10.0 + time * 0.5)) * highPeak * 2.0;
                            color += vec3(0.8, 1.0, 1.0) * lightning;

                            gl_FragColor = vec4(color,1.0);
                        }
                    `
                });
                const mesh = new THREE.Mesh(geometry, this.material);
                this.group.add(mesh);
                scene.add(this.group);
            }
            update(dataArray, audioFeatures) {
                this.material.uniforms.time.value = performance.now() * 0.0005;
                this.material.uniforms.avgLow.value = audioFeatures.avgLow;
                this.material.uniforms.avgMid.value = audioFeatures.avgMid;
                this.material.uniforms.avgHigh.value = audioFeatures.avgHigh;
                
                let highPeakValue = 0;
                if (audioFeatures.avgHigh - this.lastHighPeak > 0.2) {
                    highPeakValue = 1;
                }
                this.material.uniforms.highPeak.value = highPeakValue;
                this.lastHighPeak = audioFeatures.avgHigh;
            }
        }

        class VisStageLights {
            constructor() {
                this.name = "Stage Lights";
                this.group = new THREE.Group();
                this.lights = [];
                this.lastHighs = [0, 0]; // For strobing effect
            }
            init(scene) {
                // Floor to receive the light
                const floorGeometry = new THREE.PlaneGeometry(30, 30);
                const floorMaterial = new THREE.MeshPhongMaterial({ color: 0x1a1a1a, shininess: 50 });
                const floor = new THREE.Mesh(floorGeometry, floorMaterial);
                floor.rotation.x = -Math.PI / 2;
                floor.position.y = -5;
                this.group.add(floor);

                this.ambientLight = new THREE.AmbientLight(0xffffff, 0.1);
                this.group.add(this.ambientLight);

                const lightConfigs = [
                    { color: 0xff4444, position: new THREE.Vector3(-5, 8, 0), type: 'low' },    // Red
                    { color: 0x44ff44, position: new THREE.Vector3(5, 8, 0), type: 'low' },     // Green
                    { color: 0x4444ff, position: new THREE.Vector3(-2.5, 8, -2), type: 'mid' }, // Blue
                    { color: 0xff44ff, position: new THREE.Vector3(2.5, 8, -2), type: 'mid' },  // Magenta
                    { color: 0xffff44, position: new THREE.Vector3(0, 8, 2), type: 'mid' },     // Yellow
                    { color: 0x44ffff, position: new THREE.Vector3(-6, 8, -3), type: 'high' }, // Cyan
                    { color: 0xffffff, position: new THREE.Vector3(6, 8, -3), type: 'high' }   // White
                ];

                lightConfigs.forEach(config => {
                    const spotLight = new THREE.SpotLight(config.color, 0);
                    spotLight.position.copy(config.position);
                    spotLight.angle = Math.PI / 12; // Narrower beam
                    spotLight.penumbra = 0.2;
                    spotLight.decay = 2; // Faster falloff
                    spotLight.distance = 25;

                    // Target for the light
                    spotLight.target.position.set(config.position.x, -5, 0);
                    this.group.add(spotLight);
                    this.group.add(spotLight.target);

                    // Create visible cone "god ray"
                    const lightDistance = spotLight.position.distanceTo(spotLight.target.position);
                    const coneRadius = Math.tan(spotLight.angle) * lightDistance;
                    const coneGeometry = new THREE.ConeGeometry(coneRadius, lightDistance, 32, 1, true); // Open-ended cone
                    coneGeometry.translate(0, -lightDistance / 2, 0); // Move pivot to the top
                    coneGeometry.rotateX(Math.PI); // Point it down

                    const coneMaterial = new THREE.MeshBasicMaterial({
                        color: config.color,
                        transparent: true,
                        opacity: 0, // Start invisible
                        blending: THREE.AdditiveBlending,
                        side: THREE.DoubleSide,
                        depthWrite: false,
                    });
                    const coneMesh = new THREE.Mesh(coneGeometry, coneMaterial);
                    coneMesh.position.copy(spotLight.position);
                    this.group.add(coneMesh);

                    this.lights.push({ 
                        light: spotLight, 
                        cone: coneMesh,
                        type: config.type, 
                        lastIntensity: 0
                    });
                });

                scene.add(this.group);
            }
            update(dataArray, audioFeatures) {
                const time = performance.now() * 0.001;
                this.ambientLight.intensity = 0.05 + audioFeatures.avgVolume * 0.1;
                
                this.lights.forEach((lightObj, index) => {
                    const { light, cone, type } = lightObj;
                    
                    // More dynamic "disco" movement
                    light.target.position.x = Math.sin(time * 0.8 + index * 1.5) * 6;
                    light.target.position.z = Math.cos(time * 0.6 + index * 1.1) * 6;
                    
                    let targetIntensity = 0;

                    switch (type) {
                        case 'low':
                            targetIntensity = Math.pow(audioFeatures.avgLow, 1.5) * 8.0;
                            break;
                        case 'mid':
                            targetIntensity = Math.pow(audioFeatures.avgMid, 2) * 6.0;
                            break;
                        case 'high':
                            if (audioFeatures.avgHigh > 0.6 && lightObj.lastIntensity <= 0.6) {
                                targetIntensity = 12.0; // Flash brightly on beat
                            } else {
                                targetIntensity = light.intensity * 0.8; // Fast decay
                            }
                            lightObj.lastIntensity = audioFeatures.avgHigh;
                            break;
                    }
                    
                    light.intensity += (Math.min(targetIntensity, 12.0) - light.intensity) * 0.15; // Smoothed intensity change
                    
                    // Update the visible cone
                    cone.lookAt(light.target.position);
                    cone.material.opacity = light.intensity / 12.0 * 0.2; // Opacity is a fraction of the intensity
                });
            }
        }

        class VisGrasshopper {
            constructor() {
                this.name = "Grasshopper";
                this.group = new THREE.Group();
            }
            init(scene) {
                const geometry = new THREE.PlaneGeometry(2, 2);
                this.material = new THREE.ShaderMaterial({
                    uniforms: {
                        time: { value: 0 },
                        resolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
                        avgLow: { value: 0 },
                        avgMid: { value: 0 },
                        avgHigh: { value: 0 },
                    },
                    vertexShader: `
                        varying vec2 vUv;
                        void main() {
                            vUv = uv;
                            gl_Position = vec4(position, 1.0);
                        }
                    `,
                    fragmentShader: `
                        uniform vec2 resolution;
                        uniform float time;
                        uniform float avgLow;
                        uniform float avgMid;
                        uniform float avgHigh;
                        varying vec2 vUv;

                        float random (in vec2 _st) { return fract(sin(dot(_st.xy, vec2(12.9898,78.233))) * 43758.5453123); }

                        float noise (in vec2 _st) {
                            vec2 i = floor(_st);
                            vec2 f = fract(_st);
                            float a = random(i);
                            float b = random(i + vec2(1.0, 0.0));
                            float c = random(i + vec2(0.0, 1.0));
                            float d = random(i + vec2(1.0, 1.0));
                            vec2 u = f * f * (3.0 - 2.0 * f);
                            return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.y * u.x;
                        }

                        #define NUM_OCTAVES 4 // Optimization: Reduced octaves from 6
                        float fbm ( in vec2 _st) {
                            float v = 0.0;
                            float a = 0.5;
                            vec2 shift = vec2(100.0);
                            mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.50));
                            for (int i = 0; i < NUM_OCTAVES; ++i) {
                                v += a * noise(_st);
                                _st = rot * _st * 2.0 + shift;
                                a *= 0.5;
                            }
                            return v;
                        }

                        void main() {
                            vec2 st = vUv * 5.0;
                            
                            vec2 wind_uv = vUv * vec2(2.0, 0.5) + vec2(time * 0.2, time * 0.1);
                            float wind_pattern = noise(wind_uv) - 0.5;
                            
                            float wind_strength = 0.2 + avgLow * 0.5;
                            
                            st.x += wind_pattern * wind_strength;
                            
                            float pattern = fbm(st);
                            
                            vec3 grass_dark = vec3(0.1, 0.3, 0.05);
                            vec3 grass_light = vec3(0.4, 0.8, 0.2);
                            vec3 grass_dry = vec3(0.6, 0.5, 0.1);

                            vec3 color = mix(grass_dark, grass_light, smoothstep(0.4, 0.6, pattern));
                            color = mix(color, grass_dry, smoothstep(0.6, 0.65, pattern));

                            color.g += avgMid * 0.2;
                            color.r += avgMid * 0.1;

                            float sparkle = pow(noise(st * 20.0 + time), 10.0) * avgHigh * 1.5;
                            color += vec3(0.8, 1.0, 0.7) * sparkle;
                            
                            color *= smoothstep(1.0, 0.3, length(vUv - 0.5));

                            gl_FragColor = vec4(color, 1.0);
                        }
                    `
                });
                const mesh = new THREE.Mesh(geometry, this.material);
                this.group.add(mesh);
                scene.add(this.group);
                window.addEventListener('resize', () => {
                    this.material.uniforms.resolution.value.set(window.innerWidth, window.innerHeight);
                });
            }
            update(dataArray, audioFeatures) {
                this.material.uniforms.time.value = performance.now() * 0.001;
                this.material.uniforms.avgLow.value = audioFeatures.avgLow;
                this.material.uniforms.avgMid.value = audioFeatures.avgMid;
                this.material.uniforms.avgHigh.value = audioFeatures.avgHigh;
            }
        }

        class VisMatrix {
            constructor() {
                this.name = "Matrix";
                this.group = new THREE.Group(); // Kept for API compatibility
                this.canvas = null;
                this.ctx = null;
                this.drops = [];
                this.columns = 0;
                this.fontSize = 16;
                this.animationInterval = null;
                this.dataArray = null; // To store frequency data
                this.characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
            }

            init() {
                this.canvas = document.getElementById('matrixCanvas');
                if (!this.canvas) return; // Fail gracefully
                this.ctx = this.canvas.getContext('2d');
                // Initial setup for when it's first displayed
                this.setupCanvas(); 
                window.addEventListener('resize', () => {
                    // Only resize if it's currently visible
                    if (this.canvas.style.display === 'block') {
                        this.setupCanvas();
                    }
                }, false);
            }

            setupCanvas() {
                if (!this.canvas) return;
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
                this.columns = Math.floor(this.canvas.width / this.fontSize);
                this.drops = [];
                for (let x = 0; x < this.columns; x++) {
                    // Randomize starting position for a more natural look
                    this.drops[x] = 1 + Math.random() * 100; 
                }
            }

            draw() {
                if (!this.ctx || !this.dataArray) return;
                
                // The fading trail effect
                this.ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                this.ctx.font = this.fontSize + 'px monospace';

                for (let i = 0; i < this.drops.length; i++) {
                    // --- DYNAMIC FREQUENCY-BASED LOGIC ---

                    // 1. Map column to a frequency bin (left=low, right=high)
                    // We use about 75% of the spectrum as the highest frequencies are often quiet.
                    const freqIndex = Math.floor((i / this.drops.length) * (this.dataArray.length * 0.75));
                    const freqValue = this.dataArray[freqIndex] || 0;
                    const normalizedFreq = freqValue / 255; // Value from 0.0 to 1.0

                    // 2. Set character, position, color, and glow based on frequency
                    const text = this.characters.charAt(Math.floor(Math.random() * this.characters.length));
                    const x = i * this.fontSize;
                    const y = this.drops[i] * this.fontSize;
                    
                    const greenIntensity = 100 + Math.floor(normalizedFreq * 155);
                    this.ctx.fillStyle = `rgb(0, ${greenIntensity}, 0)`;
                    
                    const glowAmount = normalizedFreq * 15;
                    this.ctx.shadowBlur = glowAmount;
                    this.ctx.shadowColor = 'rgba(100, 255, 100, 0.5)';
                    
                    this.ctx.fillText(text, x, y);

                    // Add a bright white flash for audio peaks
                    if (normalizedFreq > 0.8) {
                        const shineAlpha = (normalizedFreq - 0.8) / 0.2; // Opacity from 0 to 1
                        this.ctx.fillStyle = `rgba(255, 255, 255, ${shineAlpha})`;
                        this.ctx.shadowBlur = 5 + shineAlpha * 10;
                        this.ctx.shadowColor = 'rgba(255, 255, 255, 0.7)';
                        this.ctx.fillText(text, x, y);
                    }
                    this.ctx.shadowBlur = 0; // Reset shadow for next character

                    // 3. Reset drop position based on frequency intensity
                    // Louder frequencies have a higher chance to start a new drop
                    if (y > this.canvas.height && Math.random() < normalizedFreq * 0.05) {
                        this.drops[i] = 0;
                    }

                    // 4. Set drop speed based on frequency with higher contrast
                    const speed = 0.5 + Math.pow(normalizedFreq, 2) * 15;
                    this.drops[i] += speed;
                }
            }

            start() {
                if (this.animationInterval) return; // Already running
                this.setupCanvas(); // Ensure it's sized correctly
                this.canvas.style.display = 'block';
                // Run draw at a consistent speed
                this.animationInterval = setInterval(() => this.draw(), 40);
            }

            stop() {
                if (!this.animationInterval) return; // Already stopped
                this.canvas.style.display = 'none';
                clearInterval(this.animationInterval);
                this.animationInterval = null;
            }
            
            update(dataArray, audioFeatures) {
                // Store the latest full frequency data array for the draw() loop to use
                this.dataArray = dataArray;
            }
        }


        // --- Event Handlers & Audio Setup ---
        
        function goHome() {
            // BUG FIX: Check if in fullscreen and exit if necessary before resetting UI
            if (document.fullscreenElement || document.webkitFullscreenElement || document.msFullscreenElement) {
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                } else if (document.webkitExitFullscreen) { /* Safari */
                    document.webkitExitFullscreen();
                } else if (document.msExitFullscreen) { /* IE11 */
                    document.msExitFullscreen();
                }
            }
            
            audio.pause();
            
            // Explicitly stop Matrix vis if it's active and show the 3D canvas
            if (visualizations[currentVisualizationIndex].name === "Matrix") {
                visualizations[currentVisualizationIndex].stop();
            }
            renderer.domElement.style.display = 'block';

            visualizations.forEach(vis => vis.group.visible = false);
            audioControlsContainer.classList.remove('visible');
            visSwitcher.classList.remove('visible');
            topBar.classList.remove('visible');
            playlistPanel.classList.remove('visible');

            initialPrompt.style.display = 'flex';
            footerElement.style.display = 'block';
            backgroundGroup.visible = true;
            
            updateHomepageUI();
        }

        function resumeSession() {
            // SAFARI/MOBILE FIX: Resume audio context on user interaction
            if (audioContext && audioContext.state === 'suspended') {
                audioContext.resume();
            }

            initialPrompt.style.display = 'none';
            footerElement.style.display = 'none';
            backgroundGroup.visible = false;

            const currentVis = visualizations[currentVisualizationIndex];
            if (currentVis.name === "Matrix") {
                renderer.domElement.style.display = 'none';
                currentVis.start();
            } else {
                renderer.domElement.style.display = 'block';
                currentVis.group.visible = true;
            }

            audioControlsContainer.classList.add('visible');
            visSwitcher.classList.add('visible');
            topBar.classList.add('visible');
            if(currentTrackIndex !== -1) audio.play();
        }

        function updateHomepageUI() {
            if (playlist.length > 0) {
                resumeBtn.style.display = 'block';
            } else {
                resumeBtn.style.display = 'none';
            }
        }

        function switchVisualization(direction) {
            const oldIndex = currentVisualizationIndex;
            const oldVis = visualizations[oldIndex];
            
            currentVisualizationIndex = (currentVisualizationIndex + direction + visualizations.length) % visualizations.length;
            const newVis = visualizations[currentVisualizationIndex];

            // Deactivate old visualization
            if (oldVis.name === "Matrix") {
                oldVis.stop();
                renderer.domElement.style.display = 'block'; // Show 3D canvas
            } else {
                oldVis.group.visible = false;
            }

            // Activate new visualization
            if (newVis.name === "Matrix") {
                newVis.start();
                renderer.domElement.style.display = 'none'; // Hide 3D canvas
            } else {
                newVis.group.visible = true;
            }
            
            visNameElement.textContent = newVis.name;
        }

        function setupAudioContext() {
            if (audioContext) return;
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            const source = audioContext.createMediaElementSource(audio);
            analyser = audioContext.createAnalyser();
            analyser.fftSize = 1024; // Optimization: Reduced from 2048
            analyser.minDecibels = -90;
            analyser.maxDecibels = -10;
            analyser.smoothingTimeConstant = 0.85;
            dataArray = new Uint8Array(analyser.frequencyBinCount);
            source.connect(analyser);
            analyser.connect(audioContext.destination);
        }

        function onFileSelect(event) {
            const newFiles = Array.from(event.target.files);
            if (newFiles.length === 0) return;

            // --- KEY FIX FOR MOBILE/SAFARI ---
            // Ensure AudioContext is created and resumed within this user gesture.
            if (!audioContext) {
                setupAudioContext();
            }
            if (audioContext.state === 'suspended') {
                audioContext.resume();
            }
            // --- END FIX ---

            const wasPlaylistEmpty = playlist.length === 0;
            const isFromHomepage = initialPrompt.style.display !== 'none';

            newFiles.forEach(file => {
                playlist.push({
                    name: file.name,
                    url: URL.createObjectURL(file)
                });
            });

            renderPlaylist();

            if (!controls) {
                controls = new OrbitControls(camera, renderer.domElement);
                controls.enableDamping = true;
                controls.dampingFactor = 0.05;
                controls.enablePan = false; // Disable panning for a cleaner mobile experience
            }

            if (isFromHomepage) {
                resumeSession();
                playlistPanel.classList.add('visible');
                if (wasPlaylistEmpty) {
                    playTrack(0);
                }
            }
            
            fileInput.value = '';
        }

        function playTrack(index) {
            if (index < 0 || index >= playlist.length) return;
            currentTrackIndex = index;
            audio.src = playlist[index].url;
            audio.play();
            songTitleElement.textContent = playlist[index].name;
            renderPlaylist();
        }

        function playNextTrack() {
            if (playlist.length === 0) return;
            let nextIndex = currentTrackIndex + 1;
            if (nextIndex >= playlist.length) {
                nextIndex = 0;
            }
            playTrack(nextIndex);
        }

        function playPreviousTrack() {
            if (playlist.length === 0) return;
            let prevIndex = currentTrackIndex - 1;
            if (prevIndex < 0) {
                prevIndex = playlist.length - 1;
            }
            playTrack(prevIndex);
        }
        
        function removeTrack(index) {
            if (index < 0 || index >= playlist.length) return;

            const isCurrentlyPlaying = (index === currentTrackIndex);
            playlist.splice(index, 1);

            if (isCurrentlyPlaying) {
                audio.pause();
                audio.src = '';
                songTitleElement.textContent = 'Select a track';
                currentTrackIndex = -1; 
            } 
            else if (index < currentTrackIndex) {
                currentTrackIndex--; 
            }

            if (playlist.length === 0) {
                goHome();
            } else {
                renderPlaylist();
            }
        }

        function renderPlaylist() {
            playlistList.innerHTML = '';
            playlist.forEach((track, index) => {
                const li = document.createElement('li');
                
                const trackName = document.createElement('span');
                trackName.textContent = track.name;
                li.appendChild(trackName);

                const removeBtn = document.createElement('button');
                removeBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg>`;
                removeBtn.className = 'remove-track-btn';
                removeBtn.title = 'Remove track';
                
                removeBtn.addEventListener('click', (event) => {
                    event.stopPropagation();
                    removeTrack(index);
                });
                li.appendChild(removeBtn);

                if (index === currentTrackIndex) {
                    li.classList.add('playing');
                }
                li.addEventListener('click', () => playTrack(index));
                playlistList.appendChild(li);
            });
        }
        
        function toggleFullscreen() {
            if (!document.fullscreenElement && !document.webkitFullscreenElement && !document.msFullscreenElement) {
                const elem = document.documentElement;
                if (elem.requestFullscreen) {
                    elem.requestFullscreen().catch(err => console.error(`Error attempting to enable full-screen mode: ${err.message} (${err.name})`));
                } else if (elem.webkitRequestFullscreen) { /* Safari */
                    elem.webkitRequestFullscreen();
                } else if (elem.msRequestFullscreen) { /* IE11 */
                    elem.msRequestFullscreen();
                }
            } else {
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                } else if (document.webkitExitFullscreen) { /* Safari */
                    document.webkitExitFullscreen();
                } else if (document.msExitFullscreen) { /* IE11 */
                    document.msExitFullscreen();
                }
            }
        }

        function showControls() {
            interactiveUIs.forEach(el => el.classList.add('visible'));
        }
        
        function hideControls() {
            interactiveUIs.forEach(el => el.classList.remove('visible'));
        }

        function onFullscreenChange() {
            const isFullscreen = !!(document.fullscreenElement || document.webkitFullscreenElement || document.msFullscreenElement);
            document.body.classList.toggle('fullscreen-active', isFullscreen);

            enterFullscreenIcon.classList.toggle('hidden', isFullscreen);
            exitFullscreenIcon.classList.toggle('hidden', !isFullscreen);

            if (isFullscreen) {
                uiHideTimeout = setTimeout(hideControls, 3000);
                window.addEventListener('mousemove', handleFullscreenActivity);
                window.addEventListener('touchstart', handleFullscreenActivity);
            } else {
                clearTimeout(uiHideTimeout);
                showControls();
                window.removeEventListener('mousemove', handleFullscreenActivity);
                window.removeEventListener('touchstart', handleFullscreenActivity);
            }
        }

        function handleFullscreenActivity() {
            if (document.fullscreenElement || document.webkitFullscreenElement || document.msFullscreenElement) {
                showControls();
                clearTimeout(uiHideTimeout);
                uiHideTimeout = setTimeout(hideControls, 3000);
            }
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            if (controls) controls.update();

            if (backgroundGroup.visible) {
                backgroundGroup.children[0].material.uniforms.time.value = performance.now() * 0.001;
            }
            
            if (analyser) {
                analyser.getByteFrequencyData(dataArray);
                const bufferLength = analyser.frequencyBinCount;
                
                const lowEnd = Math.floor(bufferLength * 0.1);
                const midEnd = Math.floor(bufferLength * 0.4);
                let lowSum = 0, midSum = 0, highSum = 0;
                for (let i = 0; i < lowEnd; i++) lowSum += dataArray[i];
                for (let i = lowEnd; i < midEnd; i++) midSum += dataArray[i];
                for (let i = midEnd; i < bufferLength; i++) highSum += dataArray[i];

                const audioFeatures = {
                    avgLow: (lowSum / lowEnd) / 255,
                    avgMid: (midSum / (midEnd - lowEnd)) / 255,
                    avgHigh: (highSum / (bufferLength - midEnd)) / 255,
                    avgVolume: (lowSum + midSum + highSum) / bufferLength
                };
                
                // This condition now correctly handles both Three.js and Matrix visualizations
                const currentVis = visualizations[currentVisualizationIndex];
                if (currentVis && (currentVis.group.visible || (currentVis.name === "Matrix" && currentVis.animationInterval))) {
                       currentVis.update(dataArray, audioFeatures);
                }
            }

            renderer.render(scene, camera);
        }

        init();
        animate();
    </script>
</body>
</html>

