<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>PULZR Audioverse</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000000;
            font-family: 'Poppins', sans-serif;
            color: #e5e7eb;
            overscroll-behavior-x: none; /* Prevent horizontal pull-to-refresh/navigation */
        }
        canvas {
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 0;
        }
        #ui-container {
            position: relative;
            z-index: 1;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            pointer-events: none; /* Allows mouse events to pass through to the canvas */
        }
        #initial-prompt, #file-input, #play-button, #visualization-switcher, .ui-button {
            pointer-events: auto; /* Re-enable pointer events for the input itself */
        }
        #initial-prompt h1 {
            color: rgba(255, 255, 255, 0.85);
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.5), 0 0 35px rgba(255, 255, 255, 0.3);
        }
        #initial-prompt p {
             color: rgba(229, 231, 235, 0.75);
             text-shadow: 0 0 8px rgba(229, 231, 235, 0.2);
        }
        #audio-controls {
            position: absolute;
            bottom: 2rem;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
            border-radius: 0.75rem;
            padding: 0.5rem 1rem;
            width: 90%;
            max-width: 500px;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            opacity: 0;
            transition: opacity 0.5s ease-in-out;
            pointer-events: none;
        }
        #audio-controls.visible {
            opacity: 1;
            pointer-events: auto;
        }
        #top-bar {
            position: absolute;
            top: 1rem;
            left: 1rem;
            right: 1rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            opacity: 0;
            transition: opacity 0.5s ease-in-out;
            pointer-events: none;
        }
        #top-bar.visible {
            opacity: 1;
            pointer-events: auto;
        }
        #song-title {
            color: white;
            font-size: 1.1rem;
            font-weight: 500;
            background: rgba(0,0,0,0.3);
            padding: 0.5rem 1.5rem;
            border-radius: 0.5rem;
            backdrop-filter: blur(10px);
            max-width: 50vw;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .ui-button {
            background: rgba(0,0,0,0.3);
            backdrop-filter: blur(10px);
            border-radius: 50%;
            cursor: pointer;
            width: 3rem;
            height: 3rem;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: background 0.2s;
            flex-shrink: 0;
        }
        .ui-button:hover {
            background: rgba(0,0,0,0.5);
        }
        body.fullscreen-active #home-btn {
            display: none;
        }
        #playlist-panel {
            position: absolute;
            top: 0;
            right: 0;
            width: 350px;
            max-width: 80vw;
            height: 100%;
            background: rgba(10, 10, 20, 0.8);
            backdrop-filter: blur(15px);
            transform: translateX(100%);
            transition: transform 0.4s ease-in-out;
            z-index: 20;
            display: flex;
            flex-direction: column;
        }
        #playlist-panel.visible {
            transform: translateX(0);
        }
        #playlist-header {
            padding: 1rem;
            border-bottom: 1px solid rgba(255,255,255,0.1);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        #playlist-header h2 {
            font-size: 1.2rem;
            font-weight: 600;
        }
        #playlist-list {
            list-style: none;
            padding: 0;
            margin: 0;
            flex-grow: 1;
            overflow-y: auto;
        }
        #playlist-list li {
            padding: 0.75rem 1rem;
            cursor: pointer;
            transition: background 0.2s;
            border-bottom: 1px solid rgba(255,255,255,0.05);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        #playlist-list li > span {
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        #playlist-list li:hover {
            background: rgba(255,255,255,0.1);
        }
        #playlist-list li.playing {
            background: rgba(99, 102, 241, 0.5);
            font-weight: 600;
        }
        .remove-track-btn {
            background: none;
            border: none;
            color: #9ca3af; /* gray-400 */
            cursor: pointer;
            padding: 0.25rem;
            border-radius: 50%;
            transition: color 0.2s, background 0.2s;
            flex-shrink: 0; /* Prevent button from shrinking */
            margin-left: 1rem;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .remove-track-btn:hover {
            color: #fca5a5; /* red-300 */
            background: rgba(255, 255, 255, 0.1);
        }

        #visualization-switcher {
            position: absolute;
            bottom: 8.5rem; /* Spacing added */
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            align-items: center;
            gap: 1rem;
            background: rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
            border-radius: 0.5rem;
            padding: 0.5rem 1rem;
            opacity: 0;
            transition: opacity 0.5s ease-in-out;
        }
        #visualization-switcher.visible {
            opacity: 1;
        }
        .arrow-btn {
            background: rgba(255,255,255,0.1);
            border: none;
            color: white;
            padding: 0.5rem;
            border-radius: 50%;
            cursor: pointer;
            transition: background 0.2s;
            width: 2.5rem;
            height: 2.5rem;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-shrink: 0;
        }
        .arrow-btn:hover {
            background: rgba(255,255,255,0.2);
        }
        #vis-name {
            color: white;
            font-weight: 500;
            width: 120px;
            text-align: center;
        }
        
        /* Mobile specific styles */
        @media (max-width: 768px) {
            #fullscreen-btn {
                display: none;
            }

            #playlist-panel {
                width: 100%;
                max-width: 100vw;
                height: 100vh;
                top: 0;
                right: 0;
                border-radius: 0;
                /* Animation from top */
                transform: translateY(-100%);
            }

            #playlist-panel.visible {
                transform: translateY(0);
            }

            #song-title {
                max-width: 40vw;
            }
        }
    </style>
</head>
<body>
    <!-- Canvas for Three.js rendering -->
    <div id="canvas-container"></div>
    <!-- Add the new canvas for the Matrix effect -->
    <canvas id="matrixCanvas" style="display: none;"></canvas>

    <!-- UI Elements -->
    <div id="ui-container">
        <div id="initial-prompt" class="flex flex-col items-center gap-4 p-8">
              <h1 class="text-3xl md:text-6xl font-bold text-white tracking-tighter">P U L Z R</h1>
              <h2 class="text-xl md:text-4xl font-bold text-white tracking-tighter">Interactive Audio Visualization.</h2>
              <p class="text-gray-300 max-w-md mt-2">Upload and play your favorite audio playlist to generate a unique visual universe.</p>
              <div class="mt-6 flex gap-4">
                  <label for="file-input" class="cursor-pointer bg-indigo-600 hover:bg-indigo-500 text-white font-bold py-3 px-6 rounded-lg transition-transform duration-200 hover:scale-105 shadow-lg">
                      Upload Audio
                  </label>
                  <button id="resume-btn" class="hidden cursor-pointer bg-gray-600 hover:bg-gray-500 text-white font-bold py-3 px-6 rounded-lg transition-transform duration-200 hover:scale-105 shadow-lg">
                      Resume Session
                  </button>
              </div>
              <input type="file" id="file-input" class="hidden" multiple accept=".mp3,.wav,.m4a,.aac,audio/*">
        </div>
    </div>
    
    <div id="top-bar" class="pointer-events-none">
        <button id="home-btn" class="ui-button" title="Back to Home">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"/><polyline points="9 22 9 12 15 12 15 22"/></svg>
        </button>
        <div id="song-title"></div>
        <div class="flex items-center gap-4">
            <button id="fullscreen-btn" class="ui-button" title="Toggle Fullscreen">
                <svg id="enter-fullscreen-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"/></svg>
                <svg id="exit-fullscreen-icon" class="hidden" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M8 3v3a2 2 0 0 1-2 2H3m18 0h-3a2 2 0 0 1-2-2V3m0 18v-3a2 2 0 0 1 2-2h3M3 16h3a2 2 0 0 1 2 2v3"/></svg>
            </button>
            <button id="playlist-btn" class="ui-button" title="Toggle Playlist">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="8" y1="6" x2="21" y2="6"/><line x1="8" y1="12" x2="21" y2="12"/><line x1="8" y1="18" x2="21" y2="18"/><line x1="3" y1="6" x2="3.01" y2="6"/><line x1="3" y1="12" x2="3.01" y2="12"/><line x1="3" y1="18" x2="3.01" y2="18"/></svg>
            </button>
        </div>
    </div>

    <!-- Playlist Panel -->
    <div id="playlist-panel">
        <div id="playlist-header">
            <h2>Playlist</h2>
            <div class="flex items-center gap-2">
                <label for="file-input" class="arrow-btn" title="Add Tracks">
                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="12" y1="5" x2="12" y2="19"/><line x1="5" y1="12" x2="19" y2="12"/></svg>
                </label>
                <button id="close-playlist-btn" class="arrow-btn" title="Close Playlist">
                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg>
                </button>
            </div>
        </div>
        <ul id="playlist-list"></ul>
    </div>

    <!-- Audio Player Controls -->
    <div id="audio-controls">
        <button id="prev-track-btn" class="arrow-btn" title="Previous Track">
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="11 19 2 12 11 5 11 19"/><polygon points="22 19 13 12 22 5 22 19"/></svg>
        </button>
        <audio id="audio" controls class="w-full"></audio>
        <button id="next-track-btn" class="arrow-btn" title="Next Track">
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="13 19 22 12 13 5 13 19"/><polygon points="2 19 11 12 2 5 2 19"/></svg>
        </button>
    </div>
    
    <!-- Visualization Switcher -->
    <div id="visualization-switcher">
        <button id="prev-vis" class="arrow-btn">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 18l-6-6 6-6"/></svg>
        </button>
        <div id="vis-name">Particle Sphere</div>
        <button id="next-vis" class="arrow-btn">
             <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9 18l6-6-6-6"/></svg>
        </button>
    </div>
    
    <!-- Footer -->
    <div id="footer" class="absolute bottom-4 w-full text-center text-white text-sm pointer-events-none z-10">
        &copy; Adiyat Coto 2025
    </div>


    <!-- Main script -->
    <script type="module">
        // Import necessary Three.js components
        import * as THREE from 'https://esm.sh/three@0.132.2';
        import { OrbitControls } from 'https://esm.sh/three@0.132.2/examples/jsm/controls/OrbitControls';

        // --- Global Variables ---
        let scene, camera, renderer, controls, analyser, dataArray, audioContext;
        let visualizations = [];
        let currentVisualizationIndex = 0;
        let backgroundGroup;
        let playlist = [];
        let currentTrackIndex = -1;
        let uiHideTimeout;

        const fileInput = document.getElementById('file-input');
        const audio = document.getElementById('audio');
        const initialPrompt = document.getElementById('initial-prompt');
        const resumeBtn = document.getElementById('resume-btn');
        const audioControlsContainer = document.getElementById('audio-controls');
        const canvasContainer = document.getElementById('canvas-container');
        const topBar = document.getElementById('top-bar');
        const songTitleElement = document.getElementById('song-title');
        const visSwitcher = document.getElementById('visualization-switcher');
        const prevVisBtn = document.getElementById('prev-vis');
        const nextVisBtn = document.getElementById('next-vis');
        const visNameElement = document.getElementById('vis-name');
        const footerElement = document.getElementById('footer');
        const homeBtn = document.getElementById('home-btn');
        const playlistBtn = document.getElementById('playlist-btn');
        const playlistPanel = document.getElementById('playlist-panel');
        const playlistList = document.getElementById('playlist-list');
        const closePlaylistBtn = document.getElementById('close-playlist-btn');
        const prevTrackBtn = document.getElementById('prev-track-btn');
        const nextTrackBtn = document.getElementById('next-track-btn');
        const fullscreenBtn = document.getElementById('fullscreen-btn');
        const enterFullscreenIcon = document.getElementById('enter-fullscreen-icon');
        const exitFullscreenIcon = document.getElementById('exit-fullscreen-icon');
        const interactiveUIs = [topBar, audioControlsContainer, visSwitcher];

        // --- Core Functions ---
        
        function createGlowTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 128; canvas.height = 128;
            const context = canvas.getContext('2d');
            const gradient = context.createRadialGradient(64, 64, 0, 64, 64, 64);
            gradient.addColorStop(0, 'rgba(255,255,255,1)');
            gradient.addColorStop(0.2, 'rgba(255,255,255,0.8)');
            gradient.addColorStop(0.5, 'rgba(255,255,255,0.3)');
            gradient.addColorStop(1, 'rgba(255,255,255,0)');
            context.fillStyle = gradient;
            context.fillRect(0, 0, 128, 128);
            return new THREE.CanvasTexture(canvas);
        }

        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 8;
            // Optimization: Use high-performance preference
            renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: 'high-performance' });
            renderer.setSize(window.innerWidth, window.innerHeight);
            // Optimization: Cap pixel ratio on high-DPI devices
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
            canvasContainer.appendChild(renderer.domElement);
            
            backgroundGroup = new THREE.Group();
            const bgGeometry = new THREE.PlaneGeometry(30, 30, 100, 100);
            const bgMaterial = new THREE.ShaderMaterial({
                uniforms: { time: { value: 0 } },
                vertexShader: `
                    uniform float time; varying vec2 vUv;
                    void main() {
                        vUv = uv; vec3 pos = position;
                        float wave1 = sin(pos.x * 2.0 + time * 0.4) * 0.5;
                        float wave2 = sin(pos.y * 3.0 + time * 0.3) * 0.2;
                        float twist = cos(pos.y * 1.0 + time * 0.5) * 0.3;
                        pos.y += wave1 + wave2;
                        pos.z += cos(pos.x * 1.5 + time * 0.2) * 0.3 + twist;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform float time; varying vec2 vUv;
                    float random(vec2 st) { return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123); }
                    float noise(vec2 st) {
                        vec2 i = floor(st); vec2 f = fract(st);
                        float a = random(i); float b = random(i + vec2(1.0, 0.0));
                        float c = random(i + vec2(0.0, 1.0)); float d = random(i + vec2(1.0, 1.0));
                        vec2 u = f * f * (3.0 - 2.0 * f);
                        return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.y * u.x;
                    }
                    void main() {
                        vec3 color1 = vec3(0.8, 0.1, 0.5); vec3 color2 = vec3(0.1, 0.2, 0.9); vec3 color3 = vec3(0.2, 0.8, 0.7);
                        float n = noise(vUv * 3.0 + vec2(0.0, time * -0.1));
                        vec3 mixed = mix(color1, color2, n);
                        vec3 finalColor = mix(mixed, color3, vUv.y * 0.8);
                        float veins = smoothstep(0.7, 0.75, noise(vUv * 8.0 + vec2(0.0, time * -0.2)));
                        finalColor += veins * 0.3;
                        gl_FragColor = vec4(finalColor, 1.0);
                    }
                `,
                side: THREE.DoubleSide
            });
            const bgMesh = new THREE.Mesh(bgGeometry, bgMaterial);
            bgMesh.rotation.x = -Math.PI / 3;
            backgroundGroup.add(bgMesh);
            scene.add(backgroundGroup);

            visualizations.push(new VisParticleSphere());
            visualizations.push(new VisDynamicTerrain());
            visualizations.push(new VisOscillator());
            visualizations.push(new VisFrequencyCanvas());
            visualizations.push(new VisLiquidMarble());
            visualizations.push(new VisStageLights());
            visualizations.push(new VisGrasshopper());
            visualizations.push(new VisMatrix());
            
            visualizations.forEach((vis) => {
                vis.init(scene);
                vis.group.visible = false;
            });
            visNameElement.textContent = visualizations[currentVisualizationIndex].name;

            window.addEventListener('resize', onWindowResize, false);
            fileInput.addEventListener('change', onFileSelect, false);
            homeBtn.addEventListener('click', goHome);
            resumeBtn.addEventListener('click', resumeSession);
            playlistBtn.addEventListener('click', () => playlistPanel.classList.add('visible'));
            closePlaylistBtn.addEventListener('click', () => playlistPanel.classList.remove('visible'));
            audio.addEventListener('ended', playNextTrack);
            prevVisBtn.addEventListener('click', () => switchVisualization(-1));
            nextVisBtn.addEventListener('click', () => switchVisualization(1));
            prevTrackBtn.addEventListener('click', playPreviousTrack);
            nextTrackBtn.addEventListener('click', playNextTrack);
            fullscreenBtn.addEventListener('click', toggleFullscreen);
            document.addEventListener('fullscreenchange', onFullscreenChange);
            document.addEventListener('webkitfullscreenchange', onFullscreenChange);
            document.addEventListener('msfullscreenchange', onFullscreenChange);

            window.addEventListener('click', (event) => {
                if (playlistPanel.classList.contains('visible') && !playlistPanel.contains(event.target) && !playlistBtn.contains(event.target)) {
                    playlistPanel.classList.remove('visible');
                }
            });
        }
        
        // --- Visualization Classes ---
        class VisParticleSphere {
            constructor() {
                this.name = "Particle Sphere";
                this.group = new THREE.Group();
                this.originalPositions = null;
                this.satellites = [];
            }
            init(scene) {
                const geometry = new THREE.IcosahedronGeometry(2.5, 24);
                geometry.setAttribute('color', new THREE.BufferAttribute(new Float32Array(geometry.attributes.position.count * 3), 3));
                this.originalPositions = new Float32Array(geometry.attributes.position.array);
                const material = new THREE.PointsMaterial({
                    size: 0.08,
                    vertexColors: true,
                    map: createGlowTexture(),
                    blending: THREE.AdditiveBlending,
                    transparent: true,
                    depthWrite: false
                });
                this.sphere = new THREE.Points(geometry, material);
                this.group.add(this.sphere);
                const satelliteCount = 150;
                for (let i = 0; i < satelliteCount; i++) {
                    const bufferGeom = new THREE.BufferGeometry();
                    bufferGeom.setAttribute('position', new THREE.BufferAttribute(new Float32Array([0, 0, 0]), 3));
                    const pointMaterial = new THREE.PointsMaterial({
                        size: 0.1,
                        color: 0xffffff,
                        map: createGlowTexture(),
                        blending: THREE.AdditiveBlending,
                        transparent: true,
                        depthWrite: false,
                        opacity: 0
                    });
                    const point = new THREE.Points(bufferGeom, pointMaterial);
                    this.satellites.push({
                        point: point,
                        radius: 4 + Math.random() * 2,
                        speed: 0.002 + Math.random() * 0.008,
                        angle: Math.random() * Math.PI * 2,
                        axis: (new THREE.Vector3(Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5)).normalize(),
                        currentOpacity: 0
                    });
                    this.group.add(point);
                }
                scene.add(this.group);
            }
            update(dataArray, audioFeatures) {
                const positions = this.sphere.geometry.attributes.position.array;
                const colors = this.sphere.geometry.attributes.color.array;
                this.sphere.material.size = 0.03 + (audioFeatures.avgVolume / 255) * 0.1;
                for (let i = 0; i < positions.length; i += 3) {
                    const vertexIndex = i / 3;
                    const dataIndex = (vertexIndex * 2) % dataArray.length;
                    const value = dataArray[dataIndex];
                    const displacement = (value / 255) * 2 * Math.pow(1 - (dataIndex / dataArray.length), 1.5);
                    const p = new THREE.Vector3(this.originalPositions[i], this.originalPositions[i + 1], this.originalPositions[i + 2]);
                    p.normalize().multiplyScalar(1 + displacement);
                    positions[i] = p.x * 2.5;
                    positions[i + 1] = p.y * 2.5;
                    positions[i + 2] = p.z * 2.5;
                    const color = new THREE.Color();
                    const baseHue = 0.65;
                    const finalHue = baseHue - (audioFeatures.avgLow * 0.5);
                    const lightness = 0.5 + audioFeatures.avgLow * 0.4;
                    color.setHSL(finalHue, 0.9, Math.min(lightness, 0.9));
                    colors[i] = color.r;
                    colors[i + 1] = color.g;
                    colors[i + 2] = color.b;
                }
                this.sphere.geometry.attributes.position.needsUpdate = true;
                this.sphere.geometry.attributes.color.needsUpdate = true;
                this.sphere.rotation.y += 0.0008;

                this.satellites.forEach((satellite) => {
                    satellite.angle += satellite.speed;
                    const quaternion = new THREE.Quaternion().setFromAxisAngle(satellite.axis, satellite.angle);
                    const pos = new THREE.Vector3(satellite.radius * (1 + audioFeatures.avgLow * 0.5), 0, 0).applyQuaternion(quaternion);
                    satellite.point.position.copy(pos);
                    
                    const targetOpacity = (audioFeatures.avgMid * 0.6 + audioFeatures.avgHigh * 0.4);

                    satellite.currentOpacity += (targetOpacity - satellite.currentOpacity) * 0.08; // Smoother fade
                    
                    satellite.point.material.opacity = satellite.currentOpacity;
                    satellite.point.material.size = satellite.currentOpacity * (0.05 + audioFeatures.avgHigh * 0.15);
                    
                    const satelliteHue = 0.5;
                    const satelliteLightness = 0.4 + audioFeatures.avgHigh * 0.6;
                    satellite.point.material.color.setHSL(satelliteHue, 1, Math.min(satelliteLightness, 1));
                });
            }
        }
        class VisDynamicTerrain {
            constructor() {
                this.name = "Dynamic Terrain";
                this.group = new THREE.Group();
                this.originalPositions = null;
            }
            init(scene) {
                const segments = 80;
                const geometry = new THREE.PlaneGeometry(15, 15, segments, segments);
                this.plane = new THREE.Mesh(geometry, new THREE.MeshPhongMaterial({
                    vertexColors: true,
                    wireframe: true
                }));
                this.plane.rotation.x = -Math.PI / 2.5;
                this.originalPositions = new Float32Array(geometry.attributes.position.array);
                this.group.add(this.plane);
                const particleGeometry = new THREE.BufferGeometry();
                particleGeometry.setAttribute('position', new THREE.BufferAttribute(new Float32Array((segments + 1) * (segments + 1) * 3), 3));
                this.peakParticles = new THREE.Points(particleGeometry, new THREE.PointsMaterial({
                    size: 0.05,
                    color: 0xffffff,
                    map: createGlowTexture(),
                    blending: THREE.AdditiveBlending,
                    transparent: true,
                    depthWrite: false
                }));
                this.peakParticles.rotation.x = this.plane.rotation.x;
                this.group.add(this.peakParticles);
                this.group.add(new THREE.AmbientLight(0xffffff, 0.2));
                const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
                directionalLight.position.set(0, 1, 0.5);
                this.group.add(directionalLight);
                scene.add(this.group);
            }
            update(dataArray, audioFeatures) {
                const positions = this.plane.geometry.attributes.position.array;
                const particlePositions = this.peakParticles.geometry.attributes.position.array;
                const colors = new Float32Array(positions.length);
                const colorDeep = new THREE.Color(0x0d0d60);
                const colorMid = new THREE.Color(0x1a8cff);
                const colorLand = new THREE.Color(0x00ff00);
                const colorHigh = new THREE.Color(0xffff00);
                const colorPeak = new THREE.Color(0xffffff);
                for (let i = 0; i < positions.length; i += 3) {
                    const zIndex = i + 2;
                    const dataIndex = Math.floor((i / 3) % (dataArray.length * 0.5));
                    const height = (dataArray[dataIndex] / 255) * 3 * audioFeatures.avgLow;
                    positions[zIndex] = this.originalPositions[zIndex] + height;
                    particlePositions[i] = positions[i];
                    particlePositions[i + 1] = positions[i + 1];
                    particlePositions[zIndex] = positions[zIndex] + 0.02;
                    const finalColor = new THREE.Color();
                    const maxHeight = 3.0;
                    const normalizedHeight = Math.min(height / maxHeight, 1.0);
                    if (normalizedHeight < 0.25) {
                        finalColor.lerpColors(colorDeep, colorMid, normalizedHeight / 0.25);
                    } else if (normalizedHeight < 0.5) {
                        finalColor.lerpColors(colorMid, colorLand, (normalizedHeight - 0.25) / 0.25);
                    } else if (normalizedHeight < 0.75) {
                        finalColor.lerpColors(colorLand, colorHigh, (normalizedHeight - 0.5) / 0.25);
                    } else {
                        finalColor.lerpColors(colorHigh, colorPeak, (normalizedHeight - 0.75) / 0.25);
                    }
                    colors[i] = finalColor.r;
                    colors[i + 1] = finalColor.g;
                    colors[i + 2] = finalColor.b;
                }
                this.plane.geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                this.plane.geometry.attributes.position.needsUpdate = true;
                this.peakParticles.geometry.attributes.position.needsUpdate = true;
            }
        }
        class VisOscillator {
            constructor() {
                this.name = "Oscillator";
                this.group = new THREE.Group();
                this.timeDomainArray = null;
                this.trails = [];
                this.trailCount = 16; // Longer ribbon
                this.segmentCount = 256;
            }

            init(scene) {
                for (let i = 0; i < this.trailCount; i++) {
                    const geometry = new THREE.BufferGeometry();
                    const positions = new Float32Array(this.segmentCount * 2 * 3);
                    const colors = new Float32Array(this.segmentCount * 2 * 3);
                    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                    geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                    const material = new THREE.MeshBasicMaterial({
                        side: THREE.DoubleSide,
                        vertexColors: true,
                        transparent: true,
                        opacity: 1.0 - (i / this.trailCount) * 0.8,
                        blending: THREE.AdditiveBlending,
                        depthWrite: false,
                    });
                    const mesh = new THREE.Mesh(geometry, material);
                    this.trails.push(mesh);
                    this.group.add(mesh);
                }
                scene.add(this.group);
            }

            update(dataArray, audioFeatures) {
                if (!analyser) return;
                if (!this.timeDomainArray) {
                    this.timeDomainArray = new Uint8Array(analyser.frequencyBinCount);
                }
                analyser.getByteTimeDomainData(this.timeDomainArray);

                // Shift trail history
                for (let i = this.trailCount - 1; i > 0; i--) {
                    this.trails[i].geometry.attributes.position.array.set(this.trails[i - 1].geometry.attributes.position.array);
                    this.trails[i].geometry.attributes.color.array.set(this.trails[i - 1].geometry.attributes.color.array);
                    this.trails[i].geometry.attributes.position.needsUpdate = true;
                    this.trails[i].geometry.attributes.color.needsUpdate = true;
                }

                const positions = this.trails[0].geometry.attributes.position.array;
                const colors = this.trails[0].geometry.attributes.color.array;
                const ribbonWidth = 0.1; // --- THINNER RIBBON ---
                const time = performance.now() * 0.001;

                for (let i = 0; i < this.segmentCount; i++) {
                    const dataIndex = Math.floor((i / this.segmentCount) * this.timeDomainArray.length);
                    const v = this.timeDomainArray[dataIndex] / 128.0;
                    const y = (v - 1.0) * 2.5;
                    const x = -6 + (i / this.segmentCount) * 12;
                    const z = Math.sin(i * 0.1 + time) * 0.5;

                    positions[i * 6 + 0] = x;
                    positions[i * 6 + 1] = y + ribbonWidth;
                    positions[i * 6 + 2] = z;
                    positions[i * 6 + 3] = x;
                    positions[i * 6 + 4] = y - ribbonWidth;
                    positions[i * 6 + 5] = z;

                    // --- NEW COLOR LOGIC ---
                    const color = new THREE.Color();
                    // Hue cycles through the spectrum over time, and is offset by the waveform height
                    const hue = (performance.now() * 0.00005 + (y / 4)) % 1.0;
                    color.setHSL(hue, 1.0, 0.5);

                    colors[i * 6 + 0] = color.r;
                    colors[i * 6 + 1] = color.g;
                    colors[i * 6 + 2] = color.b;
                    colors[i * 6 + 3] = color.r;
                    colors[i * 6 + 4] = color.g;
                    colors[i * 6 + 5] = color.b;
                }

                const indices = [];
                for (let i = 0; i < this.segmentCount - 1; i++) {
                    const a = i * 2;
                    const b = i * 2 + 1;
                    const c = i * 2 + 2;
                    const d = i * 2 + 3;
                    indices.push(a, b, c);
                    indices.push(b, d, c);
                }
                this.trails[0].geometry.setIndex(indices);
                this.trails[0].geometry.attributes.position.needsUpdate = true;
                this.trails[0].geometry.attributes.color.needsUpdate = true;
                this.trails[0].geometry.computeVertexNormals();
            }
        }
        class VisFrequencyCanvas{constructor(){this.name="Frequency Canvas";this.group=new THREE.Group}init(e){const t=96,i=12,s=new THREE.BufferGeometry,o=new Float32Array(t*t*3),n=new Float32Array(t*t*3);for(let e=0;e<t;e++)for(let a=0;a<t;a++){const r=(e*t+a)*3;o[r]=(a/(t-1)-.5)*i,o[r+1]=(e/(t-1)-.5)*i,o[r+2]=0}s.setAttribute("position",new THREE.BufferAttribute(o,3)),s.setAttribute("color",new THREE.BufferAttribute(n,3));const a=new THREE.PointsMaterial({size:.08,vertexColors:!0,map:createGlowTexture(),blending:THREE.AdditiveBlending,transparent:!0,depthWrite:!1});this.particles=new THREE.Points(s,a),this.group.add(this.particles),this.group.rotation.x=-Math.PI/3,e.add(this.group)}update(e,t){const i=this.particles.geometry.attributes.position.array,s=this.particles.geometry.attributes.color.array,o=Math.sqrt(i.length/3),n=Math.sqrt(.25+.25);for(let t=0;t<o;t++)for(let a=0;a<o;a++){const r=(t*o+a)*3,l=a/(o-1)-.5,h=t/(o-1)-.5,c=Math.sqrt(l*l+h*h),d=Math.pow(c/n,2),u=Math.floor(d*(.75*e.length)),g=e[u]/255;i[r+2]=2*g;const m=new THREE.Color;const p=0.7-0.7*d;const v=0.55+g*0.45;m.setHSL(p,1,v),s[r]=m.r,s[r+1]=m.g,s[r+2]=m.b}this.particles.geometry.attributes.position.needsUpdate=!0,this.particles.geometry.attributes.color.needsUpdate=!0}}
        
        class VisLiquidMarble {
            constructor() {
                this.name = "Liquid Marble";
                this.group = new THREE.Group();
                this.lastHighPeak = 0;
            }
            init(scene) {
                const geometry = new THREE.PlaneGeometry(2, 2); 
                this.material = new THREE.ShaderMaterial({
                    uniforms: {
                        time: { value: 0 },
                        avgLow: { value: 0 },
                        avgMid: { value: 0 },
                        avgHigh: { value: 0 },
                        highPeak: { value: 0 }
                    },
                    vertexShader: `
                        varying vec2 vUv; 
                        void main() { 
                            vUv = uv; 
                            gl_Position = vec4(position, 1.0); 
                        }
                    `,
                    fragmentShader: `
                        uniform float time;
                        uniform float avgLow;
                        uniform float avgMid;
                        uniform float avgHigh;
                        uniform float highPeak;
                        varying vec2 vUv;

                        float random (in vec2 _st) { return fract(sin(dot(_st.xy, vec2(12.9898,78.233))) * 43758.5453123); }
                        float noise (in vec2 _st) {
                            vec2 i = floor(_st); vec2 f = fract(_st);
                            float a = random(i); float b = random(i + vec2(1.0, 0.0));
                            float c = random(i + vec2(0.0, 1.0)); float d = random(i + vec2(1.0, 1.0));
                            vec2 u = f * f * (3.0 - 2.0 * f);
                            return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.y * u.x;
                        }
                        #define NUM_OCTAVES 4 // Optimization: Reduced octaves from 5
                        float fbm ( in vec2 _st) {
                            float v = 0.0; float a = 0.5; vec2 shift = vec2(100.0);
                            mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.50));
                            for (int i = 0; i < NUM_OCTAVES; ++i) { v += a * noise(_st); _st = rot * _st * 2.0 + shift; a *= 0.5; }
                            return v;
                        }

                        void main() {
                            vec2 st = vUv * (2.0 + avgLow * 2.0) - (1.0 + avgLow);
                            st += vec2(sin(time * 0.1), cos(time * 0.1)) * 0.5;
                            vec2 q = vec2(fbm(st + 0.1*time), fbm(st + vec2(1.0)));
                            vec2 r = vec2(fbm(st + 1.0*q + vec2(1.7,9.2)+ 0.15*time), fbm(st + 1.0*q + vec2(8.3,2.8)+ 0.126*time));
                            float f = fbm(st+r);
                            vec3 color = mix(vec3(0.1,0.6,0.7), vec3(0.7,0.7,0.5), clamp((f*f)*4.0,0.0,1.0));
                            color = mix(color, vec3(0.0,0.0,0.16), clamp(length(q),0.0,1.0));
                            color = mix(color, vec3(0.7,1.0,1.0), clamp(length(r.x),0.0,1.0));
                            color *= (f*f*f+.6*f*f+.5*f);
                            
                            float wave = sin(vUv.x * 10.0 + time * 2.0) * 0.3 * avgLow;
                            color *= 1.0 + wave;

                            float lightning = smoothstep(0.3, 0.8, noise(vUv * 10.0 + time * 0.5)) * highPeak * 2.0;
                            color += vec3(0.8, 1.0, 1.0) * lightning;

                            gl_FragColor = vec4(color,1.0);
                        }
                    `
                });
                const mesh = new THREE.Mesh(geometry, this.material);
                this.group.add(mesh);
                scene.add(this.group);
            }
            update(dataArray, audioFeatures) {
                this.material.uniforms.time.value = performance.now() * 0.0005;
                this.material.uniforms.avgLow.value = audioFeatures.avgLow;
                this.material.uniforms.avgMid.value = audioFeatures.avgMid;
                this.material.uniforms.avgHigh.value = audioFeatures.avgHigh;
                
                let highPeakValue = 0;
                if (audioFeatures.avgHigh - this.lastHighPeak > 0.2) {
                    highPeakValue = 1;
                }
                this.material.uniforms.highPeak.value = highPeakValue;
                this.lastHighPeak = audioFeatures.avgHigh;
            }
        }

        class VisStageLights {
            constructor() {
                this.name = "Stage Lights";
                this.group = new THREE.Group();
                this.lights = [];
                this.lastHighs = [0, 0]; // For strobing effect
            }
            init(scene) {
                // Floor to receive the light
                const floorGeometry = new THREE.PlaneGeometry(30, 30);
                const floorMaterial = new THREE.MeshPhongMaterial({ color: 0x1a1a1a, shininess: 50 });
                const floor = new THREE.Mesh(floorGeometry, floorMaterial);
                floor.rotation.x = -Math.PI / 2;
                floor.position.y = -5;
                this.group.add(floor);

                this.ambientLight = new THREE.AmbientLight(0xffffff, 0.1);
                this.group.add(this.ambientLight);

                const lightConfigs = [
                    { color: 0xff4444, position: new THREE.Vector3(-5, 8, 0), type: 'low' },    // Red
                    { color: 0x44ff44, position: new THREE.Vector3(5, 8, 0), type: 'low' },     // Green
                    { color: 0x4444ff, position: new THREE.Vector3(-2.5, 8, -2), type: 'mid' }, // Blue
                    { color: 0xff44ff, position: new THREE.Vector3(2.5, 8, -2), type: 'mid' },  // Magenta
                    { color: 0xffff44, position: new THREE.Vector3(0, 8, 2), type: 'mid' },     // Yellow
                    { color: 0x44ffff, position: new THREE.Vector3(-6, 8, -3), type: 'high' }, // Cyan
                    { color: 0xffffff, position: new THREE.Vector3(6, 8, -3), type: 'high' }   // White
                ];

                lightConfigs.forEach(config => {
                    const spotLight = new THREE.SpotLight(config.color, 0);
                    spotLight.position.copy(config.position);
                    spotLight.angle = Math.PI / 12; // Narrower beam
                    spotLight.penumbra = 0.2;
                    spotLight.decay = 2; // Faster falloff
                    spotLight.distance = 25;

                    // Target for the light
                    spotLight.target.position.set(config.position.x, -5, 0);
                    this.group.add(spotLight);
                    this.group.add(spotLight.target);

                    // Create visible cone "god ray"
                    const lightDistance = spotLight.position.distanceTo(spotLight.target.position);
                    const coneRadius = Math.tan(spotLight.angle) * lightDistance;
                    const coneGeometry = new THREE.ConeGeometry(coneRadius, lightDistance, 32, 1, true); // Open-ended cone
                    coneGeometry.translate(0, -lightDistance / 2, 0); // Move pivot to the top
                    coneGeometry.rotateX(Math.PI); // Point it down

                    const coneMaterial = new THREE.MeshBasicMaterial({
                        color: config.color,
                        transparent: true,
                        opacity: 0, // Start invisible
                        blending: THREE.AdditiveBlending,
                        side: THREE.DoubleSide,
                        depthWrite: false,
                    });
                    const coneMesh = new THREE.Mesh(coneGeometry, coneMaterial);
                    coneMesh.position.copy(spotLight.position);
                    this.group.add(coneMesh);

                    this.lights.push({ 
                        light: spotLight, 
                        cone: coneMesh,
                        type: config.type, 
                        lastIntensity: 0
                    });
                });

                scene.add(this.group);
            }
            update(dataArray, audioFeatures) {
                const time = performance.now() * 0.001;
                this.ambientLight.intensity = 0.05 + audioFeatures.avgVolume * 0.1;
                
                this.lights.forEach((lightObj, index) => {
                    const { light, cone, type } = lightObj;
                    
                    // More dynamic "disco" movement
                    light.target.position.x = Math.sin(time * 0.8 + index * 1.5) * 6;
                    light.target.position.z = Math.cos(time * 0.6 + index * 1.1) * 6;
                    
                    let targetIntensity = 0;

                    switch (type) {
                        case 'low':
                            targetIntensity = Math.pow(audioFeatures.avgLow, 1.5) * 8.0;
                            break;
                        case 'mid':
                            targetIntensity = Math.pow(audioFeatures.avgMid, 2) * 6.0;
                            break;
                        case 'high':
                            if (audioFeatures.avgHigh > 0.6 && lightObj.lastIntensity <= 0.6) {
                                targetIntensity = 12.0; // Flash brightly on beat
                            } else {
                                targetIntensity = light.intensity * 0.8; // Fast decay
                            }
                            lightObj.lastIntensity = audioFeatures.avgHigh;
                            break;
                    }
                    
                    light.intensity += (Math.min(targetIntensity, 12.0) - light.intensity) * 0.15; // Smoothed intensity change
                    
                    // Update the visible cone
                    cone.lookAt(light.target.position);
                    cone.material.opacity = light.intensity / 12.0 * 0.2; // Opacity is a fraction of the intensity
                });
            }
        }

        class VisGrasshopper {
            constructor() {
                this.name = "Grasshopper";
                this.group = new THREE.Group();
            }
            init(scene) {
                const geometry = new THREE.PlaneGeometry(2, 2);
                this.material = new THREE.ShaderMaterial({
                    uniforms: {
                        time: { value: 0 },
                        resolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
                        avgLow: { value: 0 },
                        avgMid: { value: 0 },
                        avgHigh: { value: 0 },
                    },
                    vertexShader: `
                        varying vec2 vUv;
                        void main() {
                            vUv = uv;
                            gl_Position = vec4(position, 1.0);
                        }
                    `,
                    fragmentShader: `
                        uniform vec2 resolution;
                        uniform float time;
                        uniform float avgLow;
                        uniform float avgMid;
                        uniform float avgHigh;
                        varying vec2 vUv;

                        float random (in vec2 _st) { return fract(sin(dot(_st.xy, vec2(12.9898,78.233))) * 43758.5453123); }

                        float noise (in vec2 _st) {
                            vec2 i = floor(_st);
                            vec2 f = fract(_st);
                            float a = random(i);
                            float b = random(i + vec2(1.0, 0.0));
                            float c = random(i + vec2(0.0, 1.0));
                            float d = random(i + vec2(1.0, 1.0));
                            vec2 u = f * f * (3.0 - 2.0 * f);
                            return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.y * u.x;
                        }

                        #define NUM_OCTAVES 4 // Optimization: Reduced octaves from 6
                        float fbm ( in vec2 _st) {
                            float v = 0.0;
                            float a = 0.5;
                            vec2 shift = vec2(100.0);
                            mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.50));
                            for (int i = 0; i < NUM_OCTAVES; ++i) {
                                v += a * noise(_st);
                                _st = rot * _st * 2.0 + shift;
                                a *= 0.5;
                            }
                            return v;
                        }

                        void main() {
                            vec2 st = vUv * 5.0;
                            
                            vec2 wind_uv = vUv * vec2(2.0, 0.5) + vec2(time * 0.2, time * 0.1);
                            float wind_pattern = noise(wind_uv) - 0.5;
                            
                            float wind_strength = 0.2 + avgLow * 0.5;
                            
                            st.x += wind_pattern * wind_strength;
                            
                            float pattern = fbm(st);
                            
                            vec3 grass_dark = vec3(0.1, 0.3, 0.05);
                            vec3 grass_light = vec3(0.4, 0.8, 0.2);
                            vec3 grass_dry = vec3(0.6, 0.5, 0.1);

                            vec3 color = mix(grass_dark, grass_light, smoothstep(0.4, 0.6, pattern));
                            color = mix(color, grass_dry, smoothstep(0.6, 0.65, pattern));

                            color.g += avgMid * 0.2;
                            color.r += avgMid * 0.1;

                            float sparkle = pow(noise(st * 20.0 + time), 10.0) * avgHigh * 1.5;
                            color += vec3(0.8, 1.0, 0.7) * sparkle;
                            
                            color *= smoothstep(1.0, 0.3, length(vUv - 0.5));

                            gl_FragColor = vec4(color, 1.0);
                        }
                    `
                });
                const mesh = new THREE.Mesh(geometry, this.material);
                this.group.add(mesh);
                scene.add(this.group);
                window.addEventListener('resize', () => {
                    this.material.uniforms.resolution.value.set(window.innerWidth, window.innerHeight);
                });
            }
            update(dataArray, audioFeatures) {
                this.material.uniforms.time.value = performance.now() * 0.001;
                this.material.uniforms.avgLow.value = audioFeatures.avgLow;
                this.material.uniforms.avgMid.value = audioFeatures.avgMid;
                this.material.uniforms.avgHigh.value = audioFeatures.avgHigh;
            }
        }

        class VisMatrix {
            constructor() {
                this.name = "Matrix";
                this.group = new THREE.Group(); // Kept for API compatibility
                this.canvas = null;
                this.ctx = null;
                this.drops = [];
                this.columns = 0;
                this.fontSize = 16;
                this.animationInterval = null;
                this.dataArray = null; // To store frequency data
                this.characters = 'アァカサタナハマヤャラワガザダバパイィキシチニヒミリヰギジヂビピウゥクスツヌフムユュルグズブプエェケセテネヘメレヱゲゼデベペオォコソトノホモヨョロヲゴゾドボポヴッンABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
            }

            init() {
                this.canvas = document.getElementById('matrixCanvas');
                if (!this.canvas) return; // Fail gracefully
                this.ctx = this.canvas.getContext('2d');
                // Initial setup for when it's first displayed
                this.setupCanvas(); 
                window.addEventListener('resize', () => {
                    // Only resize if it's currently visible
                    if (this.canvas.style.display === 'block') {
                        this.setupCanvas();
                    }
                }, false);
            }

            setupCanvas() {
                if (!this.canvas) return;
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
                this.columns = Math.floor(this.canvas.width / this.fontSize);
                this.drops = [];
                for (let x = 0; x < this.columns; x++) {
                    // Randomize starting position for a more natural look
                    this.drops[x] = 1 + Math.random() * 100; 
                }
            }

            draw() {
                if (!this.ctx || !this.dataArray) return;
                
                // The fading trail effect
                this.ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                this.ctx.font = this.fontSize + 'px monospace';

                for (let i = 0; i < this.drops.length; i++) {
                    // --- DYNAMIC FREQUENCY-BASED LOGIC ---

                    // 1. Map column to a frequency bin (left=low, right=high)
                    // We use about 75% of the spectrum as the highest frequencies are often quiet.
                    const freqIndex = Math.floor((i / this.drops.length) * (this.dataArray.length * 0.75));
                    const freqValue = this.dataArray[freqIndex] || 0;
                    const normalizedFreq = freqValue / 255; // Value from 0.0 to 1.0

                    // 2. Set character, position, color, and glow based on frequency
                    const text = this.characters.charAt(Math.floor(Math.random() * this.characters.length));
                    const x = i * this.fontSize;
                    const y = this.drops[i] * this.fontSize;
                    
                    const greenIntensity = 100 + Math.floor(normalizedFreq * 155);
                    this.ctx.fillStyle = `rgb(0, ${greenIntensity}, 0)`;
                    
                    const glowAmount = normalizedFreq * 15;
                    this.ctx.shadowBlur = glowAmount;
                    this.ctx.shadowColor = 'rgba(100, 255, 100, 0.5)';
                    
                    this.ctx.fillText(text, x, y);

                    // Add a bright white flash for audio peaks
                    if (normalizedFreq > 0.8) {
                        const shineAlpha = (normalizedFreq - 0.8) / 0.2; // Opacity from 0 to 1
                        this.ctx.fillStyle = `rgba(255, 255, 255, ${shineAlpha})`;
                        this.ctx.shadowBlur = 5 + shineAlpha * 10;
                        this.ctx.shadowColor = 'rgba(255, 255, 255, 0.7)';
                        this.ctx.fillText(text, x, y);
                    }
                    this.ctx.shadowBlur = 0; // Reset shadow for next character

                    // 3. Reset drop position based on frequency intensity
                    // Louder frequencies have a higher chance to start a new drop
                    if (y > this.canvas.height && Math.random() < normalizedFreq * 0.05) {
                        this.drops[i] = 0;
                    }

                    // 4. Set drop speed based on frequency with higher contrast
                    const speed = 0.5 + Math.pow(normalizedFreq, 2) * 15;
                    this.drops[i] += speed;
                }
            }

            start() {
                if (this.animationInterval) return; // Already running
                this.setupCanvas(); // Ensure it's sized correctly
                this.canvas.style.display = 'block';
                // Run draw at a consistent speed
                this.animationInterval = setInterval(() => this.draw(), 40);
            }

            stop() {
                if (!this.animationInterval) return; // Already stopped
                this.canvas.style.display = 'none';
                clearInterval(this.animationInterval);
                this.animationInterval = null;
            }
            
            update(dataArray, audioFeatures) {
                // Store the latest full frequency data array for the draw() loop to use
                this.dataArray = dataArray;
            }
        }


        // --- Event Handlers & Audio Setup ---
        
        function goHome() {
            // BUG FIX: Check if in fullscreen and exit if necessary before resetting UI
            if (document.fullscreenElement || document.webkitFullscreenElement || document.msFullscreenElement) {
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                } else if (document.webkitExitFullscreen) { /* Safari */
                    document.webkitExitFullscreen();
                } else if (document.msExitFullscreen) { /* IE11 */
                    document.msExitFullscreen();
                }
            }
            
            audio.pause();
            
            // Explicitly stop Matrix vis if it's active and show the 3D canvas
            if (visualizations[currentVisualizationIndex].name === "Matrix") {
                visualizations[currentVisualizationIndex].stop();
            }
            renderer.domElement.style.display = 'block';

            visualizations.forEach(vis => vis.group.visible = false);
            audioControlsContainer.classList.remove('visible');
            visSwitcher.classList.remove('visible');
            topBar.classList.remove('visible');
            playlistPanel.classList.remove('visible');

            initialPrompt.style.display = 'flex';
            footerElement.style.display = 'block';
            backgroundGroup.visible = true;
            
            updateHomepageUI();
        }

        function resumeSession() {
            // SAFARI/MOBILE FIX: Resume audio context on user interaction
            if (audioContext && audioContext.state === 'suspended') {
                audioContext.resume();
            }

            initialPrompt.style.display = 'none';
            footerElement.style.display = 'none';
            backgroundGroup.visible = false;

            const currentVis = visualizations[currentVisualizationIndex];
            if (currentVis.name === "Matrix") {
                renderer.domElement.style.display = 'none';
                currentVis.start();
            } else {
                renderer.domElement.style.display = 'block';
                currentVis.group.visible = true;
            }

            audioControlsContainer.classList.add('visible');
            visSwitcher.classList.add('visible');
            topBar.classList.add('visible');
            if(currentTrackIndex !== -1) audio.play();
        }

        function updateHomepageUI() {
            if (playlist.length > 0) {
                resumeBtn.style.display = 'block';
            } else {
                resumeBtn.style.display = 'none';
            }
        }

        function switchVisualization(direction) {
            const oldIndex = currentVisualizationIndex;
            const oldVis = visualizations[oldIndex];
            
            currentVisualizationIndex = (currentVisualizationIndex + direction + visualizations.length) % visualizations.length;
            const newVis = visualizations[currentVisualizationIndex];

            // Deactivate old visualization
            if (oldVis.name === "Matrix") {
                oldVis.stop();
                renderer.domElement.style.display = 'block'; // Show 3D canvas
            } else {
                oldVis.group.visible = false;
            }

            // Activate new visualization
            if (newVis.name === "Matrix") {
                newVis.start();
                renderer.domElement.style.display = 'none'; // Hide 3D canvas
            } else {
                newVis.group.visible = true;
            }
            
            visNameElement.textContent = newVis.name;
        }

        function setupAudioContext() {
            if (audioContext) return;
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            const source = audioContext.createMediaElementSource(audio);
            analyser = audioContext.createAnalyser();
            analyser.fftSize = 1024; // Optimization: Reduced from 2048
            analyser.minDecibels = -90;
            analyser.maxDecibels = -10;
            analyser.smoothingTimeConstant = 0.85;
            dataArray = new Uint8Array(analyser.frequencyBinCount);
            source.connect(analyser);
            analyser.connect(audioContext.destination);
        }

        function onFileSelect(event) {
            const newFiles = Array.from(event.target.files);
            if (newFiles.length === 0) return;

            // --- KEY FIX FOR MOBILE/SAFARI ---
            // Ensure AudioContext is created and resumed within this user gesture.
            if (!audioContext) {
                setupAudioContext();
            }
            if (audioContext.state === 'suspended') {
                audioContext.resume();
            }
            // --- END FIX ---

            const wasPlaylistEmpty = playlist.length === 0;
            const isFromHomepage = initialPrompt.style.display !== 'none';

            newFiles.forEach(file => {
                playlist.push({
                    name: file.name,
                    url: URL.createObjectURL(file)
                });
            });

            renderPlaylist();

            if (!controls) {
                controls = new OrbitControls(camera, renderer.domElement);
                controls.enableDamping = true;
                controls.dampingFactor = 0.05;
                controls.enablePan = false; // Disable panning for a cleaner mobile experience
            }

            if (isFromHomepage) {
                resumeSession();
                playlistPanel.classList.add('visible');
                if (wasPlaylistEmpty) {
                    playTrack(0);
                }
            }
            
            fileInput.value = '';
        }

        function playTrack(index) {
            if (index < 0 || index >= playlist.length) return;
            currentTrackIndex = index;
            audio.src = playlist[index].url;
            audio.play();
            songTitleElement.textContent = playlist[index].name;
            renderPlaylist();
        }

        function playNextTrack() {
            if (playlist.length === 0) return;
            let nextIndex = currentTrackIndex + 1;
            if (nextIndex >= playlist.length) {
                nextIndex = 0;
            }
            playTrack(nextIndex);
        }

        function playPreviousTrack() {
            if (playlist.length === 0) return;
            let prevIndex = currentTrackIndex - 1;
            if (prevIndex < 0) {
                prevIndex = playlist.length - 1;
            }
            playTrack(prevIndex);
        }
        
        function removeTrack(index) {
            if (index < 0 || index >= playlist.length) return;

            const isCurrentlyPlaying = (index === currentTrackIndex);
            playlist.splice(index, 1);

            if (isCurrentlyPlaying) {
                audio.pause();
                audio.src = '';
                songTitleElement.textContent = 'Select a track';
                currentTrackIndex = -1; 
            } 
            else if (index < currentTrackIndex) {
                currentTrackIndex--; 
            }

            if (playlist.length === 0) {
                goHome();
            } else {
                renderPlaylist();
            }
        }

        function renderPlaylist() {
            playlistList.innerHTML = '';
            playlist.forEach((track, index) => {
                const li = document.createElement('li');
                
                const trackName = document.createElement('span');
                trackName.textContent = track.name;
                li.appendChild(trackName);

                const removeBtn = document.createElement('button');
                removeBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg>`;
                removeBtn.className = 'remove-track-btn';
                removeBtn.title = 'Remove track';
                
                removeBtn.addEventListener('click', (event) => {
                    event.stopPropagation();
                    removeTrack(index);
                });
                li.appendChild(removeBtn);

                if (index === currentTrackIndex) {
                    li.classList.add('playing');
                }
                li.addEventListener('click', () => playTrack(index));
                playlistList.appendChild(li);
            });
        }
        
        function toggleFullscreen() {
            if (!document.fullscreenElement && !document.webkitFullscreenElement && !document.msFullscreenElement) {
                const elem = document.documentElement;
                if (elem.requestFullscreen) {
                    elem.requestFullscreen().catch(err => console.error(`Error attempting to enable full-screen mode: ${err.message} (${err.name})`));
                } else if (elem.webkitRequestFullscreen) { /* Safari */
                    elem.webkitRequestFullscreen();
                } else if (elem.msRequestFullscreen) { /* IE11 */
                    elem.msRequestFullscreen();
                }
            } else {
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                } else if (document.webkitExitFullscreen) { /* Safari */
                    document.webkitExitFullscreen();
                } else if (document.msExitFullscreen) { /* IE11 */
                    document.msExitFullscreen();
                }
            }
        }

        function showControls() {
            interactiveUIs.forEach(el => el.classList.add('visible'));
        }
        
        function hideControls() {
            interactiveUIs.forEach(el => el.classList.remove('visible'));
        }

        function onFullscreenChange() {
            const isFullscreen = !!(document.fullscreenElement || document.webkitFullscreenElement || document.msFullscreenElement);
            document.body.classList.toggle('fullscreen-active', isFullscreen);

            enterFullscreenIcon.classList.toggle('hidden', isFullscreen);
            exitFullscreenIcon.classList.toggle('hidden', !isFullscreen);

            if (isFullscreen) {
                uiHideTimeout = setTimeout(hideControls, 3000);
                window.addEventListener('mousemove', handleFullscreenActivity);
                window.addEventListener('touchstart', handleFullscreenActivity);
            } else {
                clearTimeout(uiHideTimeout);
                showControls();
                window.removeEventListener('mousemove', handleFullscreenActivity);
                window.removeEventListener('touchstart', handleFullscreenActivity);
            }
        }

        function handleFullscreenActivity() {
            if (document.fullscreenElement || document.webkitFullscreenElement || document.msFullscreenElement) {
                showControls();
                clearTimeout(uiHideTimeout);
                uiHideTimeout = setTimeout(hideControls, 3000);
            }
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            if (controls) controls.update();

            if (backgroundGroup.visible) {
                backgroundGroup.children[0].material.uniforms.time.value = performance.now() * 0.001;
            }
            
            if (analyser) {
                analyser.getByteFrequencyData(dataArray);
                const bufferLength = analyser.frequencyBinCount;
                
                const lowEnd = Math.floor(bufferLength * 0.1);
                const midEnd = Math.floor(bufferLength * 0.4);
                let lowSum = 0, midSum = 0, highSum = 0;
                for (let i = 0; i < lowEnd; i++) lowSum += dataArray[i];
                for (let i = lowEnd; i < midEnd; i++) midSum += dataArray[i];
                for (let i = midEnd; i < bufferLength; i++) highSum += dataArray[i];

                const audioFeatures = {
                    avgLow: (lowSum / lowEnd) / 255,
                    avgMid: (midSum / (midEnd - lowEnd)) / 255,
                    avgHigh: (highSum / (bufferLength - midEnd)) / 255,
                    avgVolume: (lowSum + midSum + highSum) / bufferLength
                };
                
                // This condition now correctly handles both Three.js and Matrix visualizations
                const currentVis = visualizations[currentVisualizationIndex];
                if (currentVis && (currentVis.group.visible || (currentVis.name === "Matrix" && currentVis.animationInterval))) {
                       currentVis.update(dataArray, audioFeatures);
                }
            }

            renderer.render(scene, camera);
        }

        init();
        animate();
    </script>
</body>
</html>

