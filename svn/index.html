<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RSA Confluence (Live Tick Stream + Flow + Target)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;800&family=JetBrains+Mono:wght@400;700;800&display=swap" rel="stylesheet">
    <script src="https://unpkg.com/lucide@latest"></script>
    <style>
        body { font-family: 'Inter', sans-serif; background-color: #0b0f19; color: #e2e8f0; overflow: hidden; }
        .font-mono { font-family: 'JetBrains Mono', monospace; }
        
        /* Scrollbar Hidden but Functional */
        .map-scroll::-webkit-scrollbar { width: 4px; background: #0f172a; }
        .map-scroll::-webkit-scrollbar-thumb { background: #334155; border-radius: 2px; }
        
        /* Meter */
        .regime-meter-container {
            position: relative; height: 8px;
            background: linear-gradient(90deg, #10b981 0%, #10b981 45%, #374151 50%, #ef4444 55%, #ef4444 100%); 
            border-radius: 4px; margin-top: 8px; overflow: hidden;
        }
        .regime-needle {
            position: absolute; top: -2px; width: 4px; height: 12px;
            background-color: white; border: 1px solid #000;
            transform: translateX(-50%); transition: left 1s cubic-bezier(0.4, 0, 0.2, 1);
            z-index: 10;
        }
        
        /* Map Styles */
        .map-container {
            position: relative;
            width: 100%;
            overflow-y: scroll;
            overflow-x: hidden;
            scroll-behavior: auto; 
        }

        .rsa-item {
            position: absolute;
            width: 100%;
            height: 20px;
            display: flex;
            align-items: center;
            padding: 0 6px;
            font-size: 10px;
            transform: translateY(-50%);
            white-space: nowrap;
            z-index: 20; 
            pointer-events: none; 
        }
        
        .rsa-line {
            position: absolute;
            left: 0; right: 0;
            height: 1px;
            z-index: 10; 
            pointer-events: none;
        }

        .rsa-item:hover { z-index: 50; background-color: #1f2937; border-color: #60a5fa; cursor: crosshair; pointer-events: auto; }

        /* Bias Shading Zones */
        .bias-zone {
            position: absolute;
            left: 0; right: 0;
            z-index: 0; 
            pointer-events: none;
            transition: top 0.2s ease-out, height 0.2s ease-out; 
            will-change: top, height;
        }
        .zone-red { background: linear-gradient(to bottom, rgba(239, 68, 68, 0.25) 0%, rgba(239, 68, 68, 0) 100%); }
        .zone-green { background: linear-gradient(to top, rgba(16, 185, 129, 0.25) 0%, rgba(16, 185, 129, 0) 100%); }
        .zone-blue-bull { background: linear-gradient(to bottom, rgba(59, 130, 246, 0.3) 0%, rgba(59, 130, 246, 0) 100%); }
        .zone-blue-bear { background: linear-gradient(to top, rgba(59, 130, 246, 0.3) 0%, rgba(59, 130, 246, 0) 100%); }

        /* Tags */
        .tag-pill { padding: 1px 4px; border-radius: 3px; font-size: 9px; font-weight: 800; text-transform: uppercase; margin-left: auto; }
        .tag-res { color: #f87171; border: 1px solid #7f1d1d; background: #450a0a; }
        .tag-sup { color: #34d399; border: 1px solid #064e3b; background: #022c22; }
        .tag-trg { color: #fbbf24; border: 1px solid #78350f; background: #451a03; animation: pulse 2s infinite; }
        .tag-trg-minor { color: #fdba74; border: 1px dashed #9a3412; background: #431407; animation: pulse 3s infinite; }
        .tag-eq { color: #38bdf8; border: 1px solid #0c4a6e; background: #082f49; }
        .tag-hit { color: #d1d5db; border: 1px solid #6b7280; background: #374151; margin-right: 4px;} 
        
        @keyframes pulse { 0% { opacity: 0.6; } 50% { opacity: 1; } 100% { opacity: 0.6; } }

        /* Glowing Status */
        .status-glow {
            box-shadow: 0 0 5px #10b981;
            animation: statusPulse 0.5s infinite; /* Faster pulse for WebSocket */
        }
        @keyframes statusPulse {
            0% { box-shadow: 0 0 2px #10b981; border-color: #059669; }
            50% { box-shadow: 0 0 8px #10b981; border-color: #34d399; }
            100% { box-shadow: 0 0 2px #10b981; border-color: #059669; }
        }

        .glass-panel { background: #111827; border: 1px solid #374151; }
        .loading-overlay { position: absolute; inset: 0; background: #0b0f19; z-index: 100; display: flex; flex-direction: column; align-items: center; justify-content: center; }
        
        /* Grid Column Headers */
        .col-header { padding: 4px; text-align: center; border-bottom: 1px solid #1f2937; font-size: 10px; font-weight: 800; z-index: 40; box-shadow: 0 4px 6px rgba(0,0,0,0.5); flex-shrink: 0; display: flex; flex-direction: column; align-items: center; min-height: 42px; justify-content: center; background-color: #0f172a; position: relative; }
        
        .col-header-d { color: #60a5fa; }
        .col-header-w { color: #c084fc; }
        .col-header-m { color: #facc15; }
        .col-header-q { color: #fb923c; } 
        .col-header-s { color: #2dd4bf; } 
        .col-header-y { color: #fb7185; } 
        
        .header-stats { font-size: 8px; font-family: 'JetBrains Mono', monospace; opacity: 0.8; margin-top: 2px; display: flex; gap: 4px; }
        .stat-badge { background: rgba(0,0,0,0.3); padding: 1px 3px; rounded: 2px; cursor: help; }

        /* Price Line Animation */
        #cp-line { transition: top 0.05s linear; } /* Smooth rapid transition */
        #cp-label { transition: top 0.05s linear; }
        
        /* Tick Flash Animation */
        .flash-green { color: #4ade80 !important; text-shadow: 0 0 10px rgba(74, 222, 128, 0.5); }
        .flash-red { color: #f87171 !important; text-shadow: 0 0 10px rgba(248, 113, 113, 0.5); }

        /* --- NEW: FOOTPRINT HUD STYLES --- */
        #footprint-hud {
            position: absolute;
            left: 0; 
            right: 0;
            height: 0px; /* Position reference only */
            z-index: 35; /* Above lines, below headers */
            pointer-events: none;
            transition: top 0.05s linear;
        }

        .fp-container {
            position: absolute;
            left: 60px; /* Offset from label */
            top: -50px; /* Center vertically relative to line */
            width: 200px;
            height: 100px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            opacity: 0.9;
        }

        .fp-row {
            display: flex;
            align-items: center;
            height: 6px;
            margin-bottom: 1px;
        }

        .fp-bar-buy { background: #4ade80; height: 4px; border-radius: 0 2px 2px 0; box-shadow: 0 0 4px rgba(74, 222, 128, 0.4); }
        .fp-bar-sell { background: #f87171; height: 4px; border-radius: 2px 0 0 2px; margin-left: auto; box-shadow: 0 0 4px rgba(248, 113, 113, 0.4); }
        
        .fp-center-line { width: 1px; height: 100%; background: rgba(255,255,255,0.1); margin: 0 2px; }

        .delta-meter {
            position: absolute;
            left: 60px; 
            bottom: -20px;
            font-size: 8px; /* Slightly smaller */
            font-weight: bold;
            font-family: 'JetBrains Mono', monospace;
            padding: 2px 4px;
            border-radius: 2px;
            background: rgba(0,0,0,0.7);
            border: 1px solid #333;
            white-space: nowrap;
        }

        /* NEW: PROJECTION TARGET */
        .fp-target-box {
            position: absolute;
            left: 270px; /* Right of bars */
            top: -8px;
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            pointer-events: none;
        }
        
        .fp-target-pill {
            display: flex;
            align-items: center;
            gap: 4px; /* Reduced gap */
            padding: 2px 6px; /* Reduced padding */
            border-radius: 3px;
            background: rgba(0,0,0,0.8);
            border: 1px solid #374151;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
            backdrop-filter: blur(4px);
        }

        .fp-arrow { font-size: 10px; margin-right: -1px; }
        .fp-target-price { font-family: 'JetBrains Mono', monospace; font-size: 11px; font-weight: 800; letter-spacing: -0.5px; }
        .fp-strength { font-size: 8px; font-weight: 700; padding: 1px 3px; border-radius: 2px; color: #111827; }

        /* --- NEW: MICRO-STRUCTURE PULSE (ABUSE DETECTOR) --- */
        .fp-micro-box {
            position: absolute;
            left: 270px;
            top: 28px; 
            display: flex;
            flex-direction: column;
            gap: 4px;
            pointer-events: none;
        }
        
        .fp-pulse-row {
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .fp-pulse-pill {
            display: flex;
            align-items: center;
            gap: 4px;
            padding: 2px 5px;
            border-radius: 3px;
            background: rgba(17, 24, 39, 0.8);
            border: 1px solid #4b5563;
            font-size: 8px; /* Smaller font */
            font-weight: 700;
            color: #9ca3af;
        }
        
        .pulse-active { animation: pulseRed 1s infinite; border-color: #f87171; color: #fecaca; }
        .pulse-active-bull { animation: pulseGreen 1s infinite; border-color: #4ade80; color: #bbf7d0; } /* NEW GREEN */
        .pulse-absorb { animation: pulseOrange 2s infinite; border-color: #fbbf24; color: #fef3c7; }
        
        /* NEW: HISTORY TIMELINE (BARCODE) */
        .mm-timeline {
            display: flex;
            gap: 1px;
            height: 4px;
            width: 100px;
            margin-top: 2px;
            background: rgba(0,0,0,0.5);
            border-radius: 2px;
            overflow: hidden;
        }
        .mm-tick { flex: 1; height: 100%; opacity: 0.8; }
        .mm-tick-s { background-color: #4b5563; } /* Stalking (Gray) */
        .mm-tick-h { background-color: #fbbf24; box-shadow: 0 0 2px #fbbf24; } /* Hunting (Yellow) */
        
        /* SPLIT RUNNING COLORS */
        .mm-tick-r-bear { background-color: #f87171; box-shadow: 0 0 2px #f87171; } /* Bear Running (Red) */
        .mm-tick-r-bull { background-color: #4ade80; box-shadow: 0 0 2px #4ade80; } /* Bull Running (Green) */

        @keyframes pulseRed { 0% { background: rgba(185, 28, 28, 0.2); } 50% { background: rgba(185, 28, 28, 0.6); } 100% { background: rgba(185, 28, 28, 0.2); } }
        @keyframes pulseOrange { 0% { background: rgba(180, 83, 9, 0.2); } 50% { background: rgba(180, 83, 9, 0.5); } 100% { background: rgba(180, 83, 9, 0.2); } }
        @keyframes pulseGreen { 0% { background: rgba(22, 163, 74, 0.2); } 50% { background: rgba(22, 163, 74, 0.6); } 100% { background: rgba(22, 163, 74, 0.2); } }

    </style>
</head>
<body class="flex flex-col h-screen w-screen overflow-hidden">

    <!-- Header -->
    <header class="flex-none bg-[#111827] border-b border-gray-800 p-3 flex justify-between items-center z-50 shadow-md">
        <div class="flex items-center gap-3">
            <div class="w-8 h-8 rounded bg-blue-600 flex items-center justify-center font-bold text-white">R</div>
            <div>
                <h1 class="text-sm font-bold text-white tracking-wide">RSA <span class="text-blue-500">CONFLUENCE</span></h1>
                <p class="text-[10px] text-gray-400 flex items-center gap-1"><span class="w-2 h-2 rounded-full bg-green-500 animate-pulse"></span> Live WebSocket Stream</p>
            </div>
        </div>
        
        <div class="flex items-center gap-2">
            <div id="status-indicator" class="text-[10px] px-2 py-1 rounded bg-gray-800 text-gray-400 border border-gray-700 transition-all duration-300 min-w-[80px] text-center">Ready</div>
            
            <div class="relative">
                <input type="text" id="coin-input" list="tickers" value="BTCUSDT" class="bg-gray-900 border border-gray-700 text-white text-xs px-2 py-1 rounded w-24 text-center uppercase font-bold focus:border-blue-500 outline-none transition-colors" onkeydown="if(event.key === 'Enter') loadData()">
                <datalist id="tickers">
                    <option value="BTCUSDT">
                    <option value="ETHUSDT">
                    <option value="SOLUSDT">
                    <option value="XRPUSDT">
                    <option value="BNBUSDT">
                </datalist>
            </div>
            
            <button onclick="loadData()" class="bg-blue-600 hover:bg-blue-500 text-white text-xs px-3 py-1 rounded font-bold transition">CONNECT</button>
        </div>
    </header>

    <!-- Top Bar: Stats (AGGREGATED) -->
    <div class="flex-none grid grid-cols-12 gap-1 bg-[#0b0f19] p-2 border-b border-gray-800 z-40">
        <div class="col-span-12 md:col-span-4 glass-panel p-2 rounded flex flex-col justify-center">
            <div class="flex justify-between items-end mb-1">
                <span class="text-[10px] text-gray-400 uppercase font-bold">Global Structure Matrix</span>
                <span id="regime-text" class="text-[10px] font-bold text-white">---</span>
            </div>
            <div class="regime-meter-container">
                <div id="regime-needle" class="regime-needle" style="left: 50%"></div>
            </div>
        </div>
        <div class="col-span-6 md:col-span-4 glass-panel p-2 rounded flex flex-col justify-center">
            <!-- AGGREGATE DISPLAY -->
            <div class="flex justify-between text-[10px]">
                <span class="text-gray-500">Avg Vol / Ratio</span>
                <span id="vol-text" class="font-mono text-white">---</span>
            </div>
            <div class="flex justify-between text-[10px] mt-1">
                <span class="text-gray-500 font-bold">Global Target</span>
                <span id="radius-text" class="font-mono font-bold">---</span>
            </div>
        </div>
        <div class="col-span-6 md:col-span-4 glass-panel p-2 rounded flex items-center justify-between">
            <span class="text-[10px] text-gray-500 font-bold uppercase">Live Price</span>
            <!-- UPDATED PRICE STYLE: Larger, Bolder, Yellow, Glowing -->
            <span id="price-text" class="text-3xl font-mono font-black text-yellow-400 tracking-tight drop-shadow-[0_0_10px_rgba(250,204,21,0.4)]">---</span>
        </div>
    </div>

    <!-- MAIN MAP AREA -->
    <div class="flex-grow relative overflow-hidden bg-black w-full h-full flex flex-col">
        
        <div id="loading-screen" class="loading-overlay hidden">
            <div class="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-500 mb-2"></div>
            <p class="text-xs text-gray-400 animate-pulse">Initializing Stream...</p>
        </div>

        <!-- Horizontal Scroll Container -->
        <div class="flex-grow overflow-x-auto overflow-y-hidden relative">
            <!-- Grid with min-width -->
            <div class="grid grid-cols-6 divide-x divide-gray-800 h-full min-w-[1000px] relative">
                
                <!-- DAILY -->
                <div class="relative flex flex-col h-full overflow-hidden">
                    <div id="header-d" class="col-header col-header-d">
                        <span>DAILY</span>
                        <div class="header-stats">Loading...</div>
                    </div>
                    <div id="scroll-d" class="map-scroll map-container flex-grow"><div id="world-d" class="relative w-full"></div></div>
                </div>
                
                <!-- WEEKLY -->
                <div class="relative flex flex-col h-full overflow-hidden">
                    <div id="header-w" class="col-header col-header-w">
                        <span>WEEKLY</span>
                        <div class="header-stats">Loading...</div>
                    </div>
                    <div id="scroll-w" class="map-scroll map-container flex-grow"><div id="world-w" class="relative w-full"></div></div>
                </div>
                
                <!-- MONTHLY -->
                <div class="relative flex flex-col h-full overflow-hidden">
                    <div id="header-m" class="col-header col-header-m">
                        <span>MONTHLY</span>
                        <div class="header-stats">Loading...</div>
                    </div>
                    <div id="scroll-m" class="map-scroll map-container flex-grow"><div id="world-m" class="relative w-full"></div></div>
                </div>

                <!-- QUARTERLY -->
                <div class="relative flex flex-col h-full overflow-hidden">
                    <div id="header-q" class="col-header col-header-q">
                        <span>QUARTER</span>
                        <div class="header-stats">Loading...</div>
                    </div>
                    <div id="scroll-q" class="map-scroll map-container flex-grow"><div id="world-q" class="relative w-full"></div></div>
                </div>

                <!-- SEMESTER -->
                <div class="relative flex flex-col h-full overflow-hidden">
                    <div id="header-s" class="col-header col-header-s">
                        <span>SEMESTER</span>
                        <div class="header-stats">Loading...</div>
                    </div>
                    <div id="scroll-s" class="map-scroll map-container flex-grow"><div id="world-s" class="relative w-full"></div></div>
                </div>

                <!-- YEARLY -->
                <div class="relative flex flex-col h-full overflow-hidden">
                    <div id="header-y" class="col-header col-header-y">
                        <span>YEARLY</span>
                        <div class="header-stats">Loading...</div>
                    </div>
                    <div id="scroll-y" class="map-scroll map-container flex-grow"><div id="world-y" class="relative w-full"></div></div>
                </div>

                <!-- Center Line & HUD -->
                <div id="cp-line" class="absolute left-0 right-0 h-[1px] bg-yellow-500 z-30 pointer-events-none opacity-80 shadow-[0_0_8px_eab308] transition-all duration-75" style="top: 0px;"></div>
                <div id="cp-label" class="absolute left-2 -translate-y-1/2 bg-yellow-900/90 text-yellow-200 text-[9px] px-2 py-0.5 rounded z-30 border border-yellow-500/50 font-bold transition-all duration-75" style="top: 0px;">LIVE</div>

                <!-- NEW: Footprint HUD Container attached to price line logic -->
                <div id="footprint-hud" style="top: 0px;">
                    <div id="fp-visuals" class="fp-container">
                        <!-- Bars injected via JS -->
                    </div>
                    <div id="fp-delta" class="delta-meter text-gray-400">WAITING FLOW...</div>
                    
                    <!-- NEW: Price Target Box -->
                    <div id="fp-target" class="fp-target-box hidden">
                        <div class="text-[8px] text-gray-400 mb-0.5 tracking-widest uppercase font-bold">Flow Target (1m)</div>
                        <div id="fp-target-pill" class="fp-target-pill">
                            <!-- Injected JS -->
                        </div>
                    </div>

                    <!-- NEW: Micro-Structure Abuse Detector -->
                    <div id="fp-micro" class="fp-micro-box hidden">
                        <div class="fp-pulse-row">
                            <div id="fp-speed-pill" class="fp-pulse-pill" title="Tick Velocity (Speed)">
                                <span class="text-[8px]">SPD</span>
                                <span id="fp-speed-val" class="font-mono">0/s</span>
                            </div>
                            <div id="fp-status-pill" class="fp-pulse-pill" title="Micro-Structure Status">
                                <span id="fp-status-val">STALKING</span>
                            </div>
                        </div>
                        <!-- NEW: BEHAVIOR TIMELINE (60s) -->
                        <div id="mm-timeline" class="mm-timeline" title="MM Behavior History (60s)">
                            <!-- Injected JS -->
                        </div>
                    </div>

                </div>

            </div>
        </div>

        <!-- Recenter Fab -->
        <button onclick="centerMap(true)" class="absolute bottom-6 right-6 bg-blue-600 hover:bg-blue-500 text-white rounded-full w-10 h-10 shadow-lg flex items-center justify-center z-50 transition-transform active:scale-95 group cursor-pointer" title="Re-Center">
            <span class="text-lg">⌖</span>
        </button>

    </div>

    <script>
        // --- STABLE API CONFIG ---
        const VISION_API = 'https://data-api.binance.vision/api/v3';
        
        const APIS = {
            ticker: 'https://api1.binance.com/api/v3', 
            klines: VISION_API 
        };

        const CONFIG = {
            symbol: 'BTCUSDT',
            scale: 60, 
            virtualHeight: 40000,
            centerOffset: 20000
        };

        let state = {
            price: 0,
            prevPrice: 0, // For flash detection
            intervals: {},
            klines: { d: [], w: [], m: [], q: [], s: [], y: [] },
            stats: {}, 
            touched: { 
                d: { set: new Set(), time: 0 }, 
                w: { set: new Set(), time: 0 }, 
                m: { set: new Set(), time: 0 },
                q: { set: new Set(), time: 0 }, 
                s: { set: new Set(), time: 0 }, 
                y: { set: new Set(), time: 0 }
            },
            flow: [],
            // NEW: Micro-Structure Abuse Metrics
            micro: {
                ticks: 0,
                startPrice: 0,
                startTime: 0,
                history: [] // Stores 'S', 'H', 'Rb', 'Rs' codes for last 60s
            }
        };
        
        let priceSocket = null;

        // --- CORE FUNCTIONS ---
        
        async function loadData() {
            const input = document.getElementById('coin-input').value.toUpperCase();
            if(input) CONFIG.symbol = input;
            
            showLoading(true);
            updateStatus('Syncing...');
            
            // Cleanup existing
            if(priceSocket) { 
                priceSocket.onclose = null; 
                priceSocket.close(); 
                priceSocket = null; 
            }
            if(state.intervals.poll) clearInterval(state.intervals.poll);
            if(state.intervals.micro) clearInterval(state.intervals.micro); // Clean up micro timer

            state.flow = []; // Reset flow buffer
            state.micro.history = []; // Reset history
            
            // Force clear visual container to prevent ghosting
            const fpContainer = document.getElementById('fp-visuals');
            if(fpContainer) fpContainer.innerHTML = '';
            const deltaEl = document.getElementById('fp-delta');
            if(deltaEl) deltaEl.textContent = "WAITING FLOW...";


            const initTouched = () => ({ set: new Set(), time: 0 });
            state.touched = { d: initTouched(), w: initTouched(), m: initTouched(), q: initTouched(), s: initTouched(), y: initTouched() };
            
            ['d','w','m','q','s','y'].forEach(id => document.getElementById(`world-${id}`).innerHTML = '');

            try {
                // Initial Fetch (One-time) to build map structure
                const tickerRes = await fetch(`${APIS.ticker}/ticker/24hr?symbol=${CONFIG.symbol}`);
                if(!tickerRes.ok) throw new Error('Ticker Fetch Failed');
                const ticker = await tickerRes.json();
                state.price = parseFloat(ticker.lastPrice);
                state.prevPrice = state.price;
                document.getElementById('price-text').textContent = formatPrice(state.price);
                
                const results = await Promise.allSettled([
                    fetch(`${APIS.klines}/klines?symbol=${CONFIG.symbol}&interval=1d&limit=400`),
                    fetch(`${APIS.klines}/klines?symbol=${CONFIG.symbol}&interval=1w&limit=100`),
                    fetch(`${APIS.klines}/klines?symbol=${CONFIG.symbol}&interval=1M&limit=240`)
                ]);

                if (results[0].status === 'fulfilled' && results[0].value.ok) {
                    const dData = await results[0].value.json();
                    if(Array.isArray(dData) && dData.length > 5) {
                        state.klines.d = dData;
                        state.stats.d = calculateRegime(dData, 1); 
                    } else renderError('d', 'Invalid Data Format');
                } else renderError('d', 'Daily Data Failed');

                if (results[1].status === 'fulfilled' && results[1].value.ok) {
                    state.klines.w = await results[1].value.json();
                    state.stats.w = calculateRegime(state.klines.w, 7); 
                } else renderError('w', 'Weekly Data Failed');

                if (results[2].status === 'fulfilled' && results[2].value.ok) {
                    const mData = await results[2].value.json();
                    state.klines.m = mData;
                    state.stats.m = calculateRegime(mData, 30); 
                    
                    state.klines.q = buildAggregateTF(mData, 3); 
                    state.stats.q = calculateRegime(state.klines.q, 90);

                    state.klines.s = buildAggregateTF(mData, 6); 
                    state.stats.s = calculateRegime(state.klines.s, 180);

                    state.klines.y = buildAggregateTF(mData, 12);
                    state.stats.y = calculateRegime(state.klines.y, 365);

                } else renderError('m', 'Monthly Data Failed');

                updateGlobalConfluence();
                renderAllMaps();

                showLoading(false);
                
                setTimeout(() => centerMap(true), 100);
                setTimeout(() => centerMap(true), 500); 
                
                // START WEBSOCKET STREAM (Realtime Tick)
                startStream(CONFIG.symbol);
                
                // Keep interval for STRUCTURE update (not price), e.g., recalc Anchor every 1s
                // But don't fetch HTTP price anymore, use state.price from WS
                state.intervals.poll = setInterval(syncStructure, 1000);

                // Start Micro-Structure Pulse (1s interval)
                state.intervals.micro = setInterval(updateMicroStructure, 1000);
                state.micro.startTime = Date.now();
                state.micro.startPrice = state.price;

            } catch(e) {
                console.error(e);
                showLoading(false);
                updateStatus('Error');
                alert('Connection Error.\n\nJika data tidak muncul, kemungkinan koneksi ke Binance diblokir oleh ISP.\n\nSaran: Coba gunakan VPN.');
            }
        }

        // --- WEBSOCKET LOGIC (THE HEART OF REALTIME) ---
        function startStream(symbol) {
            updateStatus('Connecting...');
            
            // Using trade stream for maximum granularity (tick-by-tick)
            // wss://stream.binance.com:9443/ws/<symbol>@trade
            const wsUrl = `wss://stream.binance.com:9443/ws/${symbol.toLowerCase()}@trade`;
            
            priceSocket = new WebSocket(wsUrl);
            
            priceSocket.onopen = () => {
                updateStatus('Live Stream');
                document.getElementById('status-indicator').classList.add('status-glow');
            };
            
            priceSocket.onmessage = (event) => {
                const data = JSON.parse(event.data);
                const newPrice = parseFloat(data.p);
                const qty = parseFloat(data.q);
                const time = data.T; // Trade time
                const isBuyerMaker = data.m; // true = Sell Aggression, false = Buy Aggression
                
                // 1. Update Price State
                state.prevPrice = state.price;
                state.price = newPrice;

                // 2. Add to Flow Buffer
                state.flow.push({ p: newPrice, q: qty, t: time, m: isBuyerMaker });
                
                // 3. Increment Micro Tick Counter for Speed calculation
                state.micro.ticks++;

                // 4. Prune old trades (> 60s)
                const cutoff = Date.now() - 60000;
                while(state.flow.length > 0 && state.flow[0].t < cutoff) {
                    state.flow.shift();
                }
                
                // 5. High Frequency Visual Updates (Lightweight)
                updatePriceVisuals();
            };
            
            priceSocket.onerror = (err) => {
                console.error("WS Error", err);
                updateStatus('WS Error');
            };
            
            priceSocket.onclose = () => {
                if(document.getElementById('status-indicator').textContent === 'Live Stream') {
                     updateStatus('Disconnected');
                }
            };
        }

        // Lightweight function run on EVERY tick
        function updatePriceVisuals() {
            // A. Update Text & Flash Color
            const priceEl = document.getElementById('price-text');
            priceEl.textContent = formatPrice(state.price);
            
            if (state.price > state.prevPrice) {
                priceEl.classList.remove('text-yellow-400', 'flash-red');
                priceEl.classList.add('flash-green');
                setTimeout(() => { priceEl.classList.remove('flash-green'); priceEl.classList.add('text-yellow-400'); }, 150);
            } else if (state.price < state.prevPrice) {
                priceEl.classList.remove('text-yellow-400', 'flash-green');
                priceEl.classList.add('flash-red');
                setTimeout(() => { priceEl.classList.remove('flash-red'); priceEl.classList.add('text-yellow-400'); }, 150);
            }

            // B. Update Line Position Immediately
            updatePriceLine();

            // C. Render Footprint HUD (New)
            renderFootprint();
        }

        // --- NEW: MICRO-STRUCTURE ABUSE DETECTION ---
        function updateMicroStructure() {
            const el = document.getElementById('fp-micro');
            const speedEl = document.getElementById('fp-speed-val');
            const statusEl = document.getElementById('fp-status-val');
            const statusPill = document.getElementById('fp-status-pill');
            const timelineEl = document.getElementById('mm-timeline');
            
            if (!el) return;

            // 1. Calculate Tick Velocity (Ticks Per Second)
            const tps = state.micro.ticks;
            speedEl.textContent = `${tps}/s`;
            
            // 2. Calculate Efficiency (Price Move / Effort)
            // If Price Move is Low but TPS is High -> ABUSE (Absorption)
            const priceDiff = state.price - state.micro.startPrice; // Signed Difference for direction
            const priceMove = Math.abs(priceDiff);
            const volatility = state.price * 0.0001; // 0.01% standard volatility
            
            let status = 'STALKING'; // Default: Quiet
            let statusCode = 'S'; // Stalking
            let colorClass = 'text-gray-400 border-gray-600';
            let animation = '';

            // --- ABUSE LOGIC "Just Below Detection" ---
            
            // Case A: High Speed, Low Movement (ABSORPTION / ABUSE)
            // Ticks > 15/s (Arbitrary high for example) but Price moved < 0.01%
            if (tps > 8 && priceMove < volatility) {
                status = 'HUNTING'; // Abuse Detected
                statusCode = 'H';
                colorClass = 'text-yellow-200 border-yellow-500 bg-yellow-900/50';
                animation = 'pulse-absorb';
            } 
            // Case B: High Speed, High Movement (BREAKOUT)
            else if (tps > 8 && priceMove >= volatility) {
                if (priceDiff > 0) {
                    // BULL RUNNING
                    status = 'RUNNING'; 
                    statusCode = 'Rb'; // Running Bull
                    colorClass = 'text-green-200 border-green-500 bg-green-900/50'; // Green Style
                    animation = 'pulse-active-bull'; // Green Pulse
                } else {
                    // BEAR RUNNING
                    status = 'RUNNING'; 
                    statusCode = 'Rs'; // Running Sell/Bear
                    colorClass = 'text-red-200 border-red-500 bg-red-900/50'; // Red Style
                    animation = 'pulse-active'; // Red Pulse
                }
            }
            // Case C: Low Speed (Noise)
            else {
                status = 'STALKING';
                statusCode = 'S';
                colorClass = 'text-gray-400 border-gray-600';
                animation = '';
            }

            // Render Status
            el.classList.remove('hidden');
            statusEl.textContent = status;
            statusPill.className = `fp-pulse-pill ${colorClass} ${animation}`;

            // --- RENDER HISTORY TIMELINE (NEW) ---
            // Push to history
            state.micro.history.push(statusCode);
            if(state.micro.history.length > 60) state.micro.history.shift(); // Keep last 60s

            // Render Barcode
            let timelineHTML = '';
            state.micro.history.forEach(code => {
                let tickClass = 'mm-tick-s';
                if(code === 'H') tickClass = 'mm-tick-h';
                if(code === 'Rs') tickClass = 'mm-tick-r-bear'; // Red
                if(code === 'Rb') tickClass = 'mm-tick-r-bull'; // Green
                timelineHTML += `<div class="mm-tick ${tickClass}"></div>`;
            });
            timelineEl.innerHTML = timelineHTML;

            // Reset Micro Counters for next second
            state.micro.ticks = 0;
            state.micro.startPrice = state.price;
        }


        // --- NEW: FOOTPRINT RENDERER & PREDICTION ---
        function renderFootprint() {
            const container = document.getElementById('fp-visuals');
            const deltaEl = document.getElementById('fp-delta');
            const targetContainer = document.getElementById('fp-target');
            const targetPill = document.getElementById('fp-target-pill');
            
            if(!container) return;

            // Bucket Logic: Group trades by price level relative to current price
            // We want to see +/- 0.05% range around price
            const bucketSize = state.price * 0.0001; // 0.01% buckets
            const buckets = {};
            let maxVol = 0;
            let netDelta = 0;
            let totalBuy = 0;
            let totalSell = 0;

            state.flow.forEach(tx => {
                // Round price to nearest bucket
                const bPrice = Math.round(tx.p / bucketSize) * bucketSize;
                
                // --- FIX: USE HIGHER PRECISION FOR KEYS ---
                // Previously: toFixed(2) caused collapse on low-value coins (XRP, ADA)
                // Now: toFixed(5) handles sub-penny assets correctly
                const key = bPrice.toFixed(5);
                
                if(!buckets[key]) buckets[key] = { buy: 0, sell: 0 };
                
                if (tx.m) { 
                    // Maker was buyer -> Taker was SELLER
                    buckets[key].sell += tx.q;
                    totalSell += tx.q;
                    netDelta -= tx.q;
                } else {
                    // Maker was seller -> Taker was BUYER
                    buckets[key].buy += tx.q;
                    totalBuy += tx.q;
                    netDelta += tx.q;
                }
                
                const vol = buckets[key].buy + buckets[key].sell;
                if(vol > maxVol) maxVol = vol;
            });

            const totalVol = totalBuy + totalSell;

            // Update Delta Label
            if(state.flow.length === 0 || totalVol === 0) {
                deltaEl.textContent = "WAITING FLOW...";
                deltaEl.className = "delta-meter text-gray-500";
                container.innerHTML = '';
                targetContainer.classList.add('hidden');
                return;
            } else {
                targetContainer.classList.remove('hidden');
            }

            const deltaSign = netDelta > 0 ? '+' : '';
            deltaEl.innerHTML = `FLOW(60s): <span class="${netDelta > 0 ? 'text-green-400' : 'text-red-400'}">${deltaSign}${netDelta.toFixed(2)}</span>`;
            
            // --- NEW: MOMENTUM TARGET PROJECTION ---
            // Logic: 
            // 1. Calculate Imbalance % (Abs Delta / Total Vol)
            // 2. Volatility Base = 0.05% (Scalp)
            // 3. Move = Imbalance * Volatility
            
            const imbalancePct = Math.abs(netDelta) / totalVol; // 0.0 to 1.0
            const strength = Math.round(imbalancePct * 100);
            
            // Dynamic volatility range based on strength (Max 0.1% move for extreme imbalance)
            const projectedMovePct = 0.0005 + (0.0005 * imbalancePct); 
            const priceMove = state.price * projectedMovePct;
            
            let targetPrice = 0;
            let arrow = '';
            let colorClass = '';
            let strengthBg = '';
            let label = '';

            if (netDelta > 0) {
                targetPrice = state.price + priceMove;
                arrow = '▲';
                colorClass = 'text-green-400';
                strengthBg = 'bg-green-400';
                label = 'BULL';
            } else {
                targetPrice = state.price - priceMove;
                arrow = '▼';
                colorClass = 'text-red-400';
                strengthBg = 'bg-red-400';
                label = 'BEAR';
            }

            targetPill.innerHTML = `
                <span class="fp-arrow ${colorClass}">${arrow}</span>
                <span class="fp-target-price ${colorClass}">${formatPrice(targetPrice)}</span>
                <span class="fp-strength ${strengthBg}">${label} ${strength}%</span>
            `;

            // --- END NEW LOGIC ---

            // Generate HTML for bars
            const keys = Object.keys(buckets).sort((a,b) => parseFloat(b) - parseFloat(a));
            const relevantKeys = keys.filter(k => Math.abs(parseFloat(k) - state.price) < (state.price * 0.002));

            let html = '';
            relevantKeys.forEach(k => {
                const b = buckets[k];
                const buyW = (b.buy / maxVol) * 80; // Max 80px width
                const sellW = (b.sell / maxVol) * 80;
                
                const isCurrent = Math.abs(parseFloat(k) - state.price) < bucketSize;
                const opacity = isCurrent ? '1.0' : '0.6';

                html += `
                    <div class="fp-row" style="opacity: ${opacity}">
                        <div style="flex:1; display:flex;">
                            <div class="fp-bar-sell" style="width: ${sellW}px;"></div>
                        </div>
                        <div class="fp-center-line"></div>
                        <div style="flex:1; display:flex;">
                            <div class="fp-bar-buy" style="width: ${buyW}px;"></div>
                        </div>
                    </div>
                `;
            });
            container.innerHTML = html;
        }

        // --- CALCULATION LOGIC ---

        function calculateRegime(klines) {
            if(!klines || klines.length < 2) return { vol: 0, radius: 0, regime: 'NEUTRAL', regimeColor: 'text-gray-400', ratio: 1, timeProgress: 0, elapsedHours: 0, totalHours: 0 };

            const t0 = klines[klines.length - 1];
            const t1 = klines[klines.length - 2];

            const t0_H = parseFloat(t0[2]);
            const t0_L = parseFloat(t0[3]);
            const t0_Open = parseFloat(t0[1]);
            const t0_Range = t0_H - t0_L;

            const t1_H = parseFloat(t1[2]);
            const t1_L = parseFloat(t1[3]);
            const t1_Range = Math.abs(t1_H - t1_L); 

            const vol = t0_Open > 0 ? (t0_Range / t0_Open) : 0;
            const ratio = t1_Range > 0 ? (t0_Range / t1_Range) : 1.0;

            let regime = 'CTR';
            let regimeColor = 'text-green-400';
            if (ratio > 1.0) {
                regime = 'EXP';
                regimeColor = 'text-red-400';
            }

            const openTime = t0[0];
            const closeTime = t0[6]; 
            const now = Date.now();
            let timeProgress = (now - openTime) / (closeTime - openTime);
            timeProgress = Math.max(0.01, Math.min(1.0, timeProgress)); 

            // Calculate precise hours for display and logic
            const totalMs = closeTime - openTime;
            const elapsedMs = now - openTime;
            const totalHours = Math.max(1, Math.round(totalMs / 3600000));
            const elapsedHours = Math.max(0, Math.round(elapsedMs / 3600000));

            const radius = vol * 1.25;

            return { 
                vol: vol, 
                radius: radius, 
                regime: regime, 
                regimeColor: regimeColor,
                ratio: ratio,
                timeProgress: timeProgress,
                elapsedHours: elapsedHours,
                totalHours: totalHours,
                // Helper data for global aggregation
                open: t0_Open,
                currentMove: Math.abs(state.price - t0_Open)
            };
        }

        // --- GLOBAL CONFLUENCE LOGIC (INTELLIGENCE) ---
        function updateGlobalConfluence() {
            if (!state.stats.d) return;

            const tfs = ['d', 'w', 'm', 'q', 's', 'y'];
            const statsArr = tfs.map(k => state.stats[k]).filter(Boolean);
            
            // 1. Regime Voting
            const expCount = statsArr.filter(s => s.regime === 'EXP').length;
            const ctrCount = statsArr.filter(s => s.regime === 'CTR').length;
            
            // 2. Bias Voting (Price vs Open)
            let bullVotes = 0;
            let bearVotes = 0;
            let projectedSum = 0;
            let weightSum = 0;
            
            let avgVol = 0;
            let avgRatio = 0;

            statsArr.forEach(s => {
                const isBull = state.price >= s.open;
                if (isBull) bullVotes++; else bearVotes++;
                
                avgVol += s.vol;
                avgRatio += s.ratio;

                // 3. Weighted Target Logic
                const safeT = Math.max(0.01, s.timeProgress);
                const projMove = s.currentMove / safeT;
                const projTarget = isBull ? (s.open + projMove) : (s.open - projMove);
                
                const w = Math.pow(safeT, 2); 
                
                projectedSum += projTarget * w;
                weightSum += w;
            });

            const globalTarget = weightSum > 0 ? (projectedSum / weightSum) : 0;
            avgVol /= statsArr.length;
            avgRatio /= statsArr.length;

            // -- UI Updates --

            // 1. Structure Matrix (Regime)
            let regimeText = 'MIXED';
            let regimeColor = 'text-yellow-400';
            let meterVal = 0.5;

            if (expCount >= 4) {
                regimeText = `NET EXPANSION (${expCount}/6)`;
                regimeColor = 'text-red-400';
                meterVal = 0.8;
            } else if (ctrCount >= 4) {
                regimeText = `NET CONTRACTION (${ctrCount}/6)`;
                regimeColor = 'text-green-400';
                meterVal = 0.2;
            }

            const biasText = bullVotes > bearVotes ? `BULLISH (${bullVotes}/6)` : `BEARISH (${bearVotes}/6)`;
            const biasColor = bullVotes > bearVotes ? 'text-green-400' : 'text-red-400';

            // Top Left Panel
            document.getElementById('regime-text').innerHTML = `${regimeText} <span class="${biasColor} ml-2">${biasText}</span>`;
            document.getElementById('regime-text').className = `text-[10px] font-bold ${regimeColor}`;
            document.getElementById('regime-needle').style.left = `${meterVal * 100}%`;

            // Top Middle Panel (Aggregated Intel with Target %)
            const volStr = (avgVol * 100).toFixed(2) + '%';
            const ratioStr = (avgRatio * 100).toFixed(0) + '%';
            const targetStr = formatPrice(globalTarget);
            
            // Calculate distance % from current price to global target
            const distPct = ((globalTarget - state.price) / state.price) * 100;
            const distSign = distPct > 0 ? '+' : '';
            const distStr = `(${distSign}${distPct.toFixed(2)}%)`;
            
            const targetEl = document.getElementById('radius-text');
            targetEl.textContent = `${targetStr} ${distStr}`;
            
            // Visual Confirmation of 2-Way Analysis
            if (globalTarget >= state.price) {
                targetEl.className = 'font-mono text-green-400 font-bold'; // Bullish Target
                targetEl.innerHTML += ' <span class="text-[9px]">▲</span>';
            } else {
                targetEl.className = 'font-mono text-red-400 font-bold'; // Bearish Target
                targetEl.innerHTML += ' <span class="text-[9px]">▼</span>';
            }

            document.getElementById('vol-text').textContent = `${volStr} / ${ratioStr}`;
        }

        function updateColumnHeader(id, stats, label, smaLabel) {
            const el = document.getElementById(`header-${id}`);
            if(!el || !stats) return;
            const timePct = (stats.timeProgress * 100).toFixed(2);
            
            el.innerHTML = `
                <span>${label} <span class="text-[9px] opacity-70 ml-1 text-yellow-200">${smaLabel}</span></span>
                <div class="header-stats">
                    <span class="stat-badge text-gray-300">V:${(stats.vol*100).toFixed(2)}%</span>
                    <span class="stat-badge text-blue-300">R:${(stats.ratio*100).toFixed(0)}%</span>
                    <span class="stat-badge text-purple-300" title="Elapsed: ${stats.elapsedHours}h / ${stats.totalHours}h">T:${timePct}%</span>
                    <span class="stat-badge ${stats.regimeColor}">${stats.regime}</span>
                </div>
            `;
        }

        function buildAggregateTF(monthlyKlines, monthsPerCandle) {
            if(!monthlyKlines || monthlyKlines.length === 0) return [];
            
            const result = [];
            let currentBin = null;

            for(let i = 0; i < monthlyKlines.length; i++) {
                const k = monthlyKlines[i];
                const date = new Date(k[0]);
                const month = date.getUTCMonth(); 
                
                const isStart = (month % monthsPerCandle) === 0;

                if (isStart) {
                    if (currentBin) result.push(finalizeBin(currentBin));
                    currentBin = createNewBin(k, monthsPerCandle);
                } else {
                    if (!currentBin) currentBin = createNewBin(k, monthsPerCandle); 
                    else updateBin(currentBin, k);
                }
            }
            if (currentBin) result.push(finalizeBin(currentBin));

            return result;
        }

        function createNewBin(k, months) {
            const openTime = k[0];
            const d = new Date(openTime);
            d.setUTCMonth(d.getUTCMonth() + months); 
            const theoreticCloseTime = d.getTime() - 1; 

            return {
                openTime: openTime,
                open: k[1], 
                high: parseFloat(k[2]),
                low: parseFloat(k[3]),
                close: k[4],
                closeTime: theoreticCloseTime 
            };
        }

        function updateBin(bin, k) {
            bin.high = Math.max(bin.high, parseFloat(k[2]));
            bin.low = Math.min(bin.low, parseFloat(k[3]));
            bin.close = k[4];
        }

        function finalizeBin(bin) {
            return [
                bin.openTime,
                bin.open,
                bin.high.toString(),
                bin.low.toString(),
                bin.close,
                0,
                bin.closeTime 
            ];
        }

        // Heavy operation: re-render map DOM, update candle high/low, recalc anchors
        // We run this less frequently (1s) than the Price Update (Tick)
        async function syncStructure() {
            try {
                // Update Klines in memory with latest price from WS
                checkAndUpdateKlines('d', state.klines.d);
                checkAndUpdateKlines('w', state.klines.w);
                checkAndUpdateKlines('m', state.klines.m);

                if(state.klines.m.length > 0) {
                    state.klines.q = buildAggregateTF(state.klines.m, 3);
                    state.klines.s = buildAggregateTF(state.klines.m, 6);
                    state.klines.y = buildAggregateTF(state.klines.m, 12);
                }
                
                state.stats.d = calculateRegime(state.klines.d);
                state.stats.w = calculateRegime(state.klines.w);
                state.stats.m = calculateRegime(state.klines.m);
                state.stats.q = calculateRegime(state.klines.q);
                state.stats.s = calculateRegime(state.klines.s);
                state.stats.y = calculateRegime(state.klines.y);

                updateGlobalConfluence();
                renderAllMaps();

            } catch(e) { console.log('Sync skip', e); }
        }

        function renderAllMaps() {
            if(!state.klines.d || state.klines.d.length === 0) return;

            const mmD = calculateSMA(state.klines.d, 1);    
            const mmW = calculateSMA(state.klines.d, 7);    
            const mmM = calculateSMA(state.klines.d, 30);   
            const mmQ = calculateSMA(state.klines.d, 90);   
            const mmS = calculateSMA(state.klines.d, 180);  
            const mmY = calculateSMA(state.klines.d, 365);  

            if(state.klines.d.length) { updateColumnHeader('d', state.stats.d, 'DAILY', '(SMA 1D)'); renderMap('d', state.klines.d, state.stats.d, mmD, 'SMA'); }
            if(state.klines.w.length) { updateColumnHeader('w', state.stats.w, 'WEEKLY', '(SMA 7D)'); renderMap('w', state.klines.w, state.stats.w, mmW, 'SMA'); }
            if(state.klines.m.length) { updateColumnHeader('m', state.stats.m, 'MONTHLY', '(SMA 30D)'); renderMap('m', state.klines.m, state.stats.m, mmM, 'SMA'); }
            if(state.klines.q.length) { updateColumnHeader('q', state.stats.q, 'QUARTER', '(SMA 90D)'); renderMap('q', state.klines.q, state.stats.q, mmQ, 'SMA'); }
            if(state.klines.s.length) { updateColumnHeader('s', state.stats.s, 'SEMESTER', '(SMA 180D)'); renderMap('s', state.klines.s, state.stats.s, mmS, 'SMA'); }
            if(state.klines.y.length) { updateColumnHeader('y', state.stats.y, 'YEARLY', '(SMA 365D)'); renderMap('y', state.klines.y, state.stats.y, mmY, 'SMA'); }
        }

        function calculateSMA(klines, period) {
            if (!klines || klines.length < period) return null;
            const slice = klines.slice(klines.length - period, klines.length);
            const sum = slice.reduce((acc, k) => {
                const h = parseFloat(k[2]);
                const l = parseFloat(k[3]);
                return acc + ((h + l) / 2); 
            }, 0);
            return sum / period;
        }

        function checkAndUpdateKlines(type, klines) {
            if(!klines || klines.length === 0) return;
            const lastK = klines[klines.length - 1];
            let h = parseFloat(lastK[2]);
            let l = parseFloat(lastK[3]);
            
            // Update current candle high/low based on realtime price
            if(state.price > h) { lastK[2] = state.price.toString(); }
            if(state.price < l) { lastK[3] = state.price.toString(); }
            lastK[4] = state.price.toString();
        }

        function renderMap(id, klines, stats, customMM, mmLabel) {
            const container = document.getElementById(`world-${id}`);
            const oldItems = container.querySelectorAll('.rsa-item, .rsa-line');
            oldItems.forEach(el => el.remove());
            container.style.height = `${CONFIG.virtualHeight}px`;

            if(!klines || klines.length < 2) return;

            const prev = klines[klines.length - 2];
            const pH = parseFloat(prev[2]);
            const pL = parseFloat(prev[3]);
            const Vu = pH - pL;
            const step = Vu * 0.125;
            
            const curr = klines[klines.length - 1];
            const currOpenTime = curr[0];

            if (state.touched[id].time !== currOpenTime) {
                state.touched[id].set.clear();
                state.touched[id].time = currOpenTime;
            }
            
            const currH = parseFloat(curr[2]);
            const currL = parseFloat(curr[3]);
            const aH = Math.max(currH, state.price); 
            const aL = Math.min(currL, state.price); 
            const openPrice = parseFloat(curr[1]); 

            const priceY = CONFIG.centerOffset; 
            const pctDiffAH = ((aH - state.price) / state.price) * 100;
            const topPosAH = CONFIG.centerOffset - (pctDiffAH * CONFIG.scale);
            const pctDiffAL = ((aL - state.price) / state.price) * 100;
            const topPosAL = CONFIG.centerOffset - (pctDiffAL * CONFIG.scale);

            updateZone(container, 'red', topPosAH, priceY - topPosAH);
            updateZone(container, 'green', priceY, topPosAL - priceY);

            const pctDiffOpen = ((openPrice - state.price) / state.price) * 100;
            const topPosOpen = CONFIG.centerOffset - (pctDiffOpen * CONFIG.scale);
            const isBull = state.price >= openPrice;
            updateBlueZone(container, isBull, priceY, topPosOpen);

            createLine(container, topPosOpen, 'dashed', 'rgba(234, 179, 8, 0.7)');
            
            const openLabel = document.createElement('div');
            openLabel.className = 'rsa-item';
            openLabel.style.top = `${topPosOpen}px`;
            openLabel.style.zIndex = '25';
            const diffPct = ((state.price - openPrice) / openPrice) * 100;
            const diffSign = diffPct > 0 ? '+' : '';
            openLabel.innerHTML = `<span class="text-[9px] text-yellow-200 font-mono tracking-widest ml-1 bg-black/60 px-1 rounded border border-yellow-900/50">OPEN: ${formatPrice(openPrice)} (${diffSign}${diffPct.toFixed(2)}%)</span>`;
            container.appendChild(openLabel);

            const levels = [];
            for(let i=1; i<=32; i++) levels.push({ p: aL + (i*step), lbl: `H${i}`, type: 'R', idx: i });
            for(let i=1; i<=32; i++) levels.push({ p: aH - (i*step), lbl: `L${i}`, type: 'S', idx: i });
            
            if(customMM !== null) { levels.push({ p: customMM, lbl: mmLabel || 'SMA', type: 'EQ_MM' }); }
            
            const rsaEq = (aH+aL)/2;
            levels.push({ p: rsaEq, lbl: 'RSA', type: 'EQ_RSA' });
            levels.push({ p: aH, lbl: 'AH', type: 'ANCHOR' });
            levels.push({ p: aL, lbl: 'AL', type: 'ANCHOR' });

            const currentRadius = stats ? stats.radius : 0.01; 
            const currentRegime = stats ? stats.regime : 'NEUTRAL';

            const currentMove = Math.abs(state.price - openPrice);
            const safeTime = Math.max(0.01, stats.timeProgress);
            const projectedMove = currentMove / safeTime;
            
            const projectedHigh = openPrice + projectedMove;
            const projectedLow = openPrice - projectedMove;
            
            // --- ADDED TOLERANCE LOGIC HERE ---
            const HIT_TOLERANCE = 0.0005; // 0.05% Tolerance

            levels.forEach(lvl => {
                if(isNaN(lvl.p)) return;

                // Check Hit with Tolerance
                if(lvl.type === 'R') { 
                    // Anchor High >= Level Price (minus tolerance)
                    if(aH >= (lvl.p * (1 - HIT_TOLERANCE))) state.touched[id].set.add(lvl.lbl); 
                }
                if(lvl.type === 'S') { 
                    // Anchor Low <= Level Price (plus tolerance)
                    if(aL <= (lvl.p * (1 + HIT_TOLERANCE))) state.touched[id].set.add(lvl.lbl); 
                }

                const isHit = state.touched[id].set.has(lvl.lbl);
                const pctDiff = ((lvl.p - state.price) / state.price) * 100;
                const offsetPx = pctDiff * CONFIG.scale;
                const topPos = CONFIG.centerOffset - offsetPx;

                if(topPos < 0 || topPos > CONFIG.virtualHeight) return;

                let tag = '';
                if (isHit) { tag = '<span class="tag-pill tag-hit">HIT</span>'; }

                const distAbs = Math.abs(pctDiff/100);
                const isClose = distAbs < currentRadius; 

                if(lvl.type === 'R' || lvl.type === 'S') {
                    if(!isHit) { 
                        let isTarget = false;
                        let isReachable = false;

                        if (lvl.type === 'R' && isBull && lvl.p <= projectedHigh) isReachable = true;
                        if (lvl.type === 'S' && !isBull && lvl.p >= projectedLow) isReachable = true;

                        let nextMajorIdx = Math.ceil(lvl.idx / 4) * 4;
                        let isNextMajorReachable = false;
                        
                        if (lvl.idx % 4 !== 0) {
                            if (lvl.type === 'R') {
                                const nextMajP = aL + (nextMajorIdx * step);
                                if (isBull && nextMajP <= projectedHigh) isNextMajorReachable = true;
                            } else if (lvl.type === 'S') {
                                const nextMajP = aH - (nextMajorIdx * step);
                                if (!isBull && nextMajP >= projectedLow) isNextMajorReachable = true;
                            }
                        }
                        
                        if (currentRegime === 'EXP') isNextMajorReachable = true;

                        if(lvl.idx % 4 === 0) {
                            if(currentRegime === 'EXP') {
                                if (lvl.type === 'R' && isBull) isTarget = true;
                                if (lvl.type === 'S' && !isBull) isTarget = true;
                            } else {
                                if (isReachable) isTarget = true;
                            }

                            if (isTarget) tag = '<span class="tag-pill tag-trg">TRG</span>';
                            else tag = '<span class="tag-pill tag-eq">KEY</span>';
                        
                        } else {
                            if (isReachable && !isNextMajorReachable) {
                                tag = '<span class="tag-pill tag-trg-minor">mTRG</span>';
                            } else if (currentRegime === 'CTR' && isClose) {
                                tag = lvl.type === 'R' ? '<span class="tag-pill tag-res">RES</span>' : '<span class="tag-pill tag-sup">SUP</span>';
                            }
                        }
                    }
                } else if (lvl.type === 'EQ_MM') {
                    tag = '<span class="tag-pill tag-eq">MAG</span>';
                }

                if(lvl.type === 'ANCHOR') {
                    createLine(container, topPos, 'dashed', 'rgba(255,255,255,0.5)');
                } else if((lvl.idx % 4 === 0) && (lvl.type === 'R' || lvl.type === 'S')) {
                    createLine(container, topPos, 'solid', 'rgba(255,255,255,0.1)');
                }

                const el = document.createElement('div');
                el.className = 'rsa-item';
                el.style.top = `${topPos}px`;
                
                let txtColor = 'text-gray-500';
                if(lvl.type === 'R') txtColor = 'text-red-400';
                if(lvl.type === 'S') txtColor = 'text-green-400';
                if(lvl.type.includes('EQ')) { txtColor = 'text-blue-300 font-bold'; el.style.backgroundColor = 'rgba(59,130,246,0.1)'; }
                if(lvl.type === 'ANCHOR') { txtColor = 'text-gray-300 font-bold'; }
                if((lvl.idx % 4 === 0) && (lvl.type === 'R' || lvl.type === 'S')) { txtColor += ' font-bold'; }
                
                if(isHit) {
                    txtColor = 'text-gray-600 line-through';
                    el.style.opacity = '0.6';
                }

                el.innerHTML = `
                    <span class="${txtColor} w-8">${lvl.lbl}</span>
                    <span class="font-mono text-gray-300 ml-2 ${isHit ? 'text-gray-500' : ''}">${formatPrice(lvl.p)}</span>
                    ${tag}
                `;
                container.appendChild(el);
            });
        }

        function createLine(container, top, style, color) {
            const line = document.createElement('div');
            line.className = 'rsa-line';
            line.style.top = `${top}px`;
            line.style.borderTop = `1px ${style} ${color}`;
            container.appendChild(line);
        }

        function updateZone(container, type, top, height) {
            let zone = container.querySelector(`.zone-${type}`);
            if (!zone) {
                zone = document.createElement('div');
                zone.className = `bias-zone zone-${type}`;
                container.appendChild(zone);
            }
            if (height < 0) { top = top + height; height = Math.abs(height); }
            zone.style.top = `${top}px`;
            zone.style.height = `${Math.max(0, height)}px`;
        }

        function updateBlueZone(container, isBull, priceY, topPosOpen) {
            let zone = container.querySelector(`.zone-blue`);
            if (!zone) {
                zone = document.createElement('div');
                zone.classList.add('bias-zone', 'zone-blue'); 
                container.appendChild(zone);
            }
            if (isBull) {
                zone.className = 'bias-zone zone-blue zone-blue-bull';
                zone.style.top = `${priceY}px`;
                zone.style.height = `${Math.abs(topPosOpen - priceY)}px`;
            } else {
                zone.className = 'bias-zone zone-blue zone-blue-bear';
                zone.style.top = `${topPosOpen}px`;
                zone.style.height = `${Math.abs(priceY - topPosOpen)}px`;
            }
        }

        function renderError(id, msg) {
            const c = document.getElementById(`world-${id}`);
            c.innerHTML = `<div class="absolute top-[20000px] w-full text-center text-red-500 text-xs mt-4 transform -translate-y-1/2">${msg}</div>`;
        }

        function centerMap(force) {
            const d = document.getElementById('scroll-d');
            if(!d) return;
            const viewportH = d.clientHeight || 500; 
            const target = CONFIG.centerOffset - (viewportH / 2);
            
            ['d','w','m','q','s','y'].forEach(id => {
                const el = document.getElementById(`scroll-${id}`);
                if(el) el.scrollTop = target;
            });
            updatePriceLine();
        }

        function updatePriceLine() {
            const scrollers = ['scroll-d', 'scroll-w', 'scroll-m', 'scroll-q', 'scroll-s', 'scroll-y'];
            let activeScroller = null;
            for (const id of scrollers) {
                const el = document.getElementById(id);
                if (el) { activeScroller = el; break; }
            }
            if(!activeScroller) return;
            
            // Calculate the offset of the scroll container relative to the main parent.
            const lineElement = document.getElementById('cp-line');
            const hudElement = document.getElementById('footprint-hud');
            if (!lineElement) return;
            
            const parent = lineElement.parentElement; 
            const parentRect = parent.getBoundingClientRect();
            const scrollerRect = activeScroller.getBoundingClientRect();
            
            const headerOffset = scrollerRect.top - parentRect.top; 

            const scrollTop = activeScroller.scrollTop;
            const viewportY = (CONFIG.centerOffset - scrollTop) + headerOffset;
            
            const label = document.getElementById('cp-label');
            if(lineElement) lineElement.style.top = `${viewportY}px`;
            if(label) label.style.top = `${viewportY}px`;
            
            // Sync HUD position with Price Line
            if(hudElement) hudElement.style.top = `${viewportY}px`;
        }

        const scrolls = ['scroll-d', 'scroll-w', 'scroll-m', 'scroll-q', 'scroll-s', 'scroll-y'];
        scrolls.forEach(id => {
            const el = document.getElementById(id);
            if(!el) return;
            el.addEventListener('scroll', () => {
                const top = el.scrollTop;
                scrolls.forEach(otherId => {
                    if(otherId !== id) {
                        const other = document.getElementById(otherId);
                        if(other) other.scrollTop = top;
                    }
                });
                // Using requestAnimationFrame to sync with screen refresh rate
                requestAnimationFrame(updatePriceLine);
            });
        });
        
        window.addEventListener('resize', () => {
             requestAnimationFrame(updatePriceLine);
             centerMap(false);
        });

        function showLoading(show) { 
            const overlay = document.getElementById('loading-screen');
            overlay.classList.toggle('hidden', !show);
            const status = document.getElementById('status-indicator');
            if(show) {
                status.classList.remove('text-gray-400', 'bg-gray-800', 'status-glow');
                status.classList.add('text-yellow-400', 'bg-yellow-900/30');
                status.textContent = 'Loading...';
            }
        }

        function updateStatus(msg) { 
            const status = document.getElementById('status-indicator');
            status.textContent = msg;
            
            if (msg.includes('Stream') || msg === 'Live') {
                status.classList.remove('text-gray-400', 'bg-gray-800', 'text-yellow-400', 'bg-yellow-900/30', 'text-red-400', 'bg-red-900/30');
                status.classList.add('text-green-400', 'bg-green-900/30', 'status-glow', 'border-green-600');
            } else if (msg.includes('Error') || msg === 'Disconnected') {
                status.classList.remove('status-glow', 'border-green-600', 'text-green-400', 'bg-green-900/30', 'text-yellow-400', 'bg-yellow-900/30');
                status.classList.add('text-red-400', 'bg-red-900/30');
            } else {
                status.classList.remove('status-glow', 'border-green-600', 'text-green-400', 'bg-green-900/30', 'text-red-400', 'bg-red-900/30');
                status.classList.add('text-yellow-400', 'bg-yellow-900/30');
            }
        }
        
        function formatPrice(p) { return p < 10 ? p.toFixed(4) : p.toLocaleString(undefined, {minimumFractionDigits: 2, maximumFractionDigits: 2}); }
        
        // --- NEW FUNCTION: Fetch Top 100 Coins ---
        async function fetchTopCoins() {
            try {
                const res = await fetch(`${APIS.ticker}/ticker/24hr`);
                if (!res.ok) return; 
                const data = await res.json();
                
                const top100 = data
                    .filter(t => t.symbol.endsWith('USDT'))
                    .sort((a, b) => parseFloat(b.quoteVolume) - parseFloat(a.quoteVolume))
                    .slice(0, 100);
                
                const dataList = document.getElementById('tickers');
                dataList.innerHTML = '';
                top100.forEach(t => {
                    const opt = document.createElement('option');
                    opt.value = t.symbol;
                    dataList.appendChild(opt);
                });
            } catch (e) {
                console.log('Failed to fetch top coins', e);
            }
        }

        // Initialize
        loadData();
        fetchTopCoins();

    </script>
</body>
</html>