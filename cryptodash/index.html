<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Top 100 Crypto Dashboard</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-chart-financial/dist/chartjs-chart-financial.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #111827;
        }
        .price-up { color: #22c55e; }
        .price-down { color: #ef4444; }
        .price-neutral { color: #6b7280; }
        .table-container {
            max-height: 75vh; /* Adjusted height */
            overflow-y: auto;
        }
        .table-container::-webkit-scrollbar, .coin-dropdown::-webkit-scrollbar { width: 8px; }
        .table-container::-webkit-scrollbar-track, .coin-dropdown::-webkit-scrollbar-track { background: #1f2937; }
        .table-container::-webkit-scrollbar-thumb, .coin-dropdown::-webkit-scrollbar-thumb { background-color: #4b5563; border-radius: 4px; }
        .flash-green { animation: flash-bg-green 0.5s ease-out; }
        .flash-red { animation: flash-bg-red 0.5s ease-out; }
        @keyframes flash-bg-green {
            0% { background-color: rgba(34, 197, 94, 0.2); }
            100% { background-color: #1f2937; }
        }
        @keyframes flash-bg-red {
            0% { background-color: rgba(239, 68, 68, 0.2); }
            100% { background-color: #1f2937; }
        }
        select {
            -webkit-appearance: none; -moz-appearance: none; appearance: none;
            background-image: url('data:image/svg+xml;charset=UTF-8,<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="%239ca3af" class="w-6 h-6"><path stroke-linecap="round" stroke-linejoin="round" d="M19.5 8.25l-7.5 7.5-7.5-7.5" /></svg>');
            background-repeat: no-repeat; background-position: right 0.75rem center; background-size: 1.25em;
        }
        .chart-container {
            position: relative;
            height: 80vh;
        }
        .chart-message {
            position: absolute;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: rgba(31, 41, 55, 0.5);
            border-radius: 0.75rem;
        }
        /* Table row highlight colors */
        .highlight-btc { background-color: rgba(251, 191, 36, 0.1); }
        .highlight-dominance { background-color: rgba(59, 130, 246, 0.1); }
        .highlight-gainer { background-color: rgba(34, 197, 94, 0.1); }
        .highlight-loser { background-color: rgba(239, 68, 68, 0.1); }
        .legend-btn {
             transition: all 0.2s ease-in-out;
             border: 1px solid #4A5568;
        }
        .legend-btn.active {
            background-color: #374151;
            box-shadow: inset 0 2px 4px 0 rgba(0,0,0,0.06);
            opacity: 1;
        }
        .legend-btn:not(.active) {
            opacity: 0.5;
            background-color: transparent;
        }
    </style>
</head>
<body class="bg-gray-900 text-white">

    <div class="container mx-auto p-4 sm:p-6 lg:p-8">
        
        <header class="flex flex-col sm:flex-row justify-between items-center mb-8">
            <div>
                 <h1 class="text-2xl sm:text-3xl font-bold text-white">Top 100 Crypto Dashboard</h1>
                 <p class="text-md text-gray-400 mt-1">Real-time market data powered by the Binance API</p>
            </div>
             <div class="mt-4 sm:mt-0">
                 <label for="timezone-selector" class="text-sm text-gray-400 mr-2">Timezone:</label>
                 <select id="timezone-selector" class="bg-gray-800 border border-gray-600 text-white text-sm rounded-lg focus:ring-blue-500 focus:border-blue-500 p-2"></select>
             </div>
        </header>

        <nav class="flex justify-center mb-8 bg-gray-800 p-2 rounded-xl border border-gray-700 max-w-md mx-auto">
            <button id="btn-analysis" class="w-1/2 py-2 px-4 rounded-lg text-lg font-semibold transition-colors duration-300">Coin Analysis</button>
            <button id="btn-insights" class="w-1/2 py-2 px-4 rounded-lg text-lg font-semibold transition-colors duration-300">Market Insights</button>
        </nav>

        <div id="page-analysis">
            <header class="text-center mb-8">
                <h1 id="analysis-header" class="text-3xl sm:text-4xl font-bold">Loading Top Coins...</h1>
                <p id="analysis-status" class="text-gray-400 mt-2">Loading initial data...</p>
                <p id="vpn-suggestion" class="text-yellow-400 text-sm mt-2 hidden"></p>
                <div class="mt-6 max-w-xs mx-auto relative" id="coin-search-container">
                    <input type="text" id="coin-search-input" placeholder="Search for a coin..." class="w-full bg-gray-800 border border-gray-600 text-white text-lg rounded-lg focus:ring-blue-500 focus:border-blue-500 block p-3">
                    <div id="coin-dropdown" class="coin-dropdown absolute z-10 w-full mt-1 bg-gray-800 border border-gray-600 rounded-lg shadow-lg max-h-60 overflow-y-auto hidden">
                        <!-- Coin options will be populated here by JS -->
                    </div>
                </div>
            </header>
            
            <div class="mt-8 bg-gray-800 p-6 rounded-xl shadow-lg border border-gray-700">
                <div class="flex justify-between items-center mb-4">
                    <h2 class="text-2xl font-bold">Candlestick Chart</h2>
                    <div id="candlestick-timeframe-selector" class="flex items-center space-x-1 bg-gray-900 p-1 rounded-lg">
                       <button data-tf="1w" class="candle-tf-btn px-3 py-1 rounded-md text-sm font-medium">1W</button>
                       <button data-tf="1d" class="candle-tf-btn px-3 py-1 rounded-md text-sm font-medium">1D</button>
                       <button data-tf="4h" class="candle-tf-btn px-3 py-1 rounded-md text-sm font-medium">4h</button>
                       <button data-tf="1h" class="candle-tf-btn px-3 py-1 rounded-md text-sm font-medium">1h</button>
                       <button data-tf="15m" class="candle-tf-btn px-3 py-1 rounded-md text-sm font-medium">15m</button>
                   </div>
                </div>
                <div class="chart-container" style="height: 60vh;">
                    <canvas id="candlestickChart"></canvas>
                    <div id="candlestickChartMessage" class="chart-message hidden"></div>
                </div>
            </div>

            <div id="analysis-grid" class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-4 sm:gap-6 mt-12"></div>
            
            <div id="deeper-analysis-section" class="mt-12">
                <h2 class="text-2xl font-bold text-center mb-6">Deeper Analysis</h2>
                <div id="deeper-analysis-content" class="space-y-8"></div>
            </div>
        </div>

        <div id="page-insights" class="hidden">
             <header class="text-center mb-8">
                 <h1 class="text-3xl sm:text-4xl font-bold">Crypto Market Insights Dashboard</h1>
                 <p id="insights-update-time" class="text-gray-400 mt-2">Data updated from Binance</p>
             </header>
             <section class="mb-12">
                 <div class="grid grid-cols-1 lg:grid-cols-3 gap-8">
                     <div class="lg:col-span-1 bg-gray-800 p-6 rounded-xl shadow-lg border border-gray-700">
                         <div class="flex flex-col sm:flex-row justify-between items-start sm:items-center mb-4">
                             <h2 id="dominance-table-header" class="text-2xl font-semibold">Volume Dominance</h2>
                             <div id="dominance-timeframe-selector" class="flex items-center space-x-1 bg-gray-900 p-1 rounded-lg mt-2 sm:mt-0">
                                 <button data-tf="24h" class="dom-tf-btn px-3 py-1 rounded-md text-sm font-medium">24h</button>
                                 <button data-tf="4h" class="dom-tf-btn px-3 py-1 rounded-md text-sm font-medium">4h</button>
                                 <button data-tf="1h" class="dom-tf-btn px-3 py-1 rounded-md text-sm font-medium">1h</button>
                                 <button data-tf="1w" class="dom-tf-btn px-3 py-1 rounded-md text-sm font-medium">1w</button>
                             </div>
                         </div>
                        <p class="text-sm text-gray-400 mt-2 mb-4">Measures a coin's share of total trading volume, indicating market attention and liquidity.</p>
                         <div class="table-container">
                             <table class="w-full text-left"><thead class="sticky top-0 bg-gray-800"><tr><th class="p-2 text-sm">#</th><th class="p-2 text-sm">Symbol</th><th class="p-2 text-sm text-right">Volume</th><th class="p-2 text-sm text-right">Dominance</th></tr></thead><tbody id="dominance-table-body"></tbody></table>
                         </div>
                     </div>
                     <div class="lg:col-span-2 bg-gray-800 p-6 rounded-xl shadow-lg border border-gray-700 chart-container">
                         <canvas id="dominanceChart"></canvas>
                         <div id="dominanceChartMessage" class="chart-message hidden"></div>
                     </div>
                 </div>
             </section>
             <section>
                 <div class="grid grid-cols-1 lg:grid-cols-3 gap-8">
                     <div class="lg:col-span-1 bg-gray-800 p-6 rounded-xl shadow-lg border border-gray-700">
                         <div class="flex flex-col sm:flex-row justify-between items-start sm:items-center mb-4">
                             <h2 id="rank-table-header" class="text-2xl font-semibold">Performance Ranking</h2>
                             <div class="flex items-center space-x-2 mt-2 sm:mt-0">
                                 <div id="rank-timeframe-selector" class="flex items-center space-x-1 bg-gray-900 p-1 rounded-lg">
                                     <button data-tf="24h" class="rank-tf-btn px-3 py-1 rounded-md text-sm font-medium">24h</button>
                                     <button data-tf="4h" class="rank-tf-btn px-3 py-1 rounded-md text-sm font-medium">4h</button>
                                     <button data-tf="1h" class="rank-tf-btn px-3 py-1 rounded-md text-sm font-medium">1h</button>
                                     <button data-tf="1w" class="rank-tf-btn px-3 py-1 rounded-md text-sm font-medium">1w</button>
                                 </div>
                             </div>
                         </div>
                        <p class="text-sm text-gray-400 mt-2 mb-4">Ranks coins by price change from the start of the timeframe to gauge market momentum.</p>
                         <div class="table-container">
                             <table class="w-full text-left"><thead class="sticky top-0 bg-gray-800">
                                <tr>
                                    <th class="p-3 text-sm">#</th>
                                    <th class="p-3 text-sm">Symbol</th>
                                    <th class="p-3 text-sm text-right">Start Price (T-1)</th>
                                    <th class="p-3 text-sm text-right">Current Price (T0)</th>
                                    <th class="p-3 text-sm text-right">Change (%)</th>
                                </tr>
                             </thead><tbody id="rank-table-body"></tbody></table>
                         </div>
                     </div>
                      <div class="lg:col-span-2 bg-gray-800 p-6 rounded-xl shadow-lg border border-gray-700 chart-container">
                          <div class="flex justify-between items-center mb-4">
                              <div id="rank-chart-legend" class="flex flex-wrap items-center gap-x-2 gap-y-2 text-xs"></div>
                              <div id="rank-scale-selector" class="flex items-center space-x-1 bg-gray-900 p-1 rounded-lg">
                                  <button data-scale="linear" class="rank-scale-btn px-3 py-1 rounded-md text-sm font-medium">Linear</button>
                                  <button data-scale="log" class="rank-scale-btn px-3 py-1 rounded-md text-sm font-medium">Log</button>
                              </div>
                          </div>
                          <canvas id="rankChart"></canvas>
                          <div id="rankChartMessage" class="chart-message hidden"></div>
                      </div>
                 </div>
             </section>
        </div>
        
        <footer class="text-center text-gray-500 mt-12">
            <p>&copy; 2025 Adiyat Coto. All Rights Reserved.</p>
            <p class="text-sm mt-1">Data provided by the Binance API. Not financial advice.</p>
        </footer>
    </div>

    <script>
        // --- Global Elements and State ---
        const pageAnalysis = document.getElementById('page-analysis');
        const pageInsights = document.getElementById('page-insights');
        const btnAnalysis = document.getElementById('btn-analysis');
        const btnInsights = document.getElementById('btn-insights');

        let analysisInterval;
        let dominanceInterval, rankInterval;
        let dominanceChart, rankChart, candlestickChart;
        let originalRankChartStyles = {};
        let selectedSymbol = '';
        let currentStatus = 'loading';
        let selectedCandlestickTimeframe = '1d';
        let selectedDominanceTimeframe = '24h';
        let selectedRankTimeframe = '24h';
        let selectedRankScale = 'linear';
        let selectedTimezone = 'Asia/Jakarta';
        let top100SymbolsCache = [];
        let lastFetchedRankData = null; 
        let rankLegendState = {
            btc: true,
            dominance: true,
            gainer: true,
            loser: true,
            other: true
        };

        const timeframesConfig = [
            { label: '5 Minutes', interval: '5m' }, { label: '15 Minutes', interval: '15m' },
            { label: '30 Minutes', interval: '30m' }, { label: '1 Hour', interval: '1h' },
            { label: '4 Hours', interval: '4h' }, { label: '1 Day', interval: '1d' },
            { label: '1 Week', interval: '1w' },
        ];
        
        // --- API Fallback Logic ---
        const binanceApiBases = ['https://api.binance.com', 'https://api1.binance.com', 'https://api2.binance.com', 'https://api3.binance.com'];

        async function fetchWithFallbacks(endpoint) {
            for (const base of binanceApiBases) {
                try {
                    const response = await fetch(`${base}${endpoint}`);
                    if (response.ok) {
                        return response;
                    }
                } catch (error) {
                    console.warn(`Failed to fetch from ${base}${endpoint}:`, error);
                }
            }
            throw new Error(`Failed to fetch from all available API endpoints for: ${endpoint}`);
        }

        // --- Page Switching Logic ---
        function switchPage(pageToShow) {
            clearInterval(analysisInterval);
            clearInterval(dominanceInterval);
            clearInterval(rankInterval);

            if (dominanceChart) { dominanceChart.destroy(); dominanceChart = null; }
            if (rankChart) { rankChart.destroy(); rankChart = null; }
            if (candlestickChart) { candlestickChart.destroy(); candlestickChart = null; }

            const pages = { analysis: pageAnalysis, insights: pageInsights };
            const buttons = { analysis: btnAnalysis, insights: btnInsights };
            
            Object.keys(pages).forEach(key => {
                const isPage = key === pageToShow;
                pages[key].classList.toggle('hidden', !isPage);
                buttons[key].classList.toggle('bg-blue-600', isPage);
                buttons[key].classList.toggle('text-white', isPage);
                buttons[key].classList.toggle('bg-gray-700', !isPage);
                buttons[key].classList.toggle('text-gray-300', !isPage);
            });

            if (pageToShow === 'analysis') initializeAnalysisPage();
            else if (pageToShow === 'insights') initializeInsightsPage();
        }
        
        async function getTop100Symbols() {
            if (top100SymbolsCache.length > 0) return top100SymbolsCache;
            try {
                const stablecoinBases = ['USDC', 'FDUSD', 'TUSD', 'USDP', 'BUSD', 'DAI']; 
                const response = await fetchWithFallbacks('/api/v3/ticker/24hr'); 
                if (!response.ok) throw new Error('Network response was not ok');
                const tickers = await response.json();
                top100SymbolsCache = tickers
                    .filter(t => {
                        if (!t.symbol.endsWith('USDT')) return false;
                        const baseAsset = t.symbol.slice(0, -4);
                        return !stablecoinBases.includes(baseAsset);
                    })
                    .sort((a, b) => parseFloat(b.quoteVolume) - parseFloat(a.quoteVolume))
                    .slice(0, 100)
                    .map(t => t.symbol);
                
                if (top100SymbolsCache.length === 0) {
                    throw new Error("Filtered list of coins is empty. Check stablecoin filter.");
                }
                return top100SymbolsCache;
            } catch (error) {
                console.error("Failed to fetch top 100 symbols:", error);
                analysisHeader.textContent = "API Connection Error";
                analysisStatus.textContent = "Error: Could not connect to Binance API.";
                updateStatus('offline');
                const vpnSuggestion = document.getElementById('vpn-suggestion');
                vpnSuggestion.textContent = "Suggestion: If you are in a restricted region, using a VPN may resolve this issue.";
                vpnSuggestion.classList.remove('hidden');
                return [];
            }
        }

        // --- Coin Analysis Page ---
        const analysisHeader = document.getElementById('analysis-header');
        const analysisStatus = document.getElementById('analysis-status');
        const coinSearchInput = document.getElementById('coin-search-input');
        const coinDropdown = document.getElementById('coin-dropdown');
        const coinSearchContainer = document.getElementById('coin-search-container');
        const analysisGrid = document.getElementById('analysis-grid');
        const deeperAnalysisContent = document.getElementById('deeper-analysis-content');

        function initializeAnalysisPage() {
            if (coinDropdown.children.length === 0) {
                fetchTopCoinsForAnalysis();
            } else {
                updateDashboardForCoin(coinSearchInput.value);
            }
            createInitialAnalysisCards();
        }

        async function fetchTopCoinsForAnalysis() {
            try {
                const symbols = await getTop100Symbols();
                if (symbols.length === 0) throw new Error("Could not retrieve coin list.");
                coinDropdown.innerHTML = '';
                symbols.forEach(symbol => {
                    const coinOption = document.createElement('div');
                    coinOption.className = 'p-3 hover:bg-gray-700 cursor-pointer text-white';
                    coinOption.textContent = symbol;
                    coinOption.dataset.value = symbol;
                    coinOption.addEventListener('click', () => {
                        coinSearchInput.value = symbol;
                        coinDropdown.classList.add('hidden');
                        updateDashboardForCoin(symbol);
                    });
                    coinDropdown.appendChild(coinOption);
                });
                const firstSymbol = symbols[0];
                coinSearchInput.value = firstSymbol;
                updateDashboardForCoin(firstSymbol);
            } catch (error) {
                console.error("Failed to fetch coin list:", error);
                analysisHeader.textContent = "Failed to Load Coins";
                updateStatus('offline');
                analysisStatus.textContent = "Error: Could not load coin list.";
                const vpnSuggestion = document.getElementById('vpn-suggestion');
                vpnSuggestion.textContent = "Suggestion: If you are in a restricted region, using a VPN may resolve this issue.";
                vpnSuggestion.classList.remove('hidden');
                coinSearchInput.placeholder = "Error loading coins";
            }
        }

        function updateDashboardForCoin(symbol) {
            selectedSymbol = symbol;
            analysisHeader.textContent = `Detailed Analysis: ${symbol}`;
            document.getElementById('vpn-suggestion').classList.add('hidden');
            if (analysisInterval) clearInterval(analysisInterval);
            fetchDataForAnalysis();
            fetchDeeperAnalysisData(symbol);
            handleCandlestickTimeframeChange(selectedCandlestickTimeframe);
            analysisInterval = setInterval(fetchDataForAnalysis, 30000); 
        }
        
        function createInitialAnalysisCards() {
            analysisGrid.innerHTML = '';
            timeframesConfig.forEach((tf, index) => {
                const card = document.createElement('div');
                card.id = `card-${index}`;
                card.className = 'bg-gray-800 p-5 rounded-xl shadow-lg border border-gray-700';
                card.innerHTML = `
                    <div class="flex justify-between items-start mb-2">
                        <h2 class="text-xl font-semibold">${tf.label}</h2>
                        <span id="update-time-${index}" class="text-xs text-gray-500">Loading...</span>
                    </div>
                    <p class="text-gray-400 text-xs mb-3" id="period-${index}">Period: -</p>
                    <div class="grid grid-cols-2 gap-2 text-center my-4">
                        <div>
                            <p class="text-gray-400 text-xs uppercase tracking-wider">T-1 Close</p>
                            <p id="t1-price-${index}" class="text-lg font-semibold text-gray-300 mt-1">---</p>
                        </div>
                        <div>
                            <p class="text-gray-400 text-xs uppercase tracking-wider">T0 Price</p>
                            <p id="t0-price-${index}" class="text-lg font-bold text-gray-500 mt-1" data-price="0">---</p>
                        </div>
                    </div>
                    <div class="mt-2 flex justify-between items-center p-3 bg-gray-900 rounded-lg">
                        <span class="text-sm font-medium">Change</span>
                        <div id="change-${index}" class="flex items-center text-lg font-bold price-neutral">
                            <span>--- %</span>
                        </div>
                    </div>`;
                analysisGrid.appendChild(card);
            });
        }
        
        async function fetchDataForAnalysis() {
            if (!selectedSymbol) return;
            const promises = timeframesConfig.map(tf => fetchWithFallbacks(`/api/v3/klines?symbol=${selectedSymbol}&interval=${tf.interval}&limit=2`).then(res => res.json()));
            const results = await Promise.allSettled(promises);
            let hasFailed = results.some(r => r.status === 'rejected');
            updateStatus(hasFailed ? 'offline' : 'online');
            results.forEach((result, index) => {
                if (result.status === 'fulfilled' && Array.isArray(result.value) && result.value.length >= 2) {
                    const [kline_t1, kline_t0] = result.value;
                    const close_t1 = parseFloat(kline_t1[4]);
                    const close_t0 = parseFloat(kline_t0[4]);
                    const change = close_t1 > 0 ? ((close_t0 - close_t1) / close_t1) * 100 : 0;
                    updateAnalysisCard(index, close_t1, close_t0, change, kline_t0[0], kline_t0[6]);
                }
            });
        }
        
        async function fetchDeeperAnalysisData(symbol) {
            deeperAnalysisContent.innerHTML = '<div class="text-center text-gray-400 col-span-full">Loading deeper analysis...</div>';
            try {
                const [hourlyRes, dailyRes] = await Promise.all([
                    fetchWithFallbacks(`/api/v3/klines?symbol=${symbol}&interval=1h&limit=1000`),
                    fetchWithFallbacks(`/api/v3/klines?symbol=${symbol}&interval=1d&limit=1000`)
                ]);

                if (!hourlyRes.ok || !dailyRes.ok) {
                    throw new Error(`API request failed. Status: ${hourlyRes.statusText} / ${dailyRes.statusText}`);
                }

                const hourlyKlines = await hourlyRes.json();
                const dailyKlines = await dailyRes.json();

                if (hourlyKlines.length < 24) throw new Error("Not enough hourly data for analysis.");
                if (dailyKlines.length < 7) throw new Error("Not enough daily data for analysis.");

                const analysis = analyzeHistoricalData(hourlyKlines, dailyKlines);
                updateDeeperAnalysisUI(analysis);

            } catch(e) {
                console.error("Deeper analysis failed:", e);
                deeperAnalysisContent.innerHTML = `<div class="text-center text-red-400 col-span-full">Could not load deeper analysis data: ${e.message}</div>`;
            }
        }

        function analyzeHistoricalData(hourlyKlines, dailyKlines) {
            const now = new Date();
            const last30d = dailyKlines.filter(k => (now - k[0]) <= 30 * 24 * 60 * 60 * 1000);
            const last7d = dailyKlines.filter(k => (now - k[0]) <= 7 * 24 * 60 * 60 * 1000);
            const last24h = hourlyKlines.filter(k => (now - k[0]) <= 24 * 60 * 60 * 1000);
            
            const findHighLow = (data) => {
                if (data.length === 0) return { high: {price: 0, time: 0}, low: {price: 0, time: 0} };
                return data.reduce((acc, kline) => {
                    const high = parseFloat(kline[2]);
                    const low = parseFloat(kline[3]);
                    if (high > acc.high.price) acc.high = { price: high, time: kline[0] };
                    if (low < acc.low.price) acc.low = { price: low, time: kline[0] };
                    return acc;
                }, { high: { price: -1, time: 0 }, low: { price: Infinity, time: 0 } });
            };
            
            const monthlyStats = findHighLow(last30d);
            const weeklyStats = findHighLow(last7d);
            const dailyStats = findHighLow(last24h);

            const hourlyPerformance = Array(24).fill(0).map(() => ({ sum: 0, count: 0 }));
            const dailyPerformance = Array(7).fill(0).map(() => ({ sum: 0, count: 0 }));
            const weeklyPerformance = new Map();
            const monthlyPerformance = Array(12).fill(0).map(() => ({ sum: 0, count: 0 }));

            dailyKlines.forEach(k => {
                const date = new Date(k[0]);
                const open = parseFloat(k[1]);
                const close = parseFloat(k[4]);
                const day = date.getUTCDay();
                const month = date.getUTCMonth();

                const weekOfMonth = Math.ceil(date.getUTCDate() / 7);
                const weekKey = `W${weekOfMonth}`;

                if (!weeklyPerformance.has(weekKey)) weeklyPerformance.set(weekKey, { sum: 0, count: 0 });

                if (open > 0) {
                    const performance = ((close - open) / open) * 100;
                    dailyPerformance[day].sum += performance;
                    dailyPerformance[day].count++;
                    monthlyPerformance[month].sum += performance;
                    monthlyPerformance[month].count++;
                    
                    const weekData = weeklyPerformance.get(weekKey);
                    weekData.sum += performance;
                    weekData.count++;
                }
            });
            
            hourlyKlines.forEach(k => {
                 const date = new Date(k[0]);
                const open = parseFloat(k[1]);
                const close = parseFloat(k[4]);
                const hour = date.getUTCHours();
                if(open > 0) {
                    const performance = ((close - open) / open) * 100;
                    hourlyPerformance[hour].sum += performance;
                    hourlyPerformance[hour].count++;
                }
            });
            
            return { 
                weeklyStats, dailyStats, monthlyStats,
                hourlyAvgPerf: hourlyPerformance.map(h => h.count > 0 ? h.sum / h.count : 0),
                dailyAvgPerf: dailyPerformance.map(d => d.count > 0 ? d.sum / d.count : 0),
                weeklyAvgPerf: ['W1', 'W2', 'W3', 'W4', 'W5'].map(key => {
                    const data = weeklyPerformance.get(key);
                    return (data && data.count > 0) ? data.sum / data.count : 0;
                }),
                monthlyAvgPerf: monthlyPerformance.map(m => m.count > 0 ? m.sum / m.count : 0),
            };
        }
        
        function updateDeeperAnalysisUI(analysis) {
            const formatTs = (ts) => ts ? new Date(ts).toLocaleString('en-US', { dateStyle: 'medium', timeStyle: 'short', timeZone: selectedTimezone }) : 'N/A';
            deeperAnalysisContent.innerHTML = `
                <div class="grid grid-cols-1 md:grid-cols-3 gap-6">
                    <div class="bg-gray-800 p-5 rounded-xl">
                        <h3 class="font-bold text-lg mb-2">Monthly High/Low (30d)</h3>
                        <p class="text-green-400">High: $${analysis.monthlyStats.high.price.toLocaleString('en-US')} <span class="text-xs text-gray-400">on ${formatTs(analysis.monthlyStats.high.time)}</span></p>
                        <p class="text-red-400">Low: $${analysis.monthlyStats.low.price.toLocaleString('en-US')} <span class="text-xs text-gray-400">on ${formatTs(analysis.monthlyStats.low.time)}</span></p>
                    </div>
                    <div class="bg-gray-800 p-5 rounded-xl">
                        <h3 class="font-bold text-lg mb-2">Weekly High/Low (7d)</h3>
                        <p class="text-green-400">High: $${analysis.weeklyStats.high.price.toLocaleString('en-US')} <span class="text-xs text-gray-400">on ${formatTs(analysis.weeklyStats.high.time)}</span></p>
                        <p class="text-red-400">Low: $${analysis.weeklyStats.low.price.toLocaleString('en-US')} <span class="text-xs text-gray-400">on ${formatTs(analysis.weeklyStats.low.time)}</span></p>
                    </div>
                    <div class="bg-gray-800 p-5 rounded-xl">
                        <h3 class="font-bold text-lg mb-2">Daily High/Low (24h)</h3>
                        <p class="text-green-400">High: $${analysis.dailyStats.high.price.toLocaleString('en-US')} <span class="text-xs text-gray-400">on ${formatTs(analysis.dailyStats.high.time)}</span></p>
                        <p class="text-red-400">Low: $${analysis.dailyStats.low.price.toLocaleString('en-US')} <span class="text-xs text-gray-400">on ${formatTs(analysis.dailyStats.low.time)}</span></p>
                    </div>
                </div>
                <div class="bg-gray-800 p-5 rounded-xl mt-6">
                    <h3 class="font-bold text-lg mb-2">Hourly Performance Heatmap (Historical Avg)</h3>
                    <p class="text-xs text-gray-400 mb-4">This heatmap shows the average percentage change for each hour of the day (UTC) over all available historical data (up to 1000 hours). Green indicates hours that have historically been bullish on average, while red indicates bearish hours. The intensity of the color represents the strength of the average move.</p>
                    <canvas id="hourlyHeatmap" height="50" class="w-full"></canvas>
                </div>
                <div class="bg-gray-800 p-5 rounded-xl mt-6">
                    <h3 class="font-bold text-lg mb-2">Daily Performance Heatmap (Historical Avg)</h3>
                    <p class="text-xs text-gray-400 mb-4">This chart shows the average performance for each day of the week over all available data. It helps identify if there are recurring bullish or bearish patterns on specific days.</p>
                    <canvas id="dailyHeatmap" height="50"></canvas>
                </div>
                 <div class="bg-gray-800 p-5 rounded-xl mt-6">
                    <h3 class="font-bold text-lg mb-2">Weekly Performance Heatmap (Historical Avg)</h3>
                    <p class="text-xs text-gray-400 mb-4">This chart shows the average performance for each week of the month (W1 = first 7 days, etc.) over all available data, helping to spot intra-month patterns.</p>
                    <canvas id="weeklyHeatmap" height="50"></canvas>
                </div>
                <div class="bg-gray-800 p-5 rounded-xl mt-6">
                    <h3 class="font-bold text-lg mb-2">Monthly Performance Heatmap (Historical Avg)</h3>
                    <p class="text-xs text-gray-400 mb-4">This chart shows the average performance for each month of the year over all available data, helping to spot seasonal patterns.</p>
                    <canvas id="monthlyHeatmap" height="50"></canvas>
                </div>
            `;
            
            const now = new Date();
            const currentUTCHour = now.getUTCHours();
            const currentUTCDay = now.getUTCDay();
            const currentUTCWeek = Math.ceil(now.getUTCDate() / 7);
            const currentUTCMonth = now.getUTCMonth();

            createHeatmap('hourlyHeatmap', analysis.hourlyAvgPerf, Array.from(Array(24).keys()).map(h => `${h}`), currentUTCHour);
            createHeatmap('dailyHeatmap', analysis.dailyAvgPerf, ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'], currentUTCDay);
            createHeatmap('weeklyHeatmap', analysis.weeklyAvgPerf, ['W1', 'W2', 'W3', 'W4', 'W5'], currentUTCWeek - 1);
            createHeatmap('monthlyHeatmap', analysis.monthlyAvgPerf, ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'], currentUTCMonth);
        }
        
        function createHeatmap(canvasId, data, labels, highlightIndex) {
            const canvas = document.getElementById(canvasId);
            if (!canvas) return;
            const ctx = canvas.getContext('2d');
            canvas.width = canvas.offsetWidth;
            const cellWidth = canvas.width / labels.length;
            const maxAbs = Math.max(0.001, ...data.map(d => Math.abs(d)));

            data.forEach((value, index) => {
                const intensity = maxAbs > 0 ? Math.min(1, Math.abs(value) / maxAbs) : 0;
                const color = value >= 0 
                    ? `rgba(34, 197, 94, ${0.1 + intensity * 0.9})`
                    : `rgba(239, 68, 68, ${0.1 + intensity * 0.9})`;
                
                ctx.fillStyle = color;
                ctx.fillRect(index * cellWidth, 0, cellWidth - 1, canvas.height - 25);

                if (index === highlightIndex) {
                    ctx.save();
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.9)';
                    ctx.lineWidth = 2;
                    ctx.shadowColor = 'rgba(255, 255, 255, 1)';
                    ctx.shadowBlur = 10;
                    ctx.strokeRect(index * cellWidth + 1, 1, cellWidth - 3, canvas.height - 27);
                    ctx.restore();
                }

                ctx.fillStyle = '#E5E7EB';
                ctx.textAlign = 'center';
                ctx.font = '12px Inter';
                ctx.fillText(labels[index], index * cellWidth + cellWidth / 2, canvas.height - 5);
            });
        }


        function updateAnalysisCard(index, price_t1, price_t0, change, startTime, endTime) {
            const card = document.getElementById(`card-${index}`);
            const t1PriceEl = document.getElementById(`t1-price-${index}`);
            const t0PriceEl = document.getElementById(`t0-price-${index}`);
            const changeEl = document.getElementById(`change-${index}`);
            const updateTimeEl = document.getElementById(`update-time-${index}`);
            const periodEl = document.getElementById(`period-${index}`);

            const oldPrice = parseFloat(t0PriceEl.dataset.price || 0);
            t0PriceEl.dataset.price = price_t0;

            const formatPrice = (p) => `$${p.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 8 })}`;
            const formatDate = (ts) => new Date(ts).toLocaleString('en-US', { day: '2-digit', month: 'short', hour: '2-digit', minute: '2-digit', timeZone: selectedTimezone });

            t1PriceEl.textContent = formatPrice(price_t1);
            t0PriceEl.textContent = formatPrice(price_t0);
            
            periodEl.textContent = `Period: ${formatDate(startTime)} - ${formatDate(endTime)}`;
            updateTimeEl.textContent = `Updated: ${new Date().toLocaleTimeString('en-US', {timeZone: selectedTimezone})}`;
            
            let changeClass = change > 0 ? 'price-up' : (change < 0 ? 'price-down' : 'price-neutral');
            let arrow = change > 0 ? '▲' : (change < 0 ? '▼' : '');
            
            changeEl.innerHTML = `<span class="mr-1">${arrow}</span> <span>${change.toFixed(3)}%</span>`;
            
            t0PriceEl.className = `text-lg font-bold mt-1 ${changeClass}`;
            changeEl.className = `flex items-center text-lg font-bold ${changeClass}`;
            t1PriceEl.className = `text-lg font-semibold text-gray-300 mt-1`;

            card.classList.remove('flash-green', 'flash-red');
            if (!isNaN(oldPrice) && oldPrice !== 0) {
                if(price_t0 > oldPrice) {
                    card.classList.add('flash-green');
                } else if (price_t0 < oldPrice) {
                    card.classList.add('flash-red');
                }
            }
        }

        function updateStatus(newStatus) {
            if (currentStatus === newStatus) return;
            currentStatus = newStatus;
            analysisStatus.textContent = `Feed Status: ${newStatus.toUpperCase()}`;
            analysisStatus.className = `mt-2 ${newStatus === 'online' ? 'text-green-500' : 'text-red-500'}`;
        }

        async function fetchCandlestickData(symbol, tf) {
            const loadingIcon = `<div class="flex justify-center items-center h-full"><svg class="animate-spin -ml-1 mr-3 h-8 w-8" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg>Loading Chart Data...</div>`;
            showChartMessage('candlestickChart', loadingIcon);
            try {
                const limit = (tf === '1w') ? 300 : (tf === '1d' ? 365 : 500);
                const response = await fetchWithFallbacks(`/api/v3/klines?symbol=${symbol}&interval=${tf}&limit=${limit}`);
                const data = await response.json();
                if (!data || data.length === 0) throw new Error('No data returned from API');

                const parsedData = data.map(d => ({
                    x: d[0],
                    o: parseFloat(d[1]),
                    h: parseFloat(d[2]),
                    l: parseFloat(d[3]),
                    c: parseFloat(d[4])
                }));
                createOrUpdateCandlestickChart(parsedData, tf);
            } catch (error) {
                console.error(`Error fetching candlestick data for ${tf}:`, error);
                showChartMessage('candlestickChart', 'Error: Failed to load chart data.');
            }
        }

        function createOrUpdateCandlestickChart(data, tf) {
            hideChartMessage('candlestickChart');
            if (candlestickChart) {
                candlestickChart.destroy();
                candlestickChart = null;
            }
            const ctx = document.getElementById('candlestickChart').getContext('2d');
            
            candlestickChart = new Chart(ctx, {
                type: 'candlestick',
                data: {
                    datasets: [{
                        label: selectedSymbol,
                        data: data
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            adapters: { date: { zone: selectedTimezone } },
                            ticks: { color: '#9CA3AF' }
                        },
                        y: {
                            ticks: { color: '#9CA3AF' }
                        }
                    },
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const raw = context.raw;
                                    return [
                                        `O: ${raw.o.toFixed(4)}`,
                                        `H: ${raw.h.toFixed(4)}`,
                                        `L: ${raw.l.toFixed(4)}`,
                                        `C: ${raw.c.toFixed(4)}`
                                    ];
                                }
                            }
                        }
                    }
                }
            });
        }
        
        function handleCandlestickTimeframeChange(tf) {
            selectedCandlestickTimeframe = tf;
            document.querySelectorAll('.candle-tf-btn').forEach(btn => {
                btn.classList.toggle('bg-blue-600', btn.dataset.tf === tf);
                btn.classList.toggle('text-white', btn.dataset.tf === tf);
                btn.classList.toggle('bg-gray-700', btn.dataset.tf !== tf);
            });
            if (selectedSymbol) {
                fetchCandlestickData(selectedSymbol, tf);
            }
        }
        
        // --- Market Insights Page ---
        const insightsUpdateTimeEl = document.getElementById('insights-update-time');
        const dominanceTableBody = document.getElementById('dominance-table-body');
        const dominanceTableHeader = document.getElementById('dominance-table-header');
        const rankTableBody = document.getElementById('rank-table-body');
        const rankTableHeader = document.getElementById('rank-table-header');
        const rankChartLegend = document.getElementById('rank-chart-legend');

        function initializeInsightsPage() {
            handleDominanceTimeframeChange(selectedDominanceTimeframe);
            handleRankTimeframeChange(selectedRankTimeframe);
            handleRankScaleChange(selectedRankScale);
        }
        
        function showTableLoading(tbody, message, colspan = 4) {
            tbody.innerHTML = `<tr><td colspan="${colspan}" class="text-center p-8 text-gray-400">${message}</td></tr>`;
        }
        
        const chartColors = ['#3B82F6', '#10B981', '#F59E0B', '#EF4444', '#8B5CF6', '#EC4899', '#6366F1', '#14B8A6', '#F97316', '#6B7280'];
        
        function showChartMessage(chartId, message) {
            if(chartId === 'dominanceChart' && dominanceChart) { dominanceChart.destroy(); dominanceChart = null; }
            if(chartId === 'rankChart' && rankChart) { rankChart.destroy(); rankChart = null; }
            if(chartId === 'candlestickChart' && candlestickChart) { candlestickChart.destroy(); candlestickChart = null; }

            const canvas = document.getElementById(chartId);
            const messageEl = document.getElementById(`${chartId}Message`);
            if(canvas) canvas.style.display = 'none';
            if(messageEl) {
                messageEl.innerHTML = message;
                messageEl.classList.remove('hidden');
            }
        }

        function hideChartMessage(chartId) {
            const canvas = document.getElementById(chartId);
            const messageEl = document.getElementById(`${chartId}Message`);
            if(canvas) canvas.style.display = 'block';
            if(messageEl) messageEl.classList.add('hidden');
        }

        const klineParams = {
            '24h': { interval: '5m', limit: 288 },
            '4h': { interval: '1m', limit: 240 },
            '1h': { interval: '1m', limit: 60 },
            '1w': { interval: '4h', limit: 42 }
        };

        async function fetchDominanceData(tf) {
            const loadingIcon = `<div class="flex justify-center items-center"><svg class="animate-spin -ml-1 mr-3 h-5 w-5" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg>Loading ${tf} chart data...</div>`;
            showChartMessage('dominanceChart', loadingIcon);
            try {
                const { interval, limit } = klineParams[tf];
                const topSymbols = await getTop100Symbols();
                const promises = topSymbols.map(symbol => fetchWithFallbacks(`/api/v3/klines?symbol=${symbol}&interval=${interval}&limit=${limit}`).then(res => res.json()));
                const results = await Promise.allSettled(promises);
                const klineData = results.map((res, i) => (res.status === 'fulfilled' && res.value) ? {symbol: topSymbols[i], data: res.value} : {symbol: topSymbols[i], data: []}).filter(d => d.data && d.data.length > 0);
                if (klineData.length === 0 || klineData[0].data.length === 0) throw new Error("No kline data found");
                
                const timestamps = klineData[0].data.map(k => k[0]);
                const historicalData = timestamps.map((ts, i) => {
                    const point = { timestamp: ts };
                    klineData.forEach(coin => {
                        const kline = coin.data[i];
                        if (kline) point[coin.symbol] = parseFloat(kline[7]);
                    });
                    return point;
                });
                
                const lastPoint = historicalData[historicalData.length - 1];
                const dominanceData = topSymbols.map(s => ({ symbol: s, volume: lastPoint[s] || 0 })).sort((a,b) => b.volume - a.volume);
                updateDominanceTable(dominanceData);
                createOrUpdateDominanceChart(historicalData, dominanceData.slice(0, 10).map(d => d.symbol), tf);
                insightsUpdateTimeEl.textContent = `Last updated: ${new Date().toLocaleTimeString('en-US', {timeZone: selectedTimezone})}`;
            } catch (error) {
                console.error(`Error fetching dominance data for ${tf}:`, error);
                dominanceTableBody.innerHTML = `<tr><td colspan="4" class="text-center p-8 text-red-400">Failed to load dominance data.</td></tr>`;
                showChartMessage('dominanceChart', 'Error: Failed to load chart data.');
            }
        }

        async function fetchRankData(tf) {
             const loadingIcon = `<div class="flex justify-center items-center"><svg class="animate-spin -ml-1 mr-3 h-5 w-5" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg>Loading ${tf} chart data...</div>`;
               showChartMessage('rankChart', loadingIcon);
               try {
                   const { interval, limit } = klineParams[tf];
                   const topSymbols = await getTop100Symbols();
                   const promises = topSymbols.map(symbol => fetchWithFallbacks(`/api/v3/klines?symbol=${symbol}&interval=${interval}&limit=${limit}`).then(res => res.json()));
                   const results = await Promise.allSettled(promises);
                   
                   const historicalPerformances = new Map();
                   let timeframeVolumes = new Map();
                   const priceDetails = new Map(); 

                   results.forEach((res, i) => {
                       if (res.status === 'fulfilled' && res.value && res.value.length > 1) {
                           const symbol = topSymbols[i];
                           const startPrice = parseFloat(res.value[0][1]);
                           const currentPrice = parseFloat(res.value[res.value.length - 1][4]);
                           priceDetails.set(symbol, { startPrice, currentPrice });

                           let totalVolume = 0;
                           if (startPrice > 0) {
                               const performanceData = res.value.map(k => {
                                   totalVolume += parseFloat(k[7]);
                                   return { t: k[0], p: ((parseFloat(k[4]) - startPrice) / startPrice) * 100 };
                               });
                               historicalPerformances.set(symbol, performanceData);
                               timeframeVolumes.set(symbol, totalVolume);
                           }
                       }
                   });
                   if (historicalPerformances.size === 0) throw new Error("No performance data calculated.");

                   let rankedCoins = Array.from(historicalPerformances.entries()).map(([symbol, data]) => {
                        const prices = priceDetails.get(symbol);
                        return {
                            symbol,
                            priceChangePercent: data[data.length - 1].p,
                            t1Price: prices.startPrice,
                            t0Price: prices.currentPrice
                        };
                    }).sort((a, b) => b.priceChangePercent - a.priceChangePercent);
                   
                   const top20ByDominance = Array.from(timeframeVolumes.entries()).sort(([, volA], [, volB]) => volB - volA).slice(0, 20).map(([symbol]) => symbol);
                   const top10 = rankedCoins.slice(0, 10).map(c => c.symbol);
                   const bottom10 = rankedCoins.slice(-10).map(c => c.symbol);

                   rankedCoins = rankedCoins.map(coin => {
                       let category = 'other';
                       if (coin.symbol === 'BTCUSDT') {
                           category = 'btc';
                       } else if (top20ByDominance.includes(coin.symbol)) {
                           category = 'dominance';
                       } else if (top10.includes(coin.symbol)) {
                           category = 'gainer';
                       } else if (bottom10.includes(coin.symbol)) {
                           category = 'loser';
                       }
                       return { ...coin, category };
                   });

                   lastFetchedRankData = { historicalPerformances, top20ByDominance, top10, bottom10 };

                   updateRankTable(rankedCoins);
                   createOrUpdateRankChart(historicalPerformances, tf, top20ByDominance, top10, bottom10);
              } catch (error) {
                   console.error(`Error fetching rank data for ${tf}:`, error);
                   rankTableBody.innerHTML = `<tr><td colspan="5" class="text-center p-8 text-red-400">Failed to load performance data.</td></tr>`;
                   showChartMessage('rankChart', 'Error: Failed to load chart data.');
              }
        }
        
        function createOrUpdateDominanceChart(historicalData, topSymbols, tf) {
            hideChartMessage('dominanceChart');
            if (dominanceChart) dominanceChart.destroy();
            
            let labelFormatOptions = (tf === '1w')
                ? { day: 'numeric', month: 'short', year: 'numeric' }
                : { day: 'numeric', month: 'short', hour: '2-digit', minute: '2-digit' };

            const ctx = document.getElementById('dominanceChart').getContext('2d');
            const datasets = topSymbols.map((symbol, i) => ({
                label: symbol.replace('USDT',''),
                data: historicalData.map(point => {
                    const totalVol = topSymbols.reduce((acc, s) => acc + (point[s] || 0), 0);
                    return totalVol > 0 ? (point[symbol] / totalVol) * 100 : 0;
                }),
                backgroundColor: chartColors[i % chartColors.length] + '80',
                borderColor: chartColors[i % chartColors.length],
                fill: true, pointRadius: 0, tension: 0.3
            }));

            dominanceChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: historicalData.map(d => new Date(d.timestamp).toLocaleString('en-GB', {...labelFormatOptions, timeZone: selectedTimezone})),
                    datasets: datasets
                },
                options: { responsive: true, maintainAspectRatio: false, plugins: { legend: { display: false }, tooltip: { callbacks: { label: (c) => `${c.dataset.label}: ${c.raw.toFixed(2)}%` } } }, scales: { y: { stacked: true, min: 0, max: 100, ticks: { color: '#9CA3AF', callback: (v) => v + '%' } }, x: { ticks: { color: '#9CA3AF', maxRotation: 0, autoSkip: true, maxTicksLimit: 10 } } }, interaction: { mode: 'nearest', intersect: false } }
            });
        }
        
        function createOrUpdateRankChart(historicalPerformances, tf, top20ByDominance, top10, bottom10) {
            hideChartMessage('rankChart');
            if (rankChart) { rankChart.destroy(); rankChart = null; }
            if (historicalPerformances.size === 0) return;

            let labelFormatOptions = (tf === '1w')
                ? { day: 'numeric', month: 'short', year: 'numeric' }
                : { day: 'numeric', month: 'short', hour: '2-digit', minute: '2-digit' };

            const ctx = document.getElementById('rankChart').getContext('2d');
            
            originalRankChartStyles = {};
            const datasets = Array.from(historicalPerformances.entries()).map(([symbol, data]) => {
                let color, width, category;
                
                if (symbol === 'BTCUSDT') {
                    width = 3.0; color = '#FBBF24'; category = 'btc';
                } else if (top20ByDominance.includes(symbol)) {
                    width = 2.0; color = '#38BDF8'; category = 'dominance';
                } else if (top10.includes(symbol)) {
                    width = 1.5; color = '#22c55e'; category = 'gainer';
                } else if (bottom10.includes(symbol)) {
                    width = 1.5; color = '#ef4444'; category = 'loser';
                } else {
                    width = 1.0; color = '#E5E7EB80'; category = 'other';
                }
                
                originalRankChartStyles[symbol] = { color, width };
                
                let chartData = data.map(d => d.p);
                if (selectedRankScale === 'log') {
                     chartData = data.map(d => {
                         const p = d.p;
                         if (p === 0) return 0;
                         return Math.sign(p) * Math.log10(Math.abs(p) + 1);
                     });
                }

                return { 
                    label: symbol, 
                    data: chartData, 
                    borderColor: color, 
                    borderWidth: width, 
                    pointRadius: 0, 
                    tension: 0.1, 
                    category: category,
                    hidden: !rankLegendState[category]
                };
            });
            
            rankChart = new Chart(ctx, {
                 type: 'line',
                 data: {
                     labels: historicalPerformances.values().next().value.map(d => new Date(d.t).toLocaleString('en-GB', {...labelFormatOptions, timeZone: selectedTimezone})),
                     datasets: datasets
                 },
                 options: { responsive: true, maintainAspectRatio: false, plugins: { legend: { display: false }, tooltip: { callbacks: { label: function(c) { let r = c.raw; if (selectedRankScale === 'log') { r = Math.sign(r) * (Math.pow(10, Math.abs(r)) - 1); } return `${c.dataset.label}: ${r.toFixed(2)}%`; } } } }, scales: { y: { type: 'linear', ticks: { color: '#9CA3AF', callback: (v) => { if (selectedRankScale === 'log') { const o = Math.sign(v) * (Math.pow(10, Math.abs(v)) - 1); return o.toFixed(0) + '%'; } return v.toFixed(0) + '%'; } } }, x: { ticks: { color: '#9CA3AF', maxRotation: 0, autoSkip: true, maxTicksLimit: 10 } } }, interaction: { mode: 'nearest', intersect: false } }
            });
        }

        function formatVolume(num) {
            if (num >= 1e9) return (num / 1e9).toFixed(2) + ' B';
            if (num >= 1e6) return (num / 1e6).toFixed(2) + ' M';
            return num.toLocaleString('en-US');
        }

        function updateRankTable(rankedCoins) {
            let tableHtml = '';
            const formatPrice = (p) => p.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 8 });

            rankedCoins.forEach((coin, index) => {
                const change = coin.priceChangePercent;
                const changeClass = change >= 0 ? 'price-up' : 'price-down';
                const sign = change >= 0 ? '+' : '';

                let highlightClass = '';
                if (coin.category === 'btc') {
                    highlightClass = 'highlight-btc';
                } else if (coin.category === 'gainer') {
                    highlightClass = 'highlight-gainer';
                } else if (coin.category === 'loser') {
                    highlightClass = 'highlight-loser';
                } else if (coin.category === 'dominance') {
                    highlightClass = 'highlight-dominance';
                }

                tableHtml += `
                    <tr class="border-b border-gray-700 hover:bg-gray-700 ${highlightClass}" data-symbol="${coin.symbol}" data-category="${coin.category}">
                        <td class="p-3">${index + 1}</td>
                        <td class="p-3 font-semibold">${coin.symbol}</td>
                        <td class="p-3 text-right text-gray-400">${formatPrice(coin.t1Price)}</td>
                        <td class="p-3 text-right font-semibold ${changeClass}">${formatPrice(coin.t0Price)}</td>
                        <td class="p-3 text-right font-medium ${changeClass}">${sign}${change.toFixed(2)}%</td>
                    </tr>`;
            });
            rankTableBody.innerHTML = tableHtml;

            rankTableBody.querySelectorAll('tr').forEach(row => {
                row.addEventListener('mouseover', handleRankHover);
                row.addEventListener('mouseout', handleRankMouseOut);
            });
            filterRankTableVisibility();
        }
        
        function handleRankHover(event) {
            if (!rankChart) return;
            const symbol = event.currentTarget.dataset.symbol;
            rankChart.data.datasets.forEach(dataset => {
                if (dataset.label === symbol) {
                    dataset.borderWidth = 4;
                    dataset.borderColor = '#A78BFA'; // Purple highlight
                }
            });
            rankChart.update('none');
        }

        function handleRankMouseOut() {
            if (!rankChart) return;
            rankChart.data.datasets.forEach(dataset => {
                const style = originalRankChartStyles[dataset.label];
                if (style) {
                    dataset.borderWidth = style.width;
                    dataset.borderColor = style.color;
                }
            });
            rankChart.update('none');
        }
        
        function handleTimeframeChange(type, tf) {
            const stateVar = `selected${type}Timeframe`;
            const headerEl = document.getElementById(`${type.toLowerCase()}-table-header`);
            const selectorEl = document.getElementById(`${type.toLowerCase()}-timeframe-selector`);
            const fetchFn = type === 'Dominance' ? fetchDominanceData : fetchRankData;
            const intervalVar = `${type.toLowerCase()}Interval`;

            window[stateVar] = tf;
            selectorEl.querySelectorAll('button').forEach(btn => {
                btn.classList.toggle('bg-blue-600', btn.dataset.tf === tf);
                btn.classList.toggle('text-white', btn.dataset.tf === tf);
                btn.classList.toggle('text-gray-400', btn.dataset.tf !== tf);
            });
            headerEl.textContent = `${type} (${tf})`;
            
            clearInterval(window[intervalVar]);
            const colspan = type === 'Dominance' ? 4 : 5;
            showTableLoading(document.getElementById(`${type.toLowerCase()}-table-body`), `Loading ${tf} data...`, colspan);
            fetchFn(tf);
            window[intervalVar] = setInterval(() => fetchFn(tf), 60000);
        }
        
        function handleRankScaleChange(scale) {
            selectedRankScale = scale;
            document.querySelectorAll('.rank-scale-btn').forEach(btn => {
                btn.classList.toggle('bg-blue-600', btn.dataset.scale === scale);
                btn.classList.toggle('text-white', btn.dataset.scale === scale);
                btn.classList.toggle('text-gray-400', btn.dataset.scale !== scale);
            });
            
            if (rankChart && lastFetchedRankData) {
                createOrUpdateRankChart(
                    lastFetchedRankData.historicalPerformances,
                    selectedRankTimeframe,
                    lastFetchedRankData.top20ByDominance,
                    lastFetchedRankData.top10,
                    lastFetchedRankData.bottom10
                );
            } else {
                handleRankTimeframeChange(selectedRankTimeframe);
            }
        }
        
        function handleRankLegendToggle(event) {
            const button = event.target.closest('.legend-btn');
            if (!button || !rankChart) return;

            const category = button.dataset.category;
            button.classList.toggle('active');
            const isActive = button.classList.contains('active');

            rankLegendState[category] = isActive;

            rankChart.data.datasets.forEach(dataset => {
                if (dataset.category === category) {
                    dataset.hidden = !isActive;
                }
            });
            rankChart.update();
            filterRankTableVisibility();
        }

        function filterRankTableVisibility() {
            if (!rankTableBody) return;
            const rows = rankTableBody.querySelectorAll('tr[data-category]');
            rows.forEach(row => {
                const category = row.dataset.category;
                if (rankLegendState.hasOwnProperty(category)) {
                    row.style.display = rankLegendState[category] ? '' : 'none';
                }
            });
        }

        function updateDominanceTable(data) {
            const totalVolume = data.reduce((acc, coin) => acc + coin.volume, 0);
            let tableHtml = '';
            data.forEach((coin, index) => {
                const dominance = totalVolume > 0 ? (coin.volume / totalVolume) * 100 : 0;
                tableHtml += `<tr class="border-b border-gray-700"><td class="p-2 text-sm">${index + 1}</td><td class="p-2 font-semibold text-sm">${coin.symbol.replace('USDT','')}</td><td class="p-2 text-right text-sm">${formatVolume(coin.volume)}</td><td class="p-2 text-right font-medium text-sm">${dominance.toFixed(2)}%</td></tr>`;
            });
            dominanceTableBody.innerHTML = tableHtml;
        }

        function updateRankLegend() {
            rankChartLegend.innerHTML = `
                <button data-category="btc" class="legend-btn active flex items-center bg-gray-700 px-2 py-1 rounded"><span class="h-3 w-3 rounded-full mr-2" style="background-color: #FBBF24;"></span>Bitcoin</button>
                <button data-category="dominance" class="legend-btn active flex items-center bg-gray-700 px-2 py-1 rounded"><span class="h-3 w-3 rounded-full mr-2" style="background-color: #38BDF8;"></span>Top 20 by Dominance</button>
                <button data-category="gainer" class="legend-btn active flex items-center bg-gray-700 px-2 py-1 rounded"><span class="h-3 w-3 rounded-full mr-2" style="background-color: #22c55e;"></span>Top 10 Gainers</button>
                <button data-category="loser" class="legend-btn active flex items-center bg-gray-700 px-2 py-1 rounded"><span class="h-3 w-3 rounded-full mr-2" style="background-color: #ef4444;"></span>Bottom 10 Losers</button>
                <button data-category="other" class="legend-btn active flex items-center bg-gray-700 px-2 py-1 rounded"><span class="h-3 w-3 rounded-full mr-2 border border-gray-500" style="background-color: #E5E7EB80;"></span>Others</button>
            `;
        }
        
        function populateTimezoneSelector() {
            const selector = document.getElementById('timezone-selector');
            const timezones = Intl.supportedValuesOf('timeZone');
            
            const offsets = timezones.map(tz => {
                try {
                    const offsetString = new Intl.DateTimeFormat('en-US', { timeZone: tz, timeZoneName: 'longOffset' }).formatToParts().find(part => part.type === 'timeZoneName').value;
                    const offset = offsetString.replace('GMT', '');
                    return { tz, offset };
                } catch (e) {
                    return { tz, offset: '' };
                }
            }).filter(o => o.offset);

            offsets.sort((a, b) => {
                const offsetA = parseInt(a.offset.replace(':', ''));
                const offsetB = parseInt(b.offset.replace(':', ''));
                return offsetA - offsetB;
            });

            offsets.forEach(({tz, offset}) => {
                const option = document.createElement('option');
                option.value = tz;
                option.textContent = `(UTC${offset}) ${tz.replace(/_/g, ' ')}`;
                if (tz === 'Asia/Jakarta') option.selected = true;
                selector.appendChild(option);
            });

            selector.addEventListener('change', (e) => {
                selectedTimezone = e.target.value;
                const currentPage = !pageAnalysis.classList.contains('hidden') ? 'analysis' : 'insights';
                if(currentPage === 'analysis') {
                    updateDashboardForCoin(selectedSymbol);
                } else if(currentPage === 'insights') {
                    handleDominanceTimeframeChange(selectedDominanceTimeframe);
                    handleRankTimeframeChange(selectedRankTimeframe);
                }
            });
        }

        const handleDominanceTimeframeChange = (tf) => handleTimeframeChange('Dominance', tf);
        const handleRankTimeframeChange = (tf) => handleTimeframeChange('Rank', tf);

        // --- Initialization ---
        document.addEventListener('DOMContentLoaded', () => {
            btnAnalysis.addEventListener('click', () => switchPage('analysis'));
            btnInsights.addEventListener('click', () => switchPage('insights'));
            
            // New Searchable Dropdown Logic
            coinSearchInput.addEventListener('focus', () => {
                coinDropdown.classList.remove('hidden');
            });
            coinSearchInput.addEventListener('input', () => {
                const filter = coinSearchInput.value.toUpperCase();
                const options = coinDropdown.getElementsByTagName('div');
                for (let i = 0; i < options.length; i++) {
                    const txtValue = options[i].textContent || options[i].innerText;
                    if (txtValue.toUpperCase().indexOf(filter) > -1) {
                        options[i].style.display = "";
                    } else {
                        options[i].style.display = "none";
                    }
                }
            });
            document.addEventListener('click', (event) => {
                if (!coinSearchContainer.contains(event.target)) {
                    coinDropdown.classList.add('hidden');
                }
            });


            document.getElementById('dominance-timeframe-selector').addEventListener('click', (e) => { if (e.target.classList.contains('dom-tf-btn')) handleDominanceTimeframeChange(e.target.dataset.tf); });
            document.getElementById('rank-timeframe-selector').addEventListener('click', (e) => { if (e.target.classList.contains('rank-tf-btn')) handleRankTimeframeChange(e.target.dataset.tf); });
            document.getElementById('rank-scale-selector').addEventListener('click', (e) => { if (e.target.classList.contains('rank-scale-btn')) handleRankScaleChange(e.target.dataset.scale); });
            rankChartLegend.addEventListener('click', handleRankLegendToggle);
            document.getElementById('candlestick-timeframe-selector').addEventListener('click', (e) => { if (e.target.classList.contains('candle-tf-btn')) handleCandlestickTimeframeChange(e.target.dataset.tf); });
            
            populateTimezoneSelector();
            updateRankLegend();
            switchPage('analysis');
        });
    </script>

</body>
</html>

