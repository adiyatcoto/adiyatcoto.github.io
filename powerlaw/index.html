<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Power Law Generator | Auto Slope and R² Confidence Detection</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&family=Inter:wght@300;400;500;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-pure: #000000;
            --accent: #fbce03;
            --up: #10b981;
            --down: #f43f5e;
            --grid-line: #111827; 
        }

        html, body {
            background-color: #000000 !important;
            color: #f8fafc; 
            font-family: 'Inter', sans-serif;
            margin: 0;
            padding: 0;
            height: 100%;
            width: 100%;
            overflow: hidden; /* Default Desktop: Hidden */
            display: flex;
            flex-direction: column;
        }

        /* Styling Grid */
        .grid line { stroke: var(--grid-line); stroke-opacity: 0.8; shape-rendering: crispEdges; }
        .grid path { stroke-width: 0; }
        .axis-label { font-size: 11px; fill: #475569; font-family: 'JetBrains Mono', monospace; }
        
        /* Candlestick Styling */
        .candle-up { fill: var(--up); stroke: var(--up); stroke-width: 0.5; }
        .candle-down { fill: var(--down); stroke: var(--down); stroke-width: 0.5; }
        .wick { stroke: #1e293b; stroke-width: 0.8; }
        
        /* Power Law Main Line */
        .regression-line { 
            stroke: var(--accent); 
            stroke-width: 3.5; 
            fill: none; 
            pointer-events: visibleStroke;
            transition: stroke-width 0.1s ease-out;
        }

        /* Deviation Bands */
        .band-line { 
            stroke-width: 1.2; 
            fill: none; 
            pointer-events: none; 
            transition: stroke-width 0.1s ease-out, stroke-opacity 0.1s ease-out;
        }

        /* Hitbox */
        .line-hitbox {
            fill: none;
            stroke: transparent;
            stroke-width: 20;
            cursor: crosshair;
            pointer-events: visibleStroke;
        }
        
        .chart-svg { cursor: crosshair; user-select: none; background-color: #000000 !important; }
        
        /* Tooltip */
        .tooltip {
            position: absolute;
            pointer-events: none;
            background: rgba(10, 10, 10, 0.98);
            border: 1px solid #1e293b;
            padding: 12px;
            border-radius: 4px;
            font-size: 12px;
            display: none;
            z-index: 100;
            font-family: 'JetBrains Mono', monospace;
            box-shadow: 0 10px 25px rgba(0,0,0,1);
            transform: translateZ(0);
        }

        .header-ui { 
            background: #000000 !important; 
            border-bottom: 1px solid #0f172a; 
        }
        
        .stat-card {
            background: #050505;
            border: 1px solid #1e293b;
            padding: 6px 14px;
            border-radius: 4px;
            min-width: 150px;
        }

        .chart-area-clip { clip-path: url(#clip); }

        #autocomplete-list {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: #050505;
            border: 1px solid #1e293b;
            z-index: 9999; 
            max-height: 250px;
            overflow-y: auto;
            display: none;
            box-shadow: 0 10px 25px rgba(0,0,0,0.8);
        }

        .suggestion-item {
            padding: 10px 14px;
            cursor: pointer;
            font-size: 13px;
            display: flex;
            justify-content: space-between;
            border-bottom: 1px solid #111827;
        }
        .suggestion-item:hover { background: #111827; }

        /* Oscillator Styles */
        .osc-line-main { stroke: #2de1fc; stroke-width: 1.5; fill: none; }
        .osc-zero-line { stroke: #475569; stroke-width: 1; stroke-dasharray: 2,2; opacity: 0.5; }
        .osc-band-upper { fill: #ff1e56; fill-opacity: 0.08; }
        .osc-band-lower { fill: #2164f3; fill-opacity: 0.08; }
        .osc-label-sigma { font-size: 9px; fill: #64748b; font-family: 'JetBrains Mono', monospace; }

        /* Draggable Windows */
        .draggable-panel {
            position: absolute;
            background: rgba(5, 5, 5, 0.95);
            border: 1px solid #1e293b;
            border-radius: 8px;
            backdrop-filter: blur(8px);
            box-shadow: 0 20px 40px rgba(0,0,0,0.8);
            z-index: 50;
            display: flex;
            flex-direction: column; 
            overflow: hidden;
            transition: opacity 0.2s;
        }
        
        .drag-handle {
            cursor: grab;
            user-select: none;
        }
        .drag-handle:active {
            cursor: grabbing;
        }

        /* Dynamic Font Size for Windows Toggle Buttons */
        .toggle-btn {
            font-size: clamp(9px, 0.8vw, 11px); /* Dynamic Font Increased */
            font-family: 'JetBrains Mono', monospace;
            text-transform: uppercase;
            padding: 4px 10px;
            border-radius: 4px;
            border: 1px solid #1e293b;
            color: #64748b;
            background: #050505;
            cursor: pointer;
            transition: all 0.2s;
        }
        .toggle-btn.active {
            background: #1e293b;
            color: #fbce03;
            border-color: #fbce03;
        }
        .toggle-btn:hover { color: #fff; border-color: #475569; }

        /* Custom Scrollbar */
        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-track { background: #000; }
        ::-webkit-scrollbar-thumb { background: #333; border-radius: 3px; }

        /* --- SCANNER TABLE STYLES --- */
        .scanner-table th {
            font-size: 9px; color: #475569; text-transform: uppercase;
            padding: 10px 8px; text-align: left; border-bottom: 1px solid #1e293b;
            cursor: pointer; transition: color 0.2s; user-select: none;
        }
        .scanner-table th:hover { color: #fbce03; background: #0f172a; }
        .scanner-table td {
            font-size: 11px; padding: 8px; font-family: 'JetBrains Mono', monospace;
            border-bottom: 1px solid #0f172a;
        }
        .scanner-row { transition: background 0.1s; }
        .scanner-row:hover { background: #1e293b; cursor: pointer; }
        .highlight-score { color: #fbce03; font-weight: bold; }

        /* --- MOBILE/TABLET/ZOOM RESPONSIVE OVERRIDES (< 1280px) --- */
        @media (max-width: 1280px) {
            html, body {
                overflow-y: auto !important; /* Enable scroll */
                height: auto !important;
                position: static !important;
                display: block !important;
            }

            .axis-label { font-size: 9px !important; }

            header {
                height: auto !important;
                flex-direction: column;
                padding: 1rem !important;
                gap: 1.25rem;
            }

            .header-info-container {
                position: relative !important;
                top: auto !important; right: auto !important; left: auto !important; transform: none !important;
                width: 100% !important;
                margin-bottom: 10px;
            }

            main {
                height: auto !important;
                display: flex !important;
                flex-direction: column;
                overflow: visible !important;
            }

            #chart-container {
                height: 60vh !important; 
                min-height: 400px;
                width: 100% !important;
                flex-shrink: 0;
                border-bottom: 1px solid #1e293b;
            }

            .draggable-panel {
                position: relative !important; 
                top: auto !important; left: auto !important; bottom: auto !important; right: auto !important;
                width: 100% !important;
                margin-top: 0;
                border-radius: 0 !important;
                border-left: 0 !important; border-right: 0 !important;
                box-shadow: none !important;
                border-bottom: 1px solid #1e293b;
            }

            #legend-panel { order: 1; height: auto !important; max-height: 300px; }
            #oscillator-panel { order: 2; height: 400px !important; }
            #scanner-panel { order: 3; height: 500px !important; }
            #metrics-panel { order: 4; height: 500px !important; }

            .draggable-panel button { display: block; }
            .drag-handle { cursor: default !important; }
            .try-text { display: none; }
            .stat-card { width: 100%; display: flex; justify-content: space-between; align-items: center; }
            .stat-card span { text-align: left; }
        }
    </style>
</head>
<body>

    <!-- Header: Menghilangkan z-index root dan membiarkannya relative bebas agar tidak memotong panel saat digeser -->
    <header class="header-ui flex-shrink-0 flex flex-col xl:grid xl:grid-cols-[1fr_auto_1.3fr] items-center px-4 lg:px-10 py-4 relative gap-4 xl:gap-0">
        
        <!-- Left Section: Title & Input (MOVED TO TOP FOR MOBILE) -->
        <div class="header-title-section flex flex-col xl:flex-row items-center xl:space-x-8 space-y-4 xl:space-y-0 w-full xl:w-auto xl:col-start-1 xl:row-start-1 xl:justify-self-start mb-2 xl:mb-0"> 
            <div class="flex flex-col justify-center text-center xl:text-left">
                <h1 class="text-[clamp(18px,1.7vw,24px)] font-black text-white italic tracking-tighter uppercase leading-tight">
                    <span class="text-yellow-500">POWER LAW GENERATOR</span>
                </h1>
                <p class="text-[clamp(9px,0.8vw,10px)] text-slate-400 font-mono tracking-widest uppercase italic mb-1">Auto slope and R² confidence detection</p>
            </div>
            
            <div class="flex flex-col space-y-1 w-full xl:w-auto relative z-[100]">
                <div class="relative flex items-center bg-black rounded-lg border border-slate-900 group focus-within:border-yellow-500 transition-all w-full">
                    <div class="p-1.5 flex items-center space-x-2 w-full justify-center">
                        <input id="tickerInput" type="text" value="BTC" autocomplete="off" class="bg-transparent border-none px-3 py-1 text-[clamp(11px,1.0vw,13px)] focus:outline-none uppercase w-28 font-bold text-yellow-500 text-center xl:text-left" placeholder="Ticker...">
                        <button id="updateBtn" class="bg-yellow-600 hover:bg-yellow-500 text-black px-6 py-2 rounded text-[clamp(10px,0.9vw,11px)] font-black transition-all uppercase">
                            Sync
                        </button>
                    </div>
                    <div id="autocomplete-list" class="rounded-b-lg shadow-2xl"></div>
                </div>
                <div class="try-text text-[clamp(9px,0.8vw,10px)] text-slate-600 font-mono italic text-right pr-1 xl:block hidden">Try: ETH, SOL, ADA, etc...</div>
            </div>
        </div>

        <!-- Info Box -->
        <div class="header-info-container relative xl:static w-full xl:w-auto flex justify-center pointer-events-none xl:mt-0 xl:col-start-2 xl:row-start-1 mb-2 xl:mb-0">
            <div class="px-6 py-2 bg-[#050505] border border-slate-900 rounded-lg shadow-2xl backdrop-blur-sm max-w-lg text-center">
                <p class="text-[clamp(9px,0.8vw,10px)] text-slate-400 font-sans leading-relaxed">
                    <span class="text-yellow-500 font-bold uppercase tracking-widest text-[clamp(10px,0.9vw,11px)]">Log-Log Power Law Model</span>
                    <span class="block mt-0.5 text-slate-500">
                        This chart uses a <span class="text-slate-300 font-medium">double-logarithmic scale</span> (Time & Price) to visualize exponential network growth as a linear trend. 
                        The central regression line represents the asset's theoretical <span class="text-slate-300 font-medium">"Fair Value"</span> baseline, 
                        while the corridors indicate statistical deviation (<span class="font-serif italic font-bold">σ</span>) often associated with market tops and bottoms.
                    </span>
                </p>
            </div>
        </div>

        <!-- Right Section: Windows & Stats -->
        <div class="flex flex-col xl:flex-row items-center xl:space-x-4 space-y-4 xl:space-y-0 w-full xl:w-auto relative xl:col-start-3 xl:row-start-1 xl:justify-self-end">
            <div class="flex flex-col space-y-1 mr-0 xl:mr-4 w-full xl:w-auto items-center">
                <div class="text-[clamp(8px,0.7vw,9px)] text-slate-600 font-bold uppercase tracking-widest text-center">Windows</div>
                <div class="flex space-x-2">
                    <button id="toggleLegend" class="toggle-btn active" onclick="togglePanel('legend-panel', this)">Legend</button>
                    <button id="toggleOsc" class="toggle-btn" onclick="togglePanel('oscillator-panel', this)">Oscillator</button>
                    <button id="toggleScanner" class="toggle-btn" onclick="togglePanel('scanner-panel', this)">Scanner</button>
                    <button id="toggleMetrics" class="toggle-btn" onclick="togglePanel('metrics-panel', this)">Metrics</button>
                </div>
            </div>

            <div class="flex w-full xl:w-auto gap-2 xl:gap-4 flex-col xl:flex-row xl:items-center">
                <div class="stat-card flex flex-col items-end">
                    <span class="text-[clamp(8px,0.7vw,9px)] text-slate-600 font-bold uppercase tracking-widest leading-none mb-1">Growth Slope (m)</span>
                    <span id="slopeVal" class="text-yellow-500 font-mono text-[clamp(15px,1.3vw,20px)] font-bold">0.0000</span>
                    <span class="text-[clamp(7px,0.6vw,8px)] text-slate-500 font-mono italic text-right hidden xl:block">Linear regression slope</span>
                </div>
                <div class="stat-card flex flex-col items-end">
                    <span class="text-[clamp(8px,0.7vw,9px)] text-slate-600 font-bold uppercase tracking-widest leading-none mb-1">R² Confidence</span>
                    <span id="r2Val" class="text-emerald-500 font-mono text-[clamp(15px,1.3vw,20px)] font-bold">0.0000</span>
                    <span class="text-[clamp(7px,0.6vw,8px)] text-slate-500 font-mono italic text-right hidden xl:block">Coefficient of determination</span>
                </div>
            </div>
        </div>
    </header>

    <!-- Main area: Menghilangkan overflow-hidden agar panel bisa diseret ke atas header tanpa terpotong -->
    <main class="flex-1 relative w-full bg-black flex flex-col">
        <!-- Chart Container: Menyembunyikan garis grafik yang meluber ke luar -->
        <div id="chart-container" class="flex-1 w-full relative overflow-hidden"></div>
        <div id="tooltip" class="tooltip"></div>
        
        <!-- LEGEND: Default Open -->
        <div id="legend-panel" class="draggable-panel top-6 left-10 w-[240px]" style="display: flex; z-index: 50;">
            <div class="drag-handle h-9 bg-[#050505] border-b border-slate-800 flex items-center justify-between px-3 relative">
                <span class="text-[10px] font-black text-slate-500 tracking-[0.2em] uppercase">Deviation Corridors</span>
                <button onclick="closePanel('legend-panel', 'toggleLegend')" class="text-slate-500 hover:text-white text-[13px] font-bold px-1 z-50">✕</button>
            </div>
            <div class="p-4 flex flex-col space-y-2 overflow-y-auto">
                <div class="flex items-center justify-between text-[10px] font-bold">
                    <div class="flex items-center space-x-3">
                        <div class="w-3 h-1 bg-[#ff1e56] rounded-full"></div>
                        <span class="text-[#ff1e56]">CYCLE PEAK</span>
                    </div>
                    <span class="text-slate-600">+2.0σ</span>
                </div>
                <div class="flex items-center justify-between text-[10px] font-medium">
                    <div class="flex items-center space-x-3">
                        <div class="w-3 h-[1px] bg-[#ffac41] border-t border-dashed border-[#ffac41]"></div>
                        <span class="text-orange-400">EXTREME HEAT</span>
                    </div>
                    <span class="text-slate-600">+1.5σ</span>
                </div>
                <div class="flex items-center justify-between text-[10px] font-medium">
                    <div class="flex items-center space-x-3">
                        <div class="w-3 h-[1px] bg-[#fffb7d] border-t border-dashed border-[#fffb7d]"></div>
                        <span class="text-yellow-100">OVERBOUGHT</span>
                    </div>
                    <span class="text-slate-600">+1.0σ</span>
                </div>
                <div class="flex items-center justify-between text-[11px] font-black my-1.5 border-y border-slate-900 py-1.5">
                    <div class="flex items-center space-x-3">
                        <div class="w-4 h-1.5 bg-[#fbce03] rounded-full"></div>
                        <span class="text-yellow-400 font-bold uppercase">Fair Value (Mean)</span>
                    </div>
                    <span class="text-yellow-600">0σ</span>
                </div>
                <div class="flex items-center justify-between text-[10px] font-medium">
                    <div class="flex items-center space-x-3">
                        <div class="w-3 h-[1px] bg-[#a3f7bf] border-t border-dashed border-[#a3f7bf]"></div>
                        <span class="text-emerald-300">ACCUMULATION</span>
                    </div>
                    <span class="text-slate-600">-1.0σ</span>
                </div>
                <div class="flex items-center justify-between text-[10px] font-medium">
                    <div class="flex items-center space-x-3">
                        <div class="w-3 h-[1px] bg-[#2de1fc] border-t border-dashed border-[#2de1fc]"></div>
                        <span class="text-cyan-400">DEEP VALUE AREA</span>
                    </div>
                    <span class="text-slate-600">-1.5σ</span>
                </div>
                <div class="flex items-center justify-between text-[10px] font-bold">
                    <div class="flex items-center space-x-3">
                        <div class="w-3 h-1 bg-[#2164f3] rounded-full"></div>
                        <span class="text-[#2164f3]">GENERATIONAL BOTTOM</span>
                    </div>
                    <span class="text-slate-600">-2.0σ</span>
                </div>
            </div>
        </div>

        <!-- OSCILLATOR: Default Closed -->
        <div id="oscillator-panel" class="draggable-panel bottom-10 right-10 w-[840px] h-[440px]" style="display: none; z-index: 50;">
            <div class="drag-handle h-9 border-b border-slate-800 flex items-center justify-between px-3 bg-[#050505] relative flex-shrink-0">
                <span class="text-[10px] font-black text-slate-500 tracking-[0.2em] uppercase hidden sm:inline">Oscillator Comparison</span>
                <span class="text-[10px] font-black text-slate-500 tracking-[0.2em] uppercase sm:hidden">Oscillator</span>
                
                <div class="flex items-center space-x-2 relative">
                    <div class="flex items-center bg-[#0a0a0a] border border-slate-800 rounded px-1.5 py-0.5">
                        <span class="text-[8px] text-slate-500 uppercase tracking-widest mr-1">MAIN:</span>
                        <span id="oscMainTickerLabel" class="text-[9px] font-bold text-cyan-400 uppercase">BTC</span>
                    </div>
                    <span class="text-[9px] text-slate-600 font-bold">+</span>
                    <div class="flex items-center bg-black border border-slate-700 rounded px-1 py-0.5">
                         <span class="text-[8px] text-slate-500 uppercase tracking-widest mr-1 hidden sm:inline">VS (COMMA SEPARATED):</span>
                         <span class="text-[8px] text-slate-500 uppercase tracking-widest mr-1 sm:hidden">VS:</span>
                         <input id="oscCompareInput" type="text" value="" class="bg-transparent border-none text-[9px] font-bold text-yellow-500 w-28 focus:outline-none uppercase text-center" placeholder="ETH, SOL...">
                    </div>
                    <button id="oscModeBtn" onclick="toggleOscMode()" class="text-[9px] bg-slate-800 text-slate-300 px-2 py-0.5 rounded border border-slate-700 hover:bg-slate-700 font-bold transition-all">MODE: %</button>
                    <button id="oscCompareBtn" onclick="runOscillatorAnalysis()" class="text-[9px] bg-emerald-600/10 text-emerald-500 px-2 py-0.5 rounded border border-emerald-500/30 hover:bg-emerald-600 hover:text-black font-bold transition-all uppercase">COMPARE</button>
                    <button onclick="closePanel('oscillator-panel', 'toggleOsc')" class="text-slate-500 hover:text-white text-[13px] font-bold px-1">✕</button>
                </div>
            </div>
            <div id="oscillator-chart" class="flex-1 w-full relative"></div>
        </div>

        <!-- SCANNER: Default Closed -->
        <div id="scanner-panel" class="draggable-panel top-6 right-10 w-[380px] h-[500px]" style="display: none; z-index: 50;">
            <div class="drag-handle h-10 bg-[#050505] border-b border-slate-800 flex items-center justify-between px-4">
                <span class="text-[10px] font-black text-slate-500 tracking-[0.2em] uppercase">Market Alpha Scanner</span>
                <div class="flex items-center space-x-2">
                    <button onclick="runScanner()" class="text-[9px] bg-yellow-600/10 text-yellow-500 px-3 py-1 rounded border border-yellow-500/30 hover:bg-yellow-600 hover:text-black font-bold transition-all">SCAN MARKET (100)</button>
                    <button onclick="closePanel('scanner-panel', 'toggleScanner')" class="text-slate-500 hover:text-white text-[13px] font-bold px-1">✕</button>
                </div>
            </div>
            <div class="flex-1 overflow-y-auto">
                <table class="w-full scanner-table">
                    <thead class="sticky top-0 bg-black z-10">
                        <tr>
                            <th onclick="sortScanner('symbol')" title="Sort by Symbol">Asset</th>
                            <th onclick="sortScanner('slope')" title="Sort by Slope">Slope (m)</th>
                            <th onclick="sortScanner('r2')" title="Sort by R²">R² Conf</th>
                            <th onclick="sortScanner('score')" class="text-yellow-500 font-bold" title="Sort by Score">Power Score</th>
                        </tr>
                    </thead>
                    <tbody id="scanner-body">
                        <tr><td colspan="4" class="text-center py-20 text-[11px] text-slate-600 italic">Click "SCAN" to analyze top 100...</td></tr>
                    </tbody>
                </table>
            </div>
        </div>

        <!-- METRICS HISTORY PANEL (Default Closed) -->
        <div id="metrics-panel" class="draggable-panel bottom-10 left-10 w-[600px] h-[450px]" style="display: none; z-index: 50;">
            <div class="drag-handle h-9 bg-[#050505] border-b border-slate-800 flex items-center justify-between px-3 relative">
                <span class="text-[10px] font-black text-slate-500 tracking-[0.2em] uppercase">Regression Evolution</span>
                <div class="flex items-center space-x-2 relative">
                    <div class="flex items-center bg-[#0a0a0a] border border-slate-800 rounded px-1.5 py-0.5">
                        <span class="text-[8px] text-slate-500 uppercase tracking-widest mr-1">MAIN:</span>
                        <span id="metricsMainTickerLabel" class="text-[9px] font-bold text-cyan-400 uppercase">BTC</span>
                    </div>
                    <span class="text-[9px] text-slate-600 font-bold">+</span>
                    <div class="flex items-center bg-black border border-slate-700 rounded px-1 py-0.5">
                         <span class="text-[8px] text-slate-500 uppercase tracking-widest mr-1 hidden sm:inline">VS (COMMA SEPARATED):</span>
                         <span class="text-[8px] text-slate-500 uppercase tracking-widest mr-1 sm:hidden">VS:</span>
                         <input id="metricsCompareInput" type="text" value="" class="bg-transparent border-none text-[9px] font-bold text-yellow-500 w-28 focus:outline-none uppercase text-center" placeholder="ETH, SOL...">
                    </div>
                    <button id="metricsCompareBtn" onclick="runMetricsAnalysis()" class="text-[9px] bg-emerald-600/10 text-emerald-500 px-2 py-0.5 rounded border border-emerald-500/30 hover:bg-emerald-600 hover:text-black font-bold transition-all uppercase">COMPARE</button>
                    <button onclick="closePanel('metrics-panel', 'toggleMetrics')" class="text-slate-500 hover:text-white text-[13px] font-bold px-1">✕</button>
                </div>
            </div>
            
            <div class="flex-1 flex flex-col p-2 space-y-2 overflow-hidden bg-black/80">
                <div class="flex-1 border border-slate-900 rounded bg-[#050505] relative flex flex-col">
                    <div class="absolute top-2 left-2 text-[9px] font-bold text-yellow-500 uppercase tracking-wider z-10 bg-black/50 px-1">
                        Growth Slope (m) History
                    </div>
                    <div id="slope-history-chart" class="flex-1 w-full h-full"></div>
                </div>
                <div class="flex-1 border border-slate-900 rounded bg-[#050505] relative flex flex-col">
                    <div class="absolute top-2 left-2 text-[9px] font-bold text-emerald-500 uppercase tracking-wider z-10 bg-black/50 px-1">
                        R² Confidence History
                    </div>
                    <div id="r2-history-chart" class="flex-1 w-full h-full"></div>
                </div>
            </div>
        </div>

        <div class="w-full text-center text-[10px] text-slate-600 font-mono tracking-[0.3em] pointer-events-none z-30 uppercase py-6 xl:py-4 xl:absolute xl:bottom-3 relative order-last">
            © 2026 Adiyat Coto
        </div>

        <div id="loader" class="absolute inset-0 bg-black flex items-center justify-center z-50">
            <div class="flex flex-col items-center">
                <div class="w-10 h-10 border-2 border-yellow-500/10 border-t-yellow-500 rounded-full animate-spin"></div>
                <p class="mt-4 text-slate-600 text-[10px] font-bold uppercase tracking-[0.3em] font-mono">Calibrating engine...</p>
            </div>
        </div>
    </main>

    <script>
        /**
         * POWER LAW GENERATOR ENGINE (V8.6 - LAYOUT FIX & OVERALL SIZE BOOST)
         */

        const GENESIS_BLOCK_TIMESTAMP = 1230940800; 
        const SECONDS_IN_DAY = 86400;
        const HARDCODED_API_KEY = "kucd5ccf2da23b5b008ee549b281c29ec08fd342b5a6bc99e206dfa4bbee162431";
        
        const METRIC_COLORS = ['#2de1fc', '#fbce03', '#ff1e56', '#10b981', '#a855f7', '#f97316'];

        const container = d3.select("#chart-container");
        const tooltip = d3.select("#tooltip");
        const tickerInput = document.getElementById('tickerInput');
        const autocompleteList = document.getElementById('autocomplete-list');
        
        let svg, width, height, xScale, yScale, xAxis, yAxis, gX, gY, chartArea;
        let originalXScale, originalYScale;
        let globalData = [], regressionMeta = {};
        let topAssets = []; 
        let currentAnchorTime = GENESIS_BLOCK_TIMESTAMP;
        let lastWindowWidth = window.innerWidth;
        let isSyncing = false; 
        
        let currentMainSymbol = "BTC"; 
        let scannerData = [];
        let sortKey = 'score', sortDir = -1;
        
        // Global state for Oscillator Mode and Cache
        let oscillatorMode = 'PERCENT'; // 'PERCENT' or 'SIGMA'
        let lastOscillatorResults = [];
        let highestZIndex = 50; // Keep track of top window

        function getMargin() {
            return window.innerWidth < 1280 
                ? { top: 20, right: 25, bottom: 40, left: 10 } 
                : { top: 40, right: 90, bottom: 60, left: 20 }; 
        }

        const BANDS_CONFIG = [
            { dev: 2.0, color: '#ff1e56', opacity: 0.8, dash: 'none', weight: 2, label: 'Cycle Peak' }, 
            { dev: 1.5, color: '#ffac41', opacity: 0.5, dash: '6,4', weight: 1, label: 'Extreme Heat' },   
            { dev: 1.0, color: '#fffb7d', opacity: 0.5, dash: '4,4', weight: 1, label: 'Overbought' }, 
            { dev: 0.5, color: '#fbce03', opacity: 0.15, dash: '2,4', weight: 0.8, label: 'Bullish Buffer' }, 
            { dev: -0.5, color: '#fbce03', opacity: 0.15, dash: '2,4', weight: 0.8, label: 'Bearish Buffer' },
            { dev: -1.0, color: '#a3f7bf', opacity: 0.5, dash: '4,4', weight: 1, label: 'Accumulation' }, 
            { dev: -1.5, color: '#2de1fc', opacity: 0.5, dash: '6,4', weight: 1, label: 'Deep Value' },   
            { dev: -2.0, color: '#2164f3', opacity: 0.8, dash: 'none', weight: 2, label: 'Generational Bottom' }  
        ];

        function togglePanel(panelId, btn) {
            const panel = document.getElementById(panelId);
            if (panel.style.display === 'none') {
                panel.style.display = 'flex';
                btn.classList.add('active');
                
                // Bring to front
                highestZIndex++;
                panel.style.zIndex = highestZIndex;

                if (panelId === 'metrics-panel') runMetricsAnalysis();
                if (panelId === 'oscillator-panel') runOscillatorAnalysis();
            } else {
                panel.style.display = 'none';
                btn.classList.remove('active');
            }
        }

        function closePanel(panelId, btnId) {
            document.getElementById(panelId).style.display = 'none';
            document.getElementById(btnId).classList.remove('active');
        }

        function toggleOscMode() {
            oscillatorMode = oscillatorMode === 'PERCENT' ? 'SIGMA' : 'PERCENT';
            const btn = document.getElementById('oscModeBtn');
            btn.innerText = oscillatorMode === 'PERCENT' ? 'MODE: %' : 'MODE: σ';
            btn.style.color = oscillatorMode === 'PERCENT' ? '#cbd5e1' : '#fbce03'; 
            
            if (lastOscillatorResults.length > 0 && document.getElementById('oscillator-panel').style.display !== 'none') {
                renderOscillatorCharts(lastOscillatorResults);
            }
        }

        function makeDraggable(elmnt) {
            let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0;
            const header = elmnt.querySelector('.drag-handle');
            
            const inputs = header.querySelectorAll('input, button');
            inputs.forEach(input => {
                input.onmousedown = (e) => e.stopPropagation();
            });
            
            if (header) {
                header.onmousedown = dragMouseDown;
            } else {
                elmnt.onmousedown = dragMouseDown;
            }

            function dragMouseDown(e) {
                if (window.innerWidth < 1280) return; 

                e = e || window.event;
                e.preventDefault();
                
                // Bring window to front
                highestZIndex++;
                elmnt.style.zIndex = highestZIndex;

                pos3 = e.clientX;
                pos4 = e.clientY;
                document.onmouseup = closeDragElement;
                document.onmousemove = elementDrag;
            }

            function elementDrag(e) {
                e = e || window.event;
                e.preventDefault();
                pos1 = pos3 - e.clientX;
                pos2 = pos4 - e.clientY;
                pos3 = e.clientX;
                pos4 = e.clientY;
                
                let newTop = elmnt.offsetTop - pos2;
                let newLeft = elmnt.offsetLeft - pos1;
                
                // --- BOUNDARY CHECK ---
                // Mencegah window menembus batas atas layar (y = 0)
                if (newTop < 0) {
                    newTop = 0;
                }

                elmnt.style.top = newTop + "px";
                elmnt.style.left = newLeft + "px";
                elmnt.style.bottom = 'auto';
                elmnt.style.right = 'auto';
            }

            function closeDragElement() {
                document.onmouseup = null;
                document.onmousemove = null;
            }
        }

        makeDraggable(document.getElementById("legend-panel"));
        makeDraggable(document.getElementById("oscillator-panel"));
        makeDraggable(document.getElementById("scanner-panel"));
        makeDraggable(document.getElementById("metrics-panel"));

        // Manage Z-Index when panels are clicked anywhere
        document.querySelectorAll('.draggable-panel').forEach(panel => {
            panel.addEventListener('mousedown', function() {
                if (window.innerWidth >= 1280) {
                    highestZIndex++;
                    this.style.zIndex = highestZIndex;
                }
            });
        });

        async function fetchAutocompleteData() {
            try {
                const res = await fetch(`https://min-api.cryptocompare.com/data/top/mktcapfull?limit=100&tsym=USD&api_key=${HARDCODED_API_KEY}`);
                const json = await res.json();
                if (json.Data) {
                    topAssets = json.Data.map(item => ({
                        symbol: item.CoinInfo.Name,
                        fullName: item.CoinInfo.FullName
                    }));
                }
            } catch (e) { console.error("Error fetching coins."); }
        }

        tickerInput.addEventListener('input', () => {
            const val = tickerInput.value.toUpperCase();
            autocompleteList.innerHTML = '';
            if (!val) { autocompleteList.style.display = 'none'; return; }
            const filtered = topAssets.filter(a => a.symbol.includes(val) || a.fullName.toUpperCase().includes(val)).slice(0, 10);
            if (filtered.length > 0) {
                autocompleteList.style.display = 'block';
                filtered.forEach(asset => {
                    const div = document.createElement('div');
                    div.className = 'suggestion-item';
                    div.innerHTML = `<span class="text-yellow-500 font-bold">${asset.symbol}</span> <span class="text-slate-500 text-[10px]">${asset.fullName}</span>`;
                    div.onclick = () => {
                        tickerInput.value = asset.symbol;
                        autocompleteList.style.display = 'none';
                        triggerUpdate();
                    };
                    autocompleteList.appendChild(div);
                });
            } else { autocompleteList.style.display = 'none'; }
        });

        document.addEventListener('click', (e) => {
            if (e.target !== tickerInput) autocompleteList.style.display = 'none';
        });

        tickerInput.addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                e.preventDefault();
                this.blur(); 
                autocompleteList.style.display = 'none'; 
                triggerUpdate();
            }
        });

        document.getElementById('oscCompareInput').addEventListener('keypress', (e) => { if(e.key === 'Enter') runOscillatorAnalysis() });
        document.getElementById('metricsCompareInput').addEventListener('keypress', (e) => { if(e.key === 'Enter') runMetricsAnalysis() });

        function setupCanvas() {
            container.selectAll("*").remove();
            const rect = container.node().getBoundingClientRect();
            const margin = getMargin(); 
            width = rect.width - margin.left - margin.right;
            height = rect.height - margin.top - margin.bottom;

            svg = container.append("svg")
                .attr("width", rect.width)
                .attr("height", rect.height)
                .attr("class", "chart-svg")
                .style("background-color", "#000000");

            svg.append("rect").attr("width", rect.width).attr("height", rect.height).attr("fill", "#000000");
            svg.append("defs").append("clipPath").attr("id", "clip").append("rect").attr("width", width).attr("height", height);
            
            const mainGroup = svg.append("g").attr("transform", `translate(${margin.left},${margin.top})`);
            gX = mainGroup.append("g").attr("class", "grid axis-label").attr("transform", `translate(0,${height})`);
            gY = mainGroup.append("g").attr("class", "grid axis-label").attr("transform", `translate(${width}, 0)`);
            chartArea = mainGroup.append("g").attr("class", "chart-area-clip");
            
            const zoom = d3.zoom().scaleExtent([0.01, 20000]).on("zoom", zoomed);
            svg.call(zoom);
        }

        function updateMainTooltipPosition(e) {
            const mainRect = document.querySelector('main').getBoundingClientRect();
            let xPos = e.clientX - mainRect.left + 15;
            let yPos = e.clientY - mainRect.top + 15;
            if (xPos + 220 > mainRect.width) xPos = (e.clientX - mainRect.left) - 235;
            if (yPos + 100 > mainRect.height) yPos = (e.clientY - mainRect.top) - 115;
            tooltip.style("left", xPos + "px").style("top", yPos + "px");
        }

        function calculateMetricsHistory(data) {
            const history = [];
            let n = 0;
            let sumX = 0; let sumY = 0; let sumXY = 0; let sumXX = 0; let sumYY = 0;
            const startRecord = 90; 

            for (let i = 0; i < data.length; i++) {
                const d = data[i];
                const lnX = Math.log(d.days);
                const lnY = Math.log(d.close);
                n++; sumX += lnX; sumY += lnY; sumXY += lnX * lnY; sumXX += lnX * lnX; sumYY += lnY * lnY;

                if (i >= startRecord) {
                    const denominator = (n * sumXX - sumX * sumX);
                    if (denominator !== 0) {
                        const slope = (n * sumXY - sumX * sumY) / denominator;
                        const numeratorR = (n * sumXY - sumX * sumY);
                        const denomR = Math.sqrt((n * sumXX - sumX * sumX) * (n * sumYY - sumY * sumY));
                        let r2 = 0;
                        if (denomR !== 0) r2 = Math.pow(numeratorR / denomR, 2);

                        history.push({ date: d.date, days: d.days, slope: slope, r2: r2 });
                    }
                }
            }
            return history;
        }

        function renderMetricsCharts(multiData) {
            drawMiniChart("#slope-history-chart", multiData, "slope", null, false); 
            drawMiniChart("#r2-history-chart", multiData, "r2", null, false); 
        }

        function drawMiniChart(containerId, multiData, key, yDomainOverride = null, useLogScale = false) {
            const container = d3.select(containerId);
            container.selectAll("*").remove();

            const rect = container.node().getBoundingClientRect();
            const m = {t: 15, r: 35, b: 20, l: 30}; 
            const w = rect.width - m.l - m.r;
            const h = rect.height - m.t - m.b;

            const svg = container.append("svg").attr("width", rect.width).attr("height", rect.height)
                .append("g").attr("transform", `translate(${m.l},${m.t})`);

            let allDates = [];
            let allValues = [];
            
            multiData.forEach(series => {
                const validHistory = series.history.filter(d => d[key] !== null && isFinite(d[key]));
                series.validHistory = validHistory; 
                validHistory.forEach(d => { allDates.push(d.date); allValues.push(d[key]); });
            });

            if (allValues.length === 0) {
                svg.append("text").attr("x", w/2).attr("y", h/2).attr("text-anchor", "middle").attr("fill", "#666").text("No Data");
                return;
            }

            const x = d3.scaleTime().domain(d3.extent(allDates)).range([0, w]);
            
            let minVal, maxVal;
            if (yDomainOverride) [minVal, maxVal] = yDomainOverride;
            else [minVal, maxVal] = d3.extent(allValues);

            if (Math.abs(maxVal - minVal) < 0.0001) {
                if (minVal === 0) { minVal = 0; maxVal = 1; }
                else { minVal = minVal * 0.9; maxVal = minVal * 1.1; }
            }

            let y;
            if (useLogScale && minVal > 0) {
                const safeMin = Math.max(0.0001, minVal);
                const pad = Math.max((Math.log(maxVal) - Math.log(safeMin)) * 0.1, 0.1);
                y = d3.scaleLog().domain([Math.exp(Math.log(safeMin) - pad), Math.exp(Math.log(maxVal) + pad)]).range([h, 0]);
            } else {
                const padding = (maxVal - minVal) * 0.15; 
                let bottom = minVal - padding;
                let top = maxVal + padding;
                if (key === 'r2') {
                    if (top > 1.0) top = 1.005; 
                    if (bottom < 0) bottom = -0.01; 
                }
                y = d3.scaleLinear().domain([bottom, top]).range([h, 0]);
            }

            if (key === 'r2') {
                 const y1 = y(1);
                 if (y1 >= 0 && y1 <= h) {
                    svg.append("line").attr("x1",0).attr("x2",w).attr("y1", y1).attr("y2", y1).attr("stroke", "#333").attr("stroke-dasharray", "2,2");
                 }
            }

            svg.append("g").attr("transform", `translate(0,${h})`).call(d3.axisBottom(x).ticks(4).tickSize(0).tickPadding(5)).attr("class", "axis-label").select(".domain").remove();

            const yRange = y.domain()[1] - y.domain()[0];
            let formatString = ".2f";
            if (yRange < 0.1) formatString = ".4f"; 
            if (yRange > 100) formatString = ".0f"; 

            svg.append("g")
                .call(d3.axisRight(y).ticks(4).tickSize(w).tickFormat(d3.format(formatString))) 
                .attr("class", "axis-label")
                .call(g => g.select(".domain").remove())
                .call(g => g.selectAll(".tick line").attr("stroke", "#1e293b").attr("stroke-dasharray", "2,2").attr("x1", 0).attr("x2", w))
                .call(g => g.selectAll(".tick text").attr("x", w + 5));

            const focusCircles = [];
            multiData.forEach((series, i) => {
                const color = METRIC_COLORS[i % METRIC_COLORS.length];
                svg.append("path").datum(series.validHistory).attr("fill", "none").attr("stroke", color).attr("stroke-width", 1.5).attr("d", d3.line().x(d => x(d.date)).y(d => y(d[key])));
                focusCircles.push(svg.append("circle").attr("r", 3).attr("fill", color).style("opacity", 0));
            });

            const focusText = svg.append("text").attr("font-size", "9px").attr("font-family", "monospace").attr("text-anchor", "middle").style("opacity", 0).style("pointer-events", "none");

            svg.append("rect").attr("width", w).attr("height", h).attr("fill", "transparent")
                .on("mousemove", function(event) {
                    const [mx] = d3.pointer(event);
                    const dateVal = x.invert(mx);
                    
                    let activeLines = [];
                    let maxVisualY = null; 
                    let minVisualY = null; 

                    multiData.forEach((series, i) => {
                        const idx = d3.bisector(d => d.date).left(series.validHistory, dateVal);
                        if (idx >= 0 && idx < series.validHistory.length) {
                            const d = series.validHistory[idx];
                            if (d && Math.abs(d.date - dateVal) < 86400000 * 3) {
                                const color = METRIC_COLORS[i % METRIC_COLORS.length];
                                const currentY = y(d[key]);
                                focusCircles[i].style("opacity", 1).attr("cx", x(d.date)).attr("cy", currentY);
                                activeLines.push({ text: `${series.symbol}: ${d[key].toFixed(4)}`, color: color, yPos: currentY });
                                if (maxVisualY === null || currentY < maxVisualY) maxVisualY = currentY; 
                                if (minVisualY === null || currentY > minVisualY) minVisualY = currentY; 
                            } else { focusCircles[i].style("opacity", 0); }
                        } else { focusCircles[i].style("opacity", 0); }
                    });

                    if (activeLines.length > 0) {
                        const dateStr = dateVal.toLocaleDateString('en-GB', { day: 'numeric', month: 'short', year: '2-digit' });
                        let tx = mx;
                        if (tx < 50) tx = 50; 
                        if (tx > w - 50) tx = w - 50; 

                        const blockHeight = (activeLines.length + 1) * 13; // slightly more height per line
                        let startY = maxVisualY - blockHeight - 5;
                        if (startY < 10) startY = minVisualY + 15;
                        if (startY + blockHeight > h) startY = 15;

                        focusText.style("opacity", 1).attr("x", tx).attr("y", startY);
                        focusText.selectAll("tspan").remove();
                        focusText.append("tspan").attr("x", tx).attr("dy", 0).attr("fill", "#a1a1aa").text(dateStr);
                        
                        activeLines.forEach((line) => {
                            focusText.append("tspan").attr("x", tx).attr("dy", "1.2em").attr("fill", line.color).text(line.text);
                        });
                    } else {
                        focusText.style("opacity", 0);
                        focusCircles.forEach(c => c.style("opacity", 0));
                    }
                })
                .on("mouseout", () => { focusText.style("opacity", 0); focusCircles.forEach(c => c.style("opacity", 0)); });
        }

        // --- NEW: MULTI-LINE OSCILLATOR RENDERER ---
        function renderOscillatorCharts(multiData) {
            const oscContainer = d3.select("#oscillator-chart");
            oscContainer.selectAll("*").remove();

            if (multiData.length === 0) return;

            const w = oscContainer.node().getBoundingClientRect().width;
            const h = oscContainer.node().getBoundingClientRect().height;
            const m = {t: 20, r: 50, b: 25, l: 20}; 
            const innerW = w - m.l - m.r;
            const innerH = h - m.t - m.b;

            const svg = oscContainer.append("svg").attr("width", w).attr("height", h);
            const g = svg.append("g").attr("transform", `translate(${m.l},${m.t})`);

            let allDates = [];
            multiData.forEach(s => s.ratios.forEach(d => allDates.push(d.date)));
            const oscX = d3.scaleTime().domain(d3.extent(allDates)).range([0, innerW]);

            let oscY, yBandUpper, yBandLower, yZero, tickVals, yFormat;
            const mainSeries = multiData[0]; // To derive bands

            if (oscillatorMode === 'PERCENT') {
                let allValues = [];
                mainSeries.ratios.forEach(d => allValues.push(d.ratio));
                
                const rPlus2 = Math.exp(2 * mainSeries.stdDev);
                const rMinus2 = Math.exp(-2 * mainSeries.stdDev);

                let maxRatio = d3.max(allValues);
                let minRatio = d3.min(allValues);
                maxRatio = Math.max(maxRatio, rPlus2);
                minRatio = Math.min(minRatio, rMinus2);
                const boundary = Math.max(maxRatio, 1/minRatio) * 1.1; 
                
                oscY = d3.scaleLog().domain([1/boundary, boundary]).range([innerH, 0]);
                yBandUpper = oscY(rPlus2);
                yBandLower = oscY(rMinus2);
                yZero = oscY(1);
                tickVals = [boundary, rPlus2, 1, rMinus2, 1/boundary];
                yFormat = d => { const pct = (d - 1) * 100; return (pct > 0 ? "+" : "") + Math.round(pct) + "%"; };
            } else {
                let allSigmas = [];
                multiData.forEach(series => {
                    series.ratios.forEach(d => {
                        const sig = Math.log(d.ratio) / series.stdDev;
                        d.sigma = sig; // Cache sigma computation
                        allSigmas.push(sig);
                    });
                });
                
                let maxSigma = d3.max(allSigmas);
                let minSigma = d3.min(allSigmas);
                maxSigma = Math.max(maxSigma, 2);
                minSigma = Math.min(minSigma, -2);
                const boundSigma = Math.max(maxSigma, Math.abs(minSigma)) * 1.1;

                oscY = d3.scaleLinear().domain([-boundSigma, boundSigma]).range([innerH, 0]);
                yBandUpper = oscY(2);
                yBandLower = oscY(-2);
                yZero = oscY(0);
                tickVals = [boundSigma, 2, 0, -2, -boundSigma];
                yFormat = d => (d > 0 ? "+" : "") + d.toFixed(1) + "σ";
            }

            g.append("rect").attr("x", 0).attr("width", innerW).attr("y", 0).attr("height", Math.max(0, yBandUpper)).attr("class", "osc-band-upper");
            g.append("rect").attr("x", 0).attr("width", innerW).attr("y", yBandLower).attr("height", Math.max(0, innerH - yBandLower)).attr("class", "osc-band-lower");
            g.append("line").attr("x1", 0).attr("x2", innerW).attr("y1", yZero).attr("y2", yZero).attr("class", "osc-zero-line");
            
            g.append("text").attr("x", innerW + 4).attr("y", yBandUpper + 3).text("+2σ").attr("class", "osc-label-sigma");
            g.append("text").attr("x", innerW + 4).attr("y", yBandLower + 3).text("-2σ").attr("class", "osc-label-sigma");

            const yAxisOsc = d3.axisRight(oscY).tickValues(tickVals).tickSize(innerW).tickFormat(yFormat);

            g.append("g").attr("class", "grid axis-label").call(yAxisOsc).call(g => g.select(".domain").remove()).call(g => g.selectAll(".tick line").attr("stroke-opacity", 0.1).attr("x1", -innerW));
            
            const xAxisOsc = d3.axisBottom(oscX).ticks(4);
            g.append("g").attr("class", "axis-label").attr("transform", `translate(0,${innerH})`).call(xAxisOsc).select(".domain").remove();

            const lineGen = d3.line().x(d => oscX(d.date)).y(d => oscillatorMode === 'PERCENT' ? oscY(d.ratio) : oscY(d.sigma));
            const focusCircles = [];

            // Draw reverse so main is on top visually
            for(let i = multiData.length - 1; i >= 0; i--) {
                const series = multiData[i];
                const color = METRIC_COLORS[i % METRIC_COLORS.length];
                g.append("path")
                 .datum(series.ratios)
                 .attr("fill", "none")
                 .attr("stroke", color)
                 .attr("stroke-width", series.isMain ? 1.5 : 1.2)
                 .attr("stroke-dasharray", series.isMain ? "none" : "4,2")
                 .attr("d", lineGen);
            }

            multiData.forEach((series, i) => {
                const color = METRIC_COLORS[i % METRIC_COLORS.length];
                focusCircles.push(g.append("circle").attr("r", 4).attr("fill", color).attr("stroke", "#000").style("opacity", 0));
            });

            const focusText = g.append("text").attr("font-size", "11px").attr("font-family", "monospace").attr("text-anchor", "middle").style("opacity", 0).style("pointer-events", "none"); 

            g.append("rect").attr("width", innerW).attr("height", innerH).attr("fill", "transparent")
                .on("mousemove", function(event) {
                    const [mx] = d3.pointer(event);
                    const dateVal = oscX.invert(mx);
                    
                    let activeLines = [];
                    let yPosForText = null;

                    multiData.forEach((series, i) => {
                        const idx = d3.bisector(d => d.date).left(series.ratios, dateVal);
                        const validIdx = Math.min(Math.max(0, idx), series.ratios.length - 1);
                        const d = series.ratios[validIdx];

                        if (d && Math.abs(d.date - dateVal) < 86400000 * 3) {
                            const color = METRIC_COLORS[i % METRIC_COLORS.length];
                            const currentY = oscillatorMode === 'PERCENT' ? oscY(d.ratio) : oscY(d.sigma);
                            focusCircles[i].style("opacity", 1).attr("cx", oscX(d.date)).attr("cy", currentY);
                            
                            let lineText;
                            if (oscillatorMode === 'PERCENT') {
                                const pct = Math.round((d.ratio - 1) * 100);
                                const sign = pct > 0 ? "+" : "";
                                lineText = `${series.symbol}: ${d.ratio.toFixed(2)}x (${sign}${pct}%)`;
                            } else {
                                const sig = d.sigma;
                                const sign = sig > 0 ? "+" : "";
                                lineText = `${series.symbol}: ${sign}${sig.toFixed(2)}σ`;
                            }
                            
                            activeLines.push({ text: lineText, color: color, yPos: currentY });

                            if (yPosForText === null || currentY < yPosForText) yPosForText = currentY; 
                        } else {
                            focusCircles[i].style("opacity", 0);
                        }
                    });

                    if (activeLines.length > 0) {
                        const dateStr = dateVal.toLocaleDateString('en-GB', { day: 'numeric', month: 'short', year: '2-digit' });
                        
                        let tx = mx;
                        if (tx < 60) tx = 60;
                        if (tx > innerW - 60) tx = innerW - 60;

                        const blockHeight = (activeLines.length + 1) * 13;
                        let startY = yPosForText - 15;
                        
                        // Smart Offset
                        if (startY - blockHeight < 10) {
                            let minY = Math.max(...activeLines.map(l => l.yPos));
                            startY = minY + blockHeight + 5;
                        }

                        focusText.style("opacity", 1).attr("x", tx).attr("y", startY);
                        focusText.selectAll("tspan").remove();
                        
                        focusText.append("tspan").attr("x", tx).attr("dy", 0).attr("fill", "#a1a1aa").text(dateStr);
                        activeLines.forEach((line) => {
                            focusText.append("tspan").attr("x", tx).attr("dy", "1.2em").attr("fill", line.color).text(line.text);
                        });
                    } else {
                        focusText.style("opacity", 0);
                        focusCircles.forEach(c => c.style("opacity", 0));
                    }
                })
                .on("mouseout", () => {
                    focusText.style("opacity", 0);
                    focusCircles.forEach(c => c.style("opacity", 0));
                });
        }

        function calculateRegression(data) {
            const n = data.length;
            let sumX = 0, sumY = 0, sumXY = 0, sumXX = 0, sumYY = 0;
            data.forEach(d => {
                const lnX = Math.log(d.days);
                const lnY = Math.log(d.close);
                sumX += lnX; sumY += lnY;
                sumXY += lnX * lnY;
                sumXX += lnX * lnX; 
                sumYY += lnY * lnY;
            });
            const slope = (n * sumXY - sumX * sumY) / (n * sumXX - sumX * sumX);
            const intercept = (sumY - slope * sumX) / n;
            const r = (n * sumXY - sumX * sumY) / Math.sqrt((n * sumXX - sumX * sumX) * (n * sumYY - sumY * sumY));
            const residuals = data.map(d => Math.log(d.close) - (slope * Math.log(d.days) + intercept));
            const stdDev = Math.sqrt(residuals.map(r => r * r).reduce((a, b) => a + b) / n);
            return { slope, intercept, r2: r * r, stdDev };
        }

        function handleLineHover(e, d, isMean = false, index = null) {
            const [mx, my] = d3.pointer(e, chartArea.node());
            const days = xScale.invert(mx);
            const dev = isMean ? 0 : d.dev;
            const label = isMean ? 'Fair Value (Mean)' : d.label;
            const color = isMean ? '#fbce03' : d.color;
            
            const price = Math.exp(regressionMeta.slope * Math.log(days) + regressionMeta.intercept + (dev * regressionMeta.stdDev));
            const date = new Date(currentAnchorTime * 1000);
            date.setDate(date.getDate() + days);

            tooltip.style("display", "block").html(`
                <div class="text-[11px] font-black uppercase mb-1" style="color: ${color}">${label}</div>
                <div class="border-t border-slate-800 pt-1.5 mt-1.5 grid grid-cols-2 gap-x-4 gap-y-1 text-[11px]">
                    <span class="text-slate-500 uppercase font-mono">Date:</span> <span>${date.toLocaleDateString('en-US', {year:'numeric', month:'short', day:'numeric'})}</span>
                    <span class="text-slate-500 uppercase font-mono">Price:</span> <span class="text-white font-bold font-mono">$${price.toLocaleString(undefined, {maximumFractionDigits: 2})}</span>
                    <span class="text-slate-500 uppercase font-mono">Sigma:</span> <span>${dev.toFixed(1)}σ</span>
                </div>
            `);
            
            updateMainTooltipPosition(e);

            if (isMean) {
                chartArea.select(".regression-line").style("stroke-width", "5px");
            } else if (index !== null) {
                chartArea.select(`.band-line-${index}`).style("stroke-opacity", "1.0").style("stroke-width", (d.weight + 2) + "px");
            }
        }

        function removeGlow(index = null) {
            tooltip.style("display", "none");
            if (index === null) {
                chartArea.select(".regression-line").style("stroke-width", "3.5px");
            } else {
                const b = BANDS_CONFIG[index];
                chartArea.select(`.band-line-${index}`).style("stroke-opacity", b.opacity).style("stroke-width", b.weight + "px");
            }
        }

        function updateElements(currXScale, currYScale) {
            xScale = currXScale;
            yScale = currYScale;
            gX.call(xAxis.scale(currXScale));
            gY.call(yAxis.scale(currYScale));

            const minD = currXScale.domain()[0];
            const maxD = currXScale.domain()[1];
            const xRange = d3.range(Math.log(Math.max(0.1, minD)), Math.log(maxD), (Math.log(maxD) - Math.log(Math.max(0.1, minD)))/250).map(Math.exp);

            const lineGen = d3.line().x(d => currXScale(d));

            chartArea.select(".regression-line").attr("d", lineGen.y(d => currYScale(Math.exp(regressionMeta.slope * Math.log(d) + regressionMeta.intercept)))(xRange));

            BANDS_CONFIG.forEach((b, i) => {
                const pathData = lineGen.y(d => currYScale(Math.exp(regressionMeta.slope * Math.log(d) + regressionMeta.intercept + (b.dev * regressionMeta.stdDev))))(xRange);
                chartArea.select(`.band-line-${i}`).attr("d", pathData);
                chartArea.select(`.hitbox-${i}`).attr("d", pathData);
            });

            const candles = chartArea.selectAll(".candle-group");
            candles.select(".wick").attr("x1", d => currXScale(d.days)).attr("x2", d => currXScale(d.days)).attr("y1", d => currYScale(d.high)).attr("y2", d => currYScale(d.low));
            candles.select("rect").attr("x", d => currXScale(d.days) - 1.25).attr("y", d => currYScale(Math.max(d.open, d.close))).attr("height", d => Math.max(0.6, Math.abs(currYScale(d.open) - currYScale(d.close))));
        }

        function zoomed(event) {
            updateElements(event.transform.rescaleX(originalXScale), event.transform.rescaleY(originalYScale));
        }

        function renderChart() {
            if (!globalData || globalData.length === 0) return;

            const isDesktop = window.innerWidth >= 1280;

            originalXScale = d3.scaleLog().domain([d3.min(globalData, d => d.days), d3.max(globalData, d => d.days) * 3]).range([0, width]);
            originalYScale = d3.scaleLog().domain([d3.min(globalData, d => d.low) * 0.4, d3.max(globalData, d => d.high) * 12]).range([height, 0]);

            xScale = originalXScale;
            yScale = originalYScale;

            xAxis = d3.axisBottom(originalXScale).ticks(10).tickFormat(d => {
                const date = new Date(currentAnchorTime * 1000);
                date.setDate(date.getDate() + d);
                return date.getFullYear();
            }).tickSize(-height);

            yAxis = d3.axisRight(originalYScale).ticks(15, d => {
                if (d >= 1000000) return "$" + (d/1000000).toLocaleString() + "M";
                if (d >= 1000) return "$" + (d/1000).toLocaleString() + "k";
                if (d >= 1) return "$" + d.toLocaleString();
                return "$" + d.toFixed(3);
            }).tickSize(-width);

            chartArea.selectAll("*").remove();

            BANDS_CONFIG.forEach((b, i) => {
                chartArea.append("path").attr("class", `band-line band-line-${i}`).attr("stroke", b.color).attr("stroke-opacity", b.opacity).attr("stroke-width", b.weight);
                if (b.dash !== 'none') { chartArea.select(`.band-line-${i}`).attr("stroke-dasharray", b.dash); }

                const hitbox = chartArea.append("path").attr("class", `line-hitbox hitbox-${i}`)
                    // FIX BUG: Apply d attribute immediately for path data
                    .attr("d", d3.line().x(d => xScale(d)).y(d => yScale(Math.exp(regressionMeta.slope * Math.log(d) + regressionMeta.intercept + (b.dev * regressionMeta.stdDev))))(d3.range(Math.log(Math.max(0.1, xScale.domain()[0])), Math.log(xScale.domain()[1]), (Math.log(xScale.domain()[1]) - Math.log(Math.max(0.1, xScale.domain()[0])))/250).map(Math.exp))); 
                
                if (isDesktop) {
                    hitbox.on("mouseover", (e) => handleLineHover(e, b, false, i)).on("mousemove", (e) => handleLineHover(e, b, false, i)).on("mouseout", () => removeGlow(i));
                }
            });

            const regLine = chartArea.append("path").attr("class", "regression-line");
            
            if (isDesktop) {
                regLine.on("mouseover", (e) => handleLineHover(e, null, true)).on("mousemove", (e) => handleLineHover(e, null, true)).on("mouseout", () => removeGlow());
            }

            const candleGroups = chartArea.selectAll(".candle-group").data(globalData).enter().append("g").attr("class", "candle-group");
            candleGroups.append("line").attr("class", "wick");
            candleGroups.append("rect").attr("width", 2.5).attr("class", d => d.close >= d.open ? "candle-up" : "candle-down");
            
            if (isDesktop) {
                candles = chartArea.selectAll(".candle-up, .candle-down");
                candles.on("mouseover", (e, d) => {
                    const dev = (Math.log(d.close) - (regressionMeta.slope * Math.log(d.days) + regressionMeta.intercept)) / regressionMeta.stdDev;
                    tooltip.style("display", "block").html(`
                        <div class="text-white font-bold border-b border-slate-900 pb-1.5 mb-2 font-mono">${d.date.toLocaleDateString('en-US', {year:'numeric', month:'short', day:'numeric'})}</div>
                        <div class="grid grid-cols-2 gap-x-4 gap-y-1 text-[11px] font-mono">
                            <span class="text-slate-500 uppercase">Price:</span> <span class="text-yellow-500 font-bold">$${d.close.toLocaleString()}</span>
                            <span class="text-slate-500 uppercase">Age:</span> <span>${Math.floor(d.days)} d</span>
                            <span class="text-slate-500 uppercase">Dev:</span> <span style="color: ${dev > 0 ? '#ff1e56' : '#2de1fc'}" class="font-bold">${dev.toFixed(3)}σ</span>
                            <span class="text-slate-500 uppercase">Zone:</span> <span class="text-slate-300 italic">
                                ${dev > 1.8 ? 'Peak' : dev > 1.3 ? 'Extreme' : dev > 0.8 ? 'Overbought' : dev > -0.8 ? 'Fair' : dev > -1.3 ? 'Accumulate' : dev > -1.8 ? 'Deep Value' : 'Bottom'}
                            </span>
                        </div>
                    `);
                    updateMainTooltipPosition(e);
                })
                .on("mousemove", (e) => updateMainTooltipPosition(e))
                .on("mouseout", () => tooltip.style("display", "none"));
            }

            updateElements(originalXScale, originalYScale);
        }

        async function analyze(symbol) {
            d3.select("#loader").style("display", "flex");
            d3.select("#loader p").text("Calibrating engine...");
            
            try {
                const response = await fetch(`https://min-api.cryptocompare.com/data/v2/histoday?fsym=${symbol.toUpperCase()}&tsym=USD&allData=true&api_key=${HARDCODED_API_KEY}`);
                const json = await response.json();
                if (json.Response === "Error") throw new Error(json.Message);
                const rawData = json.Data.Data.filter(d => d.close > 0);
                const firstTimestamp = rawData[0].time;
                currentAnchorTime = symbol.toUpperCase() === 'BTC' ? GENESIS_BLOCK_TIMESTAMP : firstTimestamp;

                globalData = rawData.map(d => ({
                    ...d,
                    days: Math.max(1, (d.time - currentAnchorTime) / SECONDS_IN_DAY),
                    date: new Date(d.time * 1000)
                }));

                currentMainSymbol = symbol.toUpperCase();
                tickerInput.value = currentMainSymbol;

                // Sync Labels
                const metricsLabel = document.getElementById('metricsMainTickerLabel');
                if (metricsLabel) metricsLabel.innerText = currentMainSymbol;
                const oscLabel = document.getElementById('oscMainTickerLabel');
                if (oscLabel) oscLabel.innerText = currentMainSymbol;

                regressionMeta = calculateRegression(globalData);
                d3.select("#slopeVal").text(regressionMeta.slope.toFixed(4));
                d3.select("#r2Val").text(regressionMeta.r2.toFixed(4));
                
                // Auto Refresh Open Panels
                if(document.getElementById('oscillator-panel').style.display !== 'none') runOscillatorAnalysis();
                if(document.getElementById('metrics-panel').style.display !== 'none') runMetricsAnalysis();
                
                renderChart();

            } catch (err) { 
                console.error(err); 
                alert("Failed to load chart data. Please check the API key or try again later.\nError: " + err.message);
                tickerInput.value = currentMainSymbol;
            }
            finally { 
                d3.select("#loader").style("display", "none"); 
                isSyncing = false; 
            }
        }

        async function triggerUpdate() {
            isSyncing = true;
            setupCanvas();
            await analyze(tickerInput.value);
        }

        // --- NEW: MULTI-TICKER OSCILLATOR ---
        async function runOscillatorAnalysis() {
            if (!globalData || globalData.length === 0) return;
            
            const btn = document.getElementById('oscCompareBtn');
            btn.innerText = "LOADING...";
            btn.disabled = true;
            
            try {
                const results = [];
                
                // Main Ticker setup
                const mainRatios = globalData.map(d => {
                    const predicted = Math.exp(regressionMeta.slope * Math.log(d.days) + regressionMeta.intercept);
                    return { time: d.time, ratio: d.close / predicted, date: d.date };
                });
                results.push({ symbol: currentMainSymbol, isMain: true, ratios: mainRatios, stdDev: regressionMeta.stdDev });

                const inputVal = document.getElementById('oscCompareInput').value;
                if (inputVal && inputVal.trim() !== "") {
                    const compareSymbols = inputVal.split(',').map(s => s.trim().toUpperCase()).filter(s => s && s !== currentMainSymbol);
                    
                    for (const sym of compareSymbols) {
                        const res = await fetch(`https://min-api.cryptocompare.com/data/v2/histoday?fsym=${sym}&tsym=USD&allData=true&api_key=${HARDCODED_API_KEY}`);
                        const json = await res.json();
                        if (json.Response === "Success" && json.Data && json.Data.Data) {
                            const rawData = json.Data.Data.filter(d => d.close > 0);
                            if (rawData.length > 180) {
                                const anchor = sym === 'BTC' ? GENESIS_BLOCK_TIMESTAMP : rawData[0].time;
                                const clean = rawData.map(d => ({
                                    close: d.close, 
                                    days: Math.max(1, (d.time - anchor) / SECONDS_IN_DAY),
                                    date: new Date(d.time * 1000),
                                    time: d.time
                                }));
                                const meta = calculateRegression(clean);
                                const ratios = clean.map(d => {
                                    const predicted = Math.exp(meta.slope * Math.log(d.days) + meta.intercept);
                                    return { time: d.time, ratio: d.close / predicted, date: d.date };
                                });
                                results.push({ symbol: sym, isMain: false, ratios: ratios, stdDev: meta.stdDev });
                            }
                        }
                    }
                }
                lastOscillatorResults = results; // Cache for mode switching
                renderOscillatorCharts(results);
            } catch (err) {
                console.error(err);
                alert("Error fetching oscillator comparison data.");
            } finally {
                btn.innerText = "COMPARE";
                btn.disabled = false;
            }
        }

        async function runMetricsAnalysis() {
            if (!globalData || globalData.length === 0) return;
            
            const btn = document.getElementById('metricsCompareBtn');
            btn.innerText = "LOADING...";
            btn.disabled = true;
            
            try {
                const results = [];
                const mainHistory = calculateMetricsHistory(globalData);
                results.push({ symbol: currentMainSymbol, history: mainHistory });

                const inputVal = document.getElementById('metricsCompareInput').value;
                if (inputVal && inputVal.trim() !== "") {
                    const compareSymbols = inputVal.split(',').map(s => s.trim().toUpperCase()).filter(s => s && s !== currentMainSymbol);
                    
                    for (const sym of compareSymbols) {
                        const res = await fetch(`https://min-api.cryptocompare.com/data/v2/histoday?fsym=${sym}&tsym=USD&allData=true&api_key=${HARDCODED_API_KEY}`);
                        const json = await res.json();
                        if (json.Response === "Success" && json.Data && json.Data.Data) {
                            const rawData = json.Data.Data.filter(d => d.close > 0);
                            if (rawData.length > 180) {
                                const anchor = sym === 'BTC' ? GENESIS_BLOCK_TIMESTAMP : rawData[0].time;
                                const clean = rawData.map(d => ({
                                    close: d.close, 
                                    days: Math.max(1, (d.time - anchor) / SECONDS_IN_DAY),
                                    date: new Date(d.time * 1000)
                                }));
                                const history = calculateMetricsHistory(clean);
                                results.push({ symbol: sym, history: history });
                            }
                        }
                    }
                }
                renderMetricsCharts(results);
            } catch (err) {
                console.error(err);
                alert("Error fetching metrics comparison data.");
            } finally {
                btn.innerText = "COMPARE";
                btn.disabled = false;
            }
        }

        async function runScanner() {
            const body = document.getElementById('scanner-body');
            const limit = 100; 
            try {
                body.innerHTML = `<tr><td colspan="4" class="text-center py-20 text-yellow-500 font-bold animate-pulse">FETCHING MARKET DATA...</td></tr>`;
                const res = await fetch(`https://min-api.cryptocompare.com/data/top/mktcapfull?limit=${limit}&tsym=USD&api_key=${HARDCODED_API_KEY}`);
                const listJson = await res.json();
                if (!listJson.Data) throw new Error("API Limit");
                
                scannerData = [];
                let count = 0;

                for (const item of listJson.Data) {
                    const symbol = item.CoinInfo.Name;
                    count++;
                    body.innerHTML = `<tr><td colspan="4" class="text-center py-20 text-yellow-500 font-bold font-mono">SCANNING: ${symbol} (${count}/${limit})</td></tr>`;

                    try {
                        const histRes = await fetch(`https://min-api.cryptocompare.com/data/v2/histoday?fsym=${symbol}&tsym=USD&allData=true&api_key=${HARDCODED_API_KEY}`);
                        const json = await histRes.json();
                        if (json.Response === 'Success' && json.Data && json.Data.Data) {
                            const raw = json.Data.Data.filter(d => d.close > 0);
                            if (raw.length > 180) { 
                                const anchor = symbol === 'BTC' ? GENESIS_BLOCK_TIMESTAMP : raw[0].time;
                                const clean = raw.map(d => ({ close: d.close, days: Math.max(1, (d.time - anchor) / SECONDS_IN_DAY) }));
                                const stats = calculateRegression(clean);
                                const score = stats.slope * stats.r2; 
                                scannerData.push({ symbol, slope: stats.slope, r2: stats.r2, score: score });
                            }
                        }
                        await new Promise(r => setTimeout(r, 20)); 
                    } catch (e) { console.warn(`Skipped ${symbol}`); }
                }
                sortScanner('score', true); 
            } catch (e) {
                body.innerHTML = `<tr><td colspan="4" class="text-center py-20 text-red-500 font-bold">SCAN ERROR<br><span class="text-[9px]">API Key Exhausted</span></td></tr>`;
            }
        }

        function sortScanner(key, force = false) {
            if (!force && sortKey === key) sortDir *= -1;
            else if (!force) sortDir = -1;
            sortKey = key;
            scannerData.sort((a, b) => (a[key] > b[key] ? 1 : -1) * sortDir);
            renderScanner();
        }

        function renderScanner() {
            const body = document.getElementById('scanner-body');
            body.innerHTML = scannerData.map(d => `
                <tr class="scanner-row" onclick="loadFromScanner('${d.symbol}')">
                    <td class="text-white font-bold">${d.symbol}</td>
                    <td class="text-slate-400">${d.slope.toFixed(4)}</td>
                    <td class="text-slate-400">${d.r2.toFixed(4)}</td>
                    <td class="highlight-score">${d.score.toFixed(4)}</td>
                </tr>
            `).join('');
        }

        function loadFromScanner(symbol) {
            tickerInput.value = symbol;
            triggerUpdate();
        }

        window.onload = async () => { 
            setupCanvas();
            fetchAutocompleteData();
            await analyze("BTC");
        };

        window.onresize = () => { 
            if (window.innerWidth !== lastWindowWidth) {
                lastWindowWidth = window.innerWidth; 
                setupCanvas(); 
                if (globalData.length > 0) {
                    renderChart(); 
                    if(document.getElementById('oscillator-panel').style.display !== 'none') runOscillatorAnalysis(); 
                    if(document.getElementById('metrics-panel').style.display !== 'none') runMetricsAnalysis(); 
                }
            }
        };

        d3.select("#updateBtn").on("click", triggerUpdate);
        tickerInput.addEventListener('focus', function() { this.value = ''; });
        tickerInput.addEventListener('blur', function() { 
            setTimeout(() => { if (!isSyncing && this.value.trim() !== currentMainSymbol) this.value = currentMainSymbol; }, 200);
        });
    </script>
</body>
</html>